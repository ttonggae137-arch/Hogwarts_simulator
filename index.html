<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Hogwarts Simulator â€” ì„¤ì • Â· ê´€ê³„ë„ Â· ìŠ¤í† ë¦¬</title>
  <style>
    :root{
      --bg:#ffffff; --text:#111; --muted:#6b7280; --line:#e5e7eb;
      --card:#ffffff; --shadow:0 10px 30px rgba(0,0,0,.06); --radius:18px;
      --focus:0 0 0 4px rgba(59,130,246,.15);
      --chip:#f3f4f6; --chip2:#fafafa; --danger:#ef4444;
      --brownFade: rgba(56, 36, 18, .92);
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial,
        "Apple SD Gothic Neo","Noto Sans KR","Malgun Gothic", sans-serif;
      background:var(--bg);
      color:var(--text);
      line-height:1.4;
    }
    .wrap{max-width:1180px;margin:0 auto;padding:22px 18px 60px;}
    header{
      display:flex;align-items:flex-end;justify-content:space-between;gap:16px;
      padding:10px 6px 16px;border-bottom:1px solid var(--line);
    }
    h1{margin:0;font-size:22px;letter-spacing:-.2px;}
    .sub{margin:6px 0 0;font-size:13px;color:var(--muted);}
    .pill{
      font-size:12px;color:#111;border:1px solid var(--line);
      padding:8px 10px;border-radius:999px;background:#fafafa;user-select:none;
      display:flex;gap:8px;align-items:center;white-space:nowrap;
    }
    .headerPills{
      display:flex;
      gap:8px;
      align-items:center;
    }
    .headerSettingsBtn{
.headerSettingsBtn{ cursor:pointer; background:#ffffff; box-shadow:0 4px 10px rgba(0,0,0,.04); transition:transform .15s ease, box-shadow .15s ease, background .15s ease;}
.headerSettingsBtn:hover{ transform:translateY(-1px); box-shadow:0 6px 14px rgba(0,0,0,.08);}
    }
    .dot{width:8px;height:8px;border-radius:999px;background:#9ca3af;display:inline-block}
    .dot.on{background:#22c55e}

    .appTabs{
      display:flex;gap:8px;padding:8px;border:1px solid var(--line);
      border-radius:999px;background:#fafafa;margin:16px 6px 0;
    }
    .appTab{
      flex:1;text-align:center;padding:12px 14px;border-radius:999px;
      font-size:13px;font-weight:950;cursor:pointer;user-select:none;
      border:1px solid transparent;color:var(--muted);background:transparent;
    }
    .appTab.active{
      background:#fff;border-color:var(--line);color:#111;
      box-shadow:0 6px 18px rgba(0,0,0,.05);
    }
    .appTab.disabled{
      opacity:.45; cursor:not-allowed;
    }

    main{padding:18px 6px 0;}
    .hidden{display:none !important;}

    .grid{display:grid;grid-template-columns: 1.10fr .90fr;gap:18px;}
    @media (max-width: 1040px){.grid{grid-template-columns:1fr;}}
    .card{background:var(--card);border:1px solid var(--line);border-radius:var(--radius);box-shadow:var(--shadow);padding:18px;}
    .card h2{margin:0 0 14px;font-size:16px;letter-spacing:-.2px;}
    .row{display:grid;gap:10px;margin-bottom:14px;}
    label{font-size:12px;color:var(--muted);font-weight:900;}
    input, select{
      width:100%;padding:12px 12px;border-radius:14px;border:1px solid var(--line);
      background:#fff;color:var(--text);outline:none;
      transition: box-shadow .15s ease, border-color .15s ease;
      font-size:14px;
    }
    input:focus, select:focus{border-color:#93c5fd;box-shadow:var(--focus);}
    .two{display:grid;grid-template-columns:1fr 1fr;gap:10px;}
    @media (max-width: 560px){.two{grid-template-columns:1fr;}}
    .actions{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px;}
    button{
      appearance:none;border:1px solid var(--line);background:#111;color:#fff;
      padding:12px 14px;border-radius:14px;font-weight:950;cursor:pointer;
      transition: transform .05s ease, opacity .15s ease, background .15s ease;
    }
    button:active{transform: translateY(1px)}
    button.secondary{background:#fff;color:#111;}
    button.ghost{background:#fff;color:var(--muted);}
    button.danger{background:#fff;color:var(--danger);border-color:#fecaca;}
    button:disabled{opacity:.45;cursor:not-allowed;}

    /* Play button area */
    .playBar{
      margin-top:16px;
      padding-top:14px;
      border-top:1px solid var(--line);
      display:flex;justify-content:flex-end;gap:10px;flex-wrap:wrap;
    }
    .playBtn{
      background:#2b1a0f;
      border-color:#3a2416;
      box-shadow:0 10px 25px rgba(43,26,15,.18);
    }
    .playBtn:hover{background:#24160d;}
    .playHint{
      margin-right:auto;
      font-size:12px;color:var(--muted);font-weight:900;align-self:center;
    }

    /* Traits (grouped) */
    .traitsHead{display:flex;align-items:center;justify-content:space-between;gap:10px;margin:8px 0 10px;}
    .small{font-size:12px;color:var(--muted);font-weight:900;}
    .counter{font-size:12px;border:1px solid var(--line);background:#fafafa;padding:8px 10px;border-radius:999px;white-space:nowrap;}
    .req{
      display:inline-flex;align-items:center;gap:6px;
      font-size:11px;font-weight:950;color:#111;
      padding:6px 8px;border-radius:999px;border:1px solid var(--line);background:var(--chip2);
      white-space:nowrap;
    }
    .req b{color:var(--danger);}

    details{border:1px solid var(--line);border-radius:16px;padding:10px 12px;background:#fff;}
    details + details{margin-top:10px;}
    summary{cursor:pointer;list-style:none;display:flex;align-items:center;justify-content:space-between;gap:10px;font-weight:950;font-size:13px;}
    summary::-webkit-details-marker{display:none}
    .badge{font-size:11px;padding:6px 8px;border-radius:999px;border:1px solid var(--line);background:var(--chip2);color:#111;font-weight:950;white-space:nowrap;}

    .traitGrid{margin-top:10px;display:flex;flex-wrap:wrap;gap:8px;}
    .chip{
      display:inline-flex;align-items:center;gap:8px;border:1px solid var(--line);
      background:#fff;border-radius:999px;padding:8px 10px;cursor:pointer;user-select:none;
      font-size:12px;font-weight:950;
      transition: box-shadow .15s ease, transform .05s ease, background .15s ease, border-color .15s ease, opacity .15s ease;
    }
    .chip:active{transform: translateY(1px)}
    .chip input{display:none}
    .chip .dot2{width:10px;height:10px;border-radius:999px;border:2px solid #9ca3af;display:inline-block;background:transparent;}
    .chip.on{border-color:#93c5fd;box-shadow:var(--focus);background:#f8fbff;}
    .chip.on .dot2{border-color:#60a5fa;background:#60a5fa;}
    .chip.disabled{opacity:.45;cursor:not-allowed;}
    .chip.value{border-style:dashed;}
    .chip.value.on{border-style:solid;}

    .topbar{display:flex;gap:10px;align-items:center;justify-content:space-between;margin-bottom:12px;}
    .search{flex:1;display:flex;align-items:center;gap:10px;border:1px solid var(--line);border-radius:14px;padding:10px 12px;background:#fff;}
    .search input{border:none;padding:0;border-radius:0}
    .search input:focus{box-shadow:none}
    .count{font-size:12px;color:var(--muted);white-space:nowrap;font-weight:950;}
    .list{display:grid;gap:10px;max-height:320px;overflow:auto;padding-right:4px;}
    .item{border:1px solid var(--line);border-radius:14px;padding:12px;display:flex;gap:10px;align-items:flex-start;justify-content:space-between;background:#fff;cursor:pointer;}
    .item:hover{background:#fafafa}
    .item.active{border-color:#93c5fd;box-shadow:var(--focus);background:#f8fbff;}
    .meta{display:grid;gap:6px;}
    .name{font-weight:950;font-size:14px;letter-spacing:-.2px}
    .tags{display:flex;gap:6px;flex-wrap:wrap;max-width:620px}
    .tag{font-size:11px;padding:6px 8px;border-radius:999px;background:var(--chip);border:1px solid var(--line);color:#111;font-weight:950;}
    .tag.soft{background:var(--chip2)}
    .tag.trait{background:#fff;border-style:dashed;color:#111}
    .rightMini{display:flex;gap:8px;align-items:center;}
    .miniBtn{font-size:12px;padding:8px 10px;border-radius:12px;background:#fff;color:#111;border:1px solid var(--line);font-weight:950;}

    .preview{display:grid;gap:10px;margin-top:14px;}
    .kv{display:grid;grid-template-columns: 90px 1fr;gap:10px;align-items:center;padding:10px 12px;border:1px solid var(--line);border-radius:14px;background:#fafafa;}
    .k{font-size:12px;color:var(--muted);font-weight:950}
    .v{font-size:14px;font-weight:950}
    .pvTraits{display:flex;gap:6px;flex-wrap:wrap}
    .note{margin-top:14px;font-size:12px;color:var(--muted);}

    /* Relationship tags */
    .relPill{
      display:inline-flex;align-items:center;gap:8px;
      font-size:11px;font-weight:950;color:#111;
      padding:6px 10px;border-radius:999px;border:1px solid var(--line);background:#fff;
      white-space:nowrap;
    }
    .relDot{width:10px;height:10px;border-radius:999px;background:#9ca3af;display:inline-block;border:1px solid rgba(0,0,0,.05)}
    .relLabel{font-weight:950}
    .rel_moru .relDot{background:#9ca3af;}
    .rel_aneun .relDot{background:#64748b;}
    .rel_friend .relDot{background:#3b82f6;}
    .rel_best .relDot{background:#22c55e;}
    .rel_love .relDot{background:#ec4899;}
    .rel_dislike .relDot{background:#f97316;}
    .rel_hate .relDot{background:#b91c1c;}

    /* Graph page */
    .graphTop{
      display:flex;justify-content:space-between;align-items:center;gap:10px;flex-wrap:wrap;
      margin:6px 0 12px;
    }
    .graphControls{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .graphControls input{width:260px;max-width:100%;}
    .graphCard{padding:12px;}
    svg{width:100%;height:640px;display:block;}
    @media (max-width:700px){svg{height:560px;}}
    .legend{display:flex;gap:10px;flex-wrap:wrap;margin-top:10px}
    .lg{display:flex;gap:8px;align-items:center;font-size:12px;color:var(--muted);}
    .sw{width:22px;height:10px;border-radius:999px;border:1px solid var(--line);background:#111;}
    .sw.moru{background:#9ca3af;}
    .sw.aneun{background:#64748b;}
    .sw.friend{background:#3b82f6;}
    .sw.best{background:#22c55e;}
    .sw.love{background:#ec4899;}
    .sw.dislike{background:#f97316;}
    .sw.hate{background:#b91c1c;}

    /* Story page */
    .storyShell{
      background: linear-gradient(180deg, #1f130a 0%, #2b1a0f 40%, #111 100%);
      color: #f3f4f6;
      border-radius: 22px;
      border: 1px solid rgba(255,255,255,.08);
      box-shadow: 0 18px 50px rgba(0,0,0,.25);
      padding: 18px;
    }
    .storyTop{
      display:flex;justify-content:space-between;align-items:flex-start;gap:12px;flex-wrap:wrap;
      margin-bottom: 14px;
    }
    .storyTitle{font-size:18px;font-weight:950;letter-spacing:-.2px;margin:0;}
    .storySub{margin:6px 0 0;color:rgba(243,244,246,.75);font-size:12px;font-weight:900;}
    .storyActions{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .storyActions button{background:#fff;color:#111;border-color:rgba(255,255,255,.2)}
    .storyActions button.ghost{background:transparent;color:rgba(243,244,246,.85);border-color:rgba(255,255,255,.18)}
    .storyGrid{display:grid;grid-template-columns:1fr;gap:12px;}

    .storyCard{
      background: rgba(0,0,0,.30);
      border: 1px solid rgba(255,255,255,.16);
      border-radius: 18px;
      padding: 14px;
      backdrop-filter: blur(6px);
    }
    .storyCard h3{margin:0 0 10px;font-size:13px;font-weight:950;letter-spacing:-.1px;}
    .storyCard p{margin:0;color:rgba(243,244,246,.82);font-size:13px;line-height:1.55;}
    .storyRoster{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px;}
    .storyChip{
      font-size:12px;font-weight:950;
      padding:8px 10px;border-radius:999px;
      background: rgba(255,255,255,.10);
      border: 1px solid rgba(255,255,255,.16);
      color: #fff;
    }

    .storyPanel{
      display:grid;gap:10px;
    }
    .storyButtons{
      display:flex;gap:10px;flex-wrap:wrap;align-items:center;justify-content:space-between;
    }
    .storyButtons .left{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .storyButtons .right{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .storyBtn{
      background:#ffffff;color:#111;border-color:rgba(255,255,255,.25);
    }
    .storyBtn.primary{
      background:#f3f4f6;color:#111;border-color:rgba(255,255,255,.30);
      box-shadow: 0 14px 40px rgba(0,0,0,.25);
    }
    .storyBtn.primary:hover{filter:brightness(.98)}
    .storyBtn.ghost{
      background:transparent;color:rgba(243,244,246,.85);
      border-color:rgba(255,255,255,.18);
    }
    .storyHint{
      font-size:12px;font-weight:900;color:rgba(243,244,246,.78);
      white-space:nowrap;
    }

    .logBox{
    .logBox:empty{display:none!important;}

      background: rgba(0,0,0,.18);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 18px;
      padding: 12px;
      max-height: 360px;
      overflow:auto;
    }
    .logTurn{
/* ë¹ˆ ë¡œê·¸ ì¹´ë“œ ìˆ¨ê¹€: logTurn ì•ˆì— logLineì´ í•˜ë‚˜ë„ ì—†ìœ¼ë©´ í‘œì‹œí•˜ì§€ ì•ŠìŒ */
.logTurn:not(:has(.logLine)){
  display:none !important;
}

      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding: 10px 12px;
      border-radius: 14px;
      background: rgba(0,0,0,.35);
      border: 1px solid rgba(255,255,255,.18);
      margin-top: 8px;
    }
.logTurn:empty{display:none;}

    .logTurn:first-child{margin-top:0;}
    .logTurn b{font-size:12px;color:#fff;letter-spacing:-.1px}
    .logLine{
      padding: 8px 10px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      margin-top: 8px;
      font-size: 13px;
      color: rgba(243,244,246,.88);
      line-height: 1.5;
    }
    .logLine em{font-style:normal;color:#fff;font-weight:950;}
    .logMeta{
      font-size:11px;color:rgba(243,244,246,.70);font-weight:900;
    }

    .toast{
      position:fixed;left:50%;bottom:18px;transform:translateX(-50%);
      background:#111;color:#fff;padding:10px 12px;border-radius:999px;
      font-size:12px;opacity:0;pointer-events:none;
      transition: opacity .18s ease, transform .18s ease;
      z-index: 9999;
    }
    .toast.show{opacity:1;transform:translateX(-50%) translateY(-6px);}

    /* Fade overlay */
    .fadeOverlay{
      position:fixed;inset:0;
      background: var(--brownFade);
      opacity:0;
      pointer-events:none;
      transition: opacity .38s ease;
      z-index: 9998;
    }
    .fadeOverlay.on{
      opacity:1;
      pointer-events:auto;
    }
.settingsModalOverlay{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  background:rgba(0,0,0,0.4);
  opacity:0;
  pointer-events:none;
  transition:opacity .2s ease;
  z-index:9999;
}
.settingsModalOverlay.on{
  opacity:1;
  pointer-events:auto;
}
.settingsModal{
  width:min(480px,100% - 32px);
  max-height:min(520px,100% - 64px);
  background:#F3F4F6;
  border-radius:14px;
  box-shadow:0 16px 32px rgba(15,23,42,.15);
  display:flex;
  flex-direction:column;
  overflow:hidden;
}
.settingsModalHeader{
  padding:14px 20px;
  display:flex;
  align-items:center;
  justify-content:space-between;
  border-bottom:1px solid #E5E7EB;
  color:#111827;
}
.settingsModalBody{
  padding:16px 20px;
  overflow-y:auto;
  color:#111827;
}
.settingsSection+ .settingsSection{
  margin-top:12px;
  padding-top:10px;
  border-top:1px solid #E5E7EB;
}
.settingsRow{
  display:flex;
  align-items:center;
  justify-content:space-between;
  gap:10px;
}
.settingsRowButtons button{
  flex:1 1 auto;
  border-radius:999px;
  padding:12px 18px;
  font-weight:600;
  font-size:14px;
  border:none;
  background:#111827;
  color:#ffffff;
  cursor:pointer;
  transition:transform .12s ease, box-shadow .12s ease, background .12s ease, opacity .12s ease;
}
.settingsRowButtons button:hover{
  transform:translateY(-1px);
  box-shadow:0 8px 20px rgba(15,23,42,.35);
  background:#020617;
}
.settingsRowButtons button:active{
  transform:translateY(0);
  box-shadow:0 4px 12px rgba(15,23,42,.28);
  opacity:.9;
}
.settingsModalFooter{
  padding:12px 20px;
  border-top:1px solid #E5E7EB;
  display:flex;
  justify-content:flex-end;
}

  
    
    .sortingQ{
      font-weight: 800;
      margin-bottom: 10px;
    }
    .chipRow{ display:flex; flex-wrap:wrap; gap:8px; }
    .chipBtn{
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      color: #fff;
      font-weight: 700;
      cursor: pointer;
      transition: transform .05s ease, background .15s ease;
    }
    .chipBtn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.10); }
    .chipBtn:disabled{ opacity:.45; cursor:not-allowed; transform:none; }
        
    .houseDot{
      display:inline-block;
      width:10px;height:10px;
      border-radius:999px;
      margin-left:8px;
      border:1px solid rgba(255,255,255,.25);
      vertical-align:middle;
      box-shadow: 0 0 0 2px rgba(0,0,0,.25) inset;
    }
    .house-gryff{ background: rgba(180,45,45,.95); }
    .house-slyth{ background: rgba(30,130,80,.95); }
    .house-raven{ background: rgba(45,95,180,.95); }
    .house-huff{ background: rgba(210,170,40,.95); }

    .logActionRow{ display:flex; flex-wrap:wrap; gap:8px; margin-top:6px; }
    .logBtn{
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      color: #fff;
      font-weight: 800;
      cursor: pointer;
      transition: transform .06s ease, background .15s ease;
    }
    .logBtn:hover{ transform: translateY(-1px); background: rgba(255,255,255,.10); }
    .logBtn:disabled{ opacity:.45; cursor:not-allowed; transform:none; }
        
    .traitsGrid{display:flex;flex-wrap:wrap;gap:8px;margin-top:6px}
    .traitBtn{
      padding:6px 10px;border-radius:999px;border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.06);cursor:pointer;font-weight:700
    }
    .traitBtn.on{background:rgba(255,255,255,.18)}
        
    .relTabs{
      display:flex;
      flex-wrap:wrap;
      gap:6px;
      margin-bottom:10px;
    }
    .relTabChip{
      border-radius:999px;
      border:1px solid var(--line);
      padding:4px 10px;
      font-size:12px;
      background:#eef2ff;
      color:#1f2937;
      cursor:pointer;
      white-space:nowrap;
    }
    .relTabChip.active{
      background:#3b82f6;
      color:#ffffff;
      border-color:#1d4ed8;
      font-weight:950;
    }
    .relBody{
      display:grid;
      gap:10px;
      max-height:260px;
      overflow:auto;
      padding-right:4px;
    }

    .relTooltip{
      position:absolute;
      padding:4px 8px;
      border-radius:999px;
      font-size:11px;
      background:rgba(15,23,42,.95);
      color:#f9fafb;
      pointer-events:none;
      z-index:9999;
      box-shadow:0 4px 10px rgba(0,0,0,.25);
      transform:translateY(-4px);
    }

.settings-btn{
  position:fixed;
  top:10px;
  right:10px;
  font-size:18px;
  background:#222;
  color:white;
  border:none;
  border-radius:50%;
  width:38px;
  height:38px;
  cursor:pointer;
  z-index:9999;
}

.settings-overlay{
  display:none;
  position:fixed;
  inset:0;
  background:rgba(0,0,0,0.55);
  z-index:9998;
  justify-content:flex-end;
}

.settings-panel{
  width:360px;
  background:white;
  height:100%;
  padding:20px;
  overflow-y:auto;
}

.setting-item{
  margin:14px 0;
}

/* =========================
   Better Checkbox Styling
   ========================= */
.settingsModalBody input[type="checkbox"]{
  appearance:none;
  -webkit-appearance:none;
  width:22px;
  height:22px;
  border-radius:6px;
  border:2px solid #4b5563;
  display:inline-block;
  position:relative;
  cursor:pointer;
  background:white;
  transition:background .15s ease, border .15s ease, box-shadow .15s ease, transform .08s ease;
}
.settingsModalBody input[type="checkbox"]:hover{
  box-shadow:0 6px 16px rgba(0,0,0,.18);
  transform:translateY(-1px);
}
.settingsModalBody input[type="checkbox"]:active{
  transform:scale(.96);
}
.settingsModalBody input[type="checkbox"]:checked{
  background:#2563eb;
  border-color:#2563eb;
}
.settingsModalBody input[type="checkbox"]:checked::after{
  content:"âœ”";
  color:white;
  position:absolute;
  font-size:16px;
  left:4px;
  top:-1px;
}








/* === Stronger, Clearer Centered Checkmark === */
.settingsModalBody input[type="checkbox"]:checked::after{
  content:"âœ“";
  color:white;
  position:absolute;
  top:50%;
  left:50%;
  transform:translate(-50%,-54%);
  font-size:15px;
  font-weight:900;
  text-shadow:0 0 0 white, 0 0 0 white;
}

</style>

</head>
<body>
  <div class="fadeOverlay" id="fade"></div>

<div id="settingsModalOverlay" class="settingsModalOverlay" aria-hidden="true">
  <div class="settingsModal" role="dialog" aria-modal="true" aria-labelledby="settingsModalTitle">
    <header class="settingsModalHeader">
      <h2 id="settingsModalTitle">ì„¤ì •</h2>
      <button type="button" id="settingsModalCloseBtn" class="settingsModalClose" aria-label="ì„¤ì • ë‹«ê¸°">âœ•</button>
    </header>
    <div class="settingsModalBody">
      <section class="settingsSection">
        <h3>ê²Œì„ ì„¤ì •</h3>
        <label class="settingsRow">
          <span>ìŠ¤í† ë¦¬ ìë™ ì €ì¥</span>
          <input type="checkbox" id="settingsAutoArchiveToggle" />
        </label>
      </section>

      <section class="settingsSection">
        <h3>ì €ì¥ / ë¶ˆëŸ¬ì˜¤ê¸°</h3>
        <div class="settingsRow settingsRowButtons">
          <button type="button" id="btnExportSave">í˜„ì¬ ì§„í–‰ ì €ì¥</button>
          <button type="button" id="btnImportSave">ì €ì¥ íŒŒì¼ ë¶ˆëŸ¬ì˜¤ê¸°</button>
          <input type="file" id="fileInputSave" accept=".hogsave,.json" style="display:none" />
        </div>
      </section>
    </div>

    <footer class="settingsModalFooter">
    </footer>
  </div>
</div>


  <div class="wrap">
    <header>
      <div>
        <h1>í˜¸ê·¸ì™€íŠ¸ ì‹œë®¬ë ˆì´í„°</h1>
      </div>
      <div class="headerPills">
        <div class="pill"><span class="dot" id="dot"></span><span id="statusText">ì €ì¥: 0ëª…</span></div>
        <button id="headerSettingsChip" class="pill headerSettingsBtn" type="button">âš™ ì„¤ì •</button>
      </div>
    </header>

    <div class="appTabs" role="tablist" aria-label="ë©”ì¸ íƒ­">
      <div class="appTab active" id="mainSettings" role="tab" tabindex="0" aria-selected="true">ì„¤ì •</div>
      <div class="appTab" id="mainGraph" role="tab" tabindex="0" aria-selected="false">ê´€ê³„ë„</div>
      <div class="appTab disabled" id="mainStory" role="tab" tabindex="0" aria-selected="false" aria-disabled="true">ìŠ¤í† ë¦¬</div>
      <div class="appTab" id="mainArchive" role="tab" tabindex="0" aria-selected="false">ê¸°ë¡</div>
    </div>

    <main>
      <!-- SETTINGS PAGE -->
      <section id="pageSettings" aria-label="ì„¤ì • í˜ì´ì§€">
        <div class="grid">
          <section class="card" aria-label="ìºë¦­í„° ìƒì„±">
            <h2>ìºë¦­í„° í¸ì§‘</h2>

            <div class="row">
              <label for="name">ì´ë¦„</label>
              <input id="name" type="text" placeholder="ì˜ˆ: ì´í‰í™”" maxlength="24" autocomplete="off" />
            </div>

            <div class="two">
              <div class="row">
                <label for="mbti">MBTI</label>
                <select id="mbti"><option value="" selected disabled>ì„ íƒâ€¦</option></select>
              </div>
              <div class="row">
                <label for="blood">í˜ˆí†µ</label>
                <select id="blood">
                  <option value="" selected disabled>ì„ íƒâ€¦</option>
                  <option value="ìˆœí˜ˆ">ìˆœí˜ˆ</option>
                  <option value="í˜¼í˜ˆ">í˜¼í˜ˆ</option>
                  <option value="ë¨¸ê¸€ íƒœìƒ">ë¨¸ê¸€ íƒœìƒ</option>
                  <option value="ë¶ˆëª…">ë¶ˆëª…</option>
                </select>
              </div>
            </div>

            <div class="row">
              <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap;">
                <label>íŠ¹ì„±</label>
                <div class="small">ìµœëŒ€ 2ê°œ ì„ íƒ (ì„ íƒ ì‚¬í•­)</div>
              </div>
              <div id="featsBox" class="traitGrid"></div>
            </div>

            <div class="traitsHead">
              <div style="display:flex;gap:10px;align-items:center;flex-wrap:wrap;">
                <div class="small">ì„±ê²© í‚¤ì›Œë“œ (ìµœëŒ€ 5ê°œ ì„ íƒ)</div>
                <div class="req"><b>í•„ìˆ˜</b> ê°€ì¹˜ê´€Â·ì‚¬ìƒ 1ê°œ ì´ìƒ</div>
              </div>
              <div class="counter"><strong id="traitCount">0</strong>/5</div>
            </div>

            <div id="traitsBox" class="row" style="gap:10px; margin-bottom:8px;"></div>
            <div class="small" id="traitHint" style="margin-top:6px;"></div>

            <div class="actions">
              <button id="addBtn" disabled>ì¶”ê°€</button>
              <button id="updateBtn" class="secondary" disabled>ìˆ˜ì • ì €ì¥</button>
              <button id="newBtn" class="ghost">ìƒˆë¡œ ì…ë ¥</button>
              <button id="deleteBtn" class="danger" disabled>ì„ íƒ ì‚­ì œ</button>
            </div>

            <p class="note">
              â€» ê´€ê³„(ëª¨ë¥´ëŠ”/ì•„ëŠ”/ì¹œêµ¬/ì ˆì¹œ/ì—°ì¸)ëŠ” <b>í”Œë ˆì´ì–´ê°€ ì§ì ‘ ìˆ˜ì • ë¶ˆê°€</b> (ì‹œë®¬ ì´ë²¤íŠ¸ë¡œë§Œ ë³€ê²½ë©ë‹ˆë‹¤.)<br/>
              â€» ìºë¦­í„°ë¥¼ ì¶”ê°€í•˜ë©´ ëª¨ë“  ìŒ ê´€ê³„ëŠ” ìë™ìœ¼ë¡œ <b>ëª¨ë¥´ëŠ” ì‚¬ì´</b>ë¡œ ì‹œì‘í•©ë‹ˆë‹¤.
            </p>

            <!-- PLAY BAR (shows after at least 2 characters) -->
            <div class="playBar hidden" id="playBar">
              <div class="playHint">ìºë¦­í„°ê°€ 2ëª… ì´ìƒ ì¤€ë¹„ë˜ì—ˆìŠµë‹ˆë‹¤. ìŠ¤í† ë¦¬ë¡œ ë„˜ì–´ê°€ ì£¼ì„¸ìš”.</div>
              <button id="playBtn" class="playBtn" type="button">í”Œë ˆì´</button>
            </div>
          </section>

          <aside class="card" aria-label="ìºë¦­í„° & ê´€ê³„ ìš”ì•½">
            <div class="topbar">
              <div class="search" title="ì´ë¦„/íƒœê·¸/í‚¤ì›Œë“œë¡œ ê²€ìƒ‰">
                <span style="font-size:12px;color:var(--muted);font-weight:950;">ê²€ìƒ‰</span>
                <input id="q" type="text" placeholder="ì´ë¦„, MBTI, í˜ˆí†µ, í‚¤ì›Œë“œâ€¦" autocomplete="off" />
              </div>
              <div class="count" id="countText">0ëª…</div>
            </div>

            <div class="list" id="list"></div>

            <div class="preview" aria-label="ì„ íƒ í”„ë¦¬ë·°">
              <div class="kv"><div class="k">ì´ë¦„</div><div class="v" id="pvPick">â€”</div></div>
              <div class="kv"><div class="k">MBTI</div><div class="v" id="pvMbti">â€”</div></div>
              <div class="kv"><div class="k">í˜ˆí†µ</div><div class="v" id="pvBlood">â€”</div></div>
              <div class="kv"><div class="k">í‚¤ì›Œë“œ</div><div class="v"><div class="pvTraits" id="pvTraits"></div></div></div>

              <div class="actions" style="margin-top:12px;">
                <button id="rightLoadToEdit" class="secondary" disabled>ì™¼ìª½ì— ë¶ˆëŸ¬ì˜¤ê¸°</button>
                <button id="rightDelete" class="danger" disabled>ì´ ìºë¦­í„° ì‚­ì œ</button>
              </div>
              <div class="note" style="margin-top:10px;">
                â€» ì‚­ì œëŠ” ë‘ ë²ˆ í´ë¦­ìœ¼ë¡œ í™•ì¸ë©ë‹ˆë‹¤.<br>ì‚­ì œí•˜ë©´ í•´ë‹¹ ìºë¦­í„°ì™€ ê´€ë ¨ëœ ê´€ê³„ë„ í•¨ê»˜ ì •ë¦¬ë©ë‹ˆë‹¤.
              </div>
            </div>

            <hr style="border:none;border-top:1px solid var(--line);margin:16px 0 14px;">

            <div class="topbar" style="margin-bottom:10px;">
              <div style="display:flex;flex-direction:column;gap:4px;">
                <div style="font-weight:950;font-size:13px;">ê´€ê³„ ìš”ì•½</div>
                <div class="note" style="margin:0;">(ì¹œë°€ë„ ë†’ì€ ìˆœìœ¼ë¡œ ì •ë ¬ Â· í‘œì‹œë§Œ)</div>
              </div>
              <div class="count" id="relCountText">0ìŒ</div>
            </div>

            <div class="search" style="margin-bottom:10px;" title="ê´€ê³„ ê²€ìƒ‰">
              <span style="font-size:12px;color:var(--muted);font-weight:950;">ê²€ìƒ‰</span>
              <input id="rq" type="text" placeholder="ì´ë¦„ìœ¼ë¡œ ê²€ìƒ‰â€¦" autocomplete="off" />
            </div>

            <div id="relList" style="display:grid;gap:10px;max-height:320px;overflow:auto;padding-right:4px;"></div>
          </aside>
        </div>
      </section>

      <!-- GRAPH PAGE -->
      <section id="pageGraph" class="hidden" aria-label="ê´€ê³„ë„ í˜ì´ì§€">
        <div class="graphTop">
          <div>
            <div style="font-weight:950;font-size:16px;letter-spacing:-.2px;">ê´€ê³„ë„</div>
            <div class="note" style="margin:6px 0 0;">ì„  ìƒ‰=ê´€ê³„ ìœ í˜• Â· êµµê¸°=ì¹œë°€ë„</div>
          </div>
          <div class="pill" id="graphPill">0ëª… Â· 0ì„ </div>
        </div>

        <div class="card graphCard">
          <div class="graphControls">
            <input id="filter" type="text" placeholder="ì´ë¦„ ê²€ìƒ‰(í•„í„°)â€¦" autocomplete="off">
            <button id="reload" class="secondary" type="button">ìƒˆë¡œê³ ì¹¨</button>
            <button id="toggleLabels" type="button">ê´€ê³„ ë¼ë²¨: ON</button>
            <button id="goSettings" class="secondary" type="button">ì„¤ì •ìœ¼ë¡œ</button>
          </div>
          <div class="note" style="margin-top:10px;">â€» ê¸°ë³¸ ìƒíƒœëŠ” â€˜ëª¨ë¥´ëŠ” ì‚¬ì´â€™ì´ë¯€ë¡œ, ì´ë²¤íŠ¸ë¡œ ë³€ê²½ëœ ê´€ê³„ì—ë§Œ ì„ ì´ í‘œì‹œë©ë‹ˆë‹¤.</div>
          <div style="margin-top:12px;border:1px solid var(--line);border-radius:16px;overflow:hidden;">
            <svg id="svg" viewBox="0 0 1000 640" role="img" aria-label="ê´€ê³„ë„ ê·¸ë˜í”„"></svg>
          </div>
          <div class="legend">
            <div class="lg"><span class="sw aneun"></span> ì•„ëŠ” ì‚¬ì´</div>
            <div class="lg"><span class="sw friend"></span> ì¹œêµ¬</div>
            <div class="lg"><span class="sw best"></span> ì ˆì¹œ</div>
            <div class="lg"><span class="sw love"></span> ì—°ì¸</div>
            <div class="lg"><span class="sw dislike"></span> ì‹«ì–´í•˜ëŠ” ì‚¬ì´</div>
            <div class="lg"><span class="sw hate"></span> í˜ì˜¤í•˜ëŠ” ì‚¬ì´</div>
          </div>
        </div>
      </section>

      <!-- STORY PAGE -->
      <section id="pageStory" class="hidden" aria-label="ìŠ¤í† ë¦¬ í˜ì´ì§€">
        <div class="storyShell">
          <div class="storyTop">
            <div>
              <p class="storyTitle">ìŠ¤í† ë¦¬</p>
              <p class="storySub" id="storySub">9ì›” 1í•™ë…„ Â· í˜¸ê·¸ì™€íŠ¸í–‰ ì—´ì°¨ ğŸš‚ (0/5)</p>
            </div>
            <div class="storyActions">
              <button id="storyBackSettings" class="secondary" type="button">ì„¤ì •</button>
              <button id="storyGoGraph" class="secondary" type="button">ê´€ê³„ë„</button>
              <button id="storyPrevLogs" class="secondary" type="button">ì´ì „ ë¡œê·¸ ë³´ê¸°</button>
              <button id="storyReset" class="ghost" type="button">ë¡œê·¸ ì´ˆê¸°í™”</button>
            </div>
          </div>

          <div class="storyGrid">
            <div class="storyCard">
              <h3>ë“±ì¥ ìºë¦­í„°</h3>
              <div class="storyRoster" id="storyRoster"></div>
            </div>

            <div class="storyCard storyPanel">
              <div class="storyButtons">
                <div class="left">
                  <button id="storyNext" class="storyBtn primary" type="button">ìŠ¤í† ë¦¬ ì§„í–‰</button>
                  <span class="storyHint" id="storyHint"></span>
                </div>
                <div class="right">
                  <span class="storyHint" id="storyDoneHint"></span>
                </div>
              </div>

              <div class="logBox" id="logBox" aria-label="ìŠ¤í† ë¦¬ ë¡œê·¸"></div>
              <div id="sortingPanel" class="sortingPanel" style="display:none;"></div>
            </div>
          </div>
        </div>
      </section>

      <section id="pageArchive" class="hidden" aria-label="ê¸°ë¡ í˜ì´ì§€">
        <div class="storyShell">
          <div class="storyTop">
            <div>
              <p class="storyTitle">ê¸°ë¡</p>
              <p class="storySub" id="archiveSub">ì§€ë‚œ í•™ë…„ì˜ ë¡œê·¸ë¥¼ ëª¨ì•„ë‘ëŠ” ê³³ì…ë‹ˆë‹¤.</p>
            </div>
            <div class="storyActions">
              <button id="archiveBackStory" class="secondary" type="button">ìŠ¤í† ë¦¬</button>
            </div>
          </div>

          <div class="storyGrid">
            <div class="storyCard">
              <h3>í•™ë…„ ì„ íƒ</h3>
              <div class="relTabs" id="archiveYearTabs"></div>
            </div>

            <div class="storyCard storyPanel">
              <div class="storyButtons">
                <div class="left">
                  <span class="storyHint" id="archiveHint">ì•„ì¹´ì´ë¸Œëœ í•™ë…„ ë¡œê·¸ë¥¼ ì—¬ê¸°ì—ì„œ ë³´ì‹¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</span>
                </div>
              </div>
              <div class="logBox" id="archiveLogBox" aria-label="ì´ì „ ë¡œê·¸"></div>
            </div>
          </div>
        </div>
      </section>
    </main>
  </div>

  <div class="toast" id="toast">ì™„ë£Œ!</div>

  <script>

    const MBTI_LIST = ["INTJ","INTP","ENTJ","ENTP","INFJ","INFP","ENFJ","ENFP","ISTJ","ISFJ","ESTJ","ESFJ","ISTP","ISFP","ESTP","ESFP"];

    // Trait groups (legacy list)
    const TRAIT_GROUPS = [
      { title: "ê¸°ë³¸ ì„±ê²©", items: ["ì‹ ì¤‘í•¨","ë‚™ì²œì ","ëƒ‰ì •í•¨","í˜¸ê¸°ì‹¬","ì„±ì‹¤í•¨"] },
      { title: "ì‚¬íšŒÂ·ê´€ê³„í˜•", items: ["ì‚¬êµì ","ê³ ë…í•¨","ì¹´ë¦¬ìŠ¤ë§ˆ","ëˆˆì¹˜ë¹ ë¦„","ì˜ì¡´ì "] },
      { title: "ê°€ì¹˜ê´€Â·ì‚¬ìƒ", items: ["í˜ˆí†µì¤‘ì‹œ","í‰ë“±ì£¼ì˜","ê¶Œìœ„ì¡´ì¤‘","ë°˜ê¶Œìœ„","ì´ìƒì£¼ì˜","í˜„ì‹¤ì£¼ì˜"] },
      { title: "ì•¼ë§Â·í–‰ë™ì„±", items: ["ì•¼ì‹¬ê°€","ëª¨í—˜ê°€","ê¸°íšŒì£¼ì˜ì","ì§‘ì°©í˜•","ì™„ë²½ì£¼ì˜"] },
      { title: "ë¶ˆì•ˆì •/í­ì£¼", items: ["ì¶©ë™ì ","ì˜ì‹¬ë§ìŒ","ë¶„ë…¸ì¡°ì ˆê³¤ë€","í—ˆë¬´ì£¼ì˜","ì´ì¤‘ì„±"] }
    ];
    const VALUE_TRAITS = new Set(TRAIT_GROUPS.find(g=>g.title==="ê°€ì¹˜ê´€Â·ì‚¬ìƒ").items);
    const TRAITS_ALL = TRAIT_GROUPS.flatMap(g=>g.items);
    const MAX_TRAITS = 5;

    // Relationship types
    const REL_TYPES = [
      { key:"moru",    label:"ëª¨ë¥´ëŠ” ì‚¬ì´",   rank:0, color:"#9ca3af", width:1.2 },
      { key:"aneun",   label:"ì•„ëŠ” ì‚¬ì´",     rank:1, color:"#64748b", width:1.8 },
      { key:"friend",  label:"ì¹œêµ¬",         rank:2, color:"#3b82f6", width:2.6 },
      { key:"best",    label:"ì ˆì¹œ",         rank:3, color:"#22c55e", width:3.4 },
      { key:"love",    label:"ì—°ì¸",         rank:4, color:"#ec4899", width:4.2 },
      { key:"dislike", label:"ì‹«ì–´í•˜ëŠ” ì‚¬ì´", rank:3, color:"#f97316", width:3.0 },
      { key:"hate",    label:"í˜ì˜¤í•˜ëŠ” ì‚¬ì´", rank:4, color:"#b91c1c", width:3.8 },
    ];
    const REL_BY_KEY = Object.fromEntries(REL_TYPES.map(r=>[r.key,r]));
    const DEFAULT_REL = "moru";

    // Storage v11
    const STORAGE_KEY = "hogwarts_sim_state_v11";
    const LEGACY_KEYS = ["hogwarts_sim_state_v10","hogwarts_sim_state_v9","hogwarts_sim_state_v8","hogwarts_sim_state_v7","hogwarts_sim_state_v6","hogwarts_sim_state_v5","hogwarts_sim_characters_v2"];

    // Story constants
    const TRAIN_TURNS_MAX = 5;
    const TRAITS = ["ëŒ€ë‹´í•¨","ì •ì˜ê°","ì‚¬êµì ","ê³ ë…í•¨","ì‹ ì¤‘í•¨","ì•¼ë§","ì„±ì‹¤í•¨","ë°°ë ¤","í˜¸ê¸°ì‹¬","ë¶„ì„ì "];
    const HOUSES = ["ê·¸ë¦¬í•€ë„ë¥´","ìŠ¬ë¦¬ë°ë¦°","ë˜ë²ˆí´ë¡œ","í›„í”Œí‘¸í”„"];
    const HOUSE_META = {
      "ê·¸ë¦¬í•€ë„ë¥´": { cls:"house-gryff" },
      "ìŠ¬ë¦¬ë°ë¦°": { cls:"house-slyth" },
      "ë˜ë²ˆí´ë¡œ": { cls:"house-raven" },
      "í›„í”Œí‘¸í”„": { cls:"house-huff" },
    };

    // Elements
    const toast = document.getElementById('toast');
    const fade = document.getElementById('fade');

    const statusText = document.getElementById('statusText');
    const dot = document.getElementById('dot');
    const headerSettingsChip = document.getElementById('headerSettingsChip');

    
const settingsModalOverlay = document.getElementById('settingsModalOverlay');
const settingsModalCloseBtn = document.getElementById('settingsModalCloseBtn');
const settingsAutoArchiveToggle = document.getElementById('settingsAutoArchiveToggle');
const btnExportSave = document.getElementById('btnExportSave');
const btnImportSave = document.getElementById('btnImportSave');
const fileInputSave = document.getElementById('fileInputSave');
const mainSettings = document.getElementById('mainSettings');
    const mainGraph = document.getElementById('mainGraph');
    const mainStory = document.getElementById('mainStory');
    const mainArchive = document.getElementById('mainArchive');

    const pageSettings = document.getElementById('pageSettings');
    const pageGraph = document.getElementById('pageGraph');
    const pageStory = document.getElementById('pageStory');
    const pageArchive = document.getElementById('pageArchive');

    const elName = document.getElementById('name');
    const elMbti = document.getElementById('mbti');
    const elBlood = document.getElementById('blood');

    const featsBox = document.getElementById("featsBox");

    const FEAT_LIST = ["ê°€ë¬¸ì˜ í›„ê³„ì","ë¶€ìœ í•œ ì§‘ì•ˆ","ì±…ë²Œë ˆ","ì²œì¬","ë¦¬ë”ì‹­","ìœ ë¦¬ ë©˜íƒˆ","ë°˜í•­ì•„","í–‰ìš´ì•„","ë³‘ì•½","ìš´ë™ê´‘"];
    const MAX_FEATS = 2;

    
    
    
    function renderFeats(){
      if (!featsBox || featsBox.dataset.ready) return;
      featsBox.dataset.ready = "1";
      featsBox.innerHTML = "";
      const details = document.createElement('details');
      details.open = true;

      const summary = document.createElement('summary');
      const left = document.createElement('div');
      const right = document.createElement('div');
      const badge = document.createElement('span'); badge.className = "badge"; badge.textContent = `${FEAT_LIST.length}ê°œ`;
      right.appendChild(badge);
      summary.appendChild(left);
      summary.appendChild(right);

      const grid = document.createElement('div'); grid.className = "traitGrid";

      FEAT_LIST.forEach(f=>{
        const lbl = document.createElement('label');
        lbl.className = "chip";
        const d = document.createElement('span'); d.className = "dot2";
        const cb = document.createElement('input'); cb.type="checkbox"; cb.setAttribute("data-feat", f);
        cb.addEventListener("change", ()=>{
          refreshFeatUI();
        });
        const tx = document.createElement('span'); tx.textContent = f;
        lbl.appendChild(d); lbl.appendChild(cb); lbl.appendChild(tx);
        grid.appendChild(lbl);
      });

      details.appendChild(summary);
      details.appendChild(grid);
      featsBox.appendChild(details);
      refreshFeatUI();
    }

function getSelectedFeats(){
      if (!featsBox) return [];
      const cbs = featsBox.querySelectorAll("input[type=checkbox][data-feat]");
      const arr = [];
      cbs.forEach(cb=>{ if (cb.checked) arr.push(cb.dataset.feat); });
      return arr.slice(0, MAX_FEATS);
    }


    const traitsBox = document.getElementById('traitsBox');
    const traitCount = document.getElementById('traitCount');
    const traitHint = document.getElementById('traitHint');

    const addBtn = document.getElementById('addBtn');

    function renderMbtiOptions(){
      // populate MBTI select once
      if (!elMbti) return;
      if (elMbti.dataset.ready) return;
      elMbti.dataset.ready = "1";
      // keep the first placeholder option if present
      const keepFirst = elMbti.querySelector("option[disabled]");
      elMbti.innerHTML = "";
      const ph = document.createElement("option");
      ph.value = "";
      ph.disabled = true;
      ph.selected = true;
      ph.textContent = "ì„ íƒâ€¦";
      elMbti.appendChild(ph);
      (MBTI_LIST || []).forEach(code=>{
        const opt = document.createElement("option");
        opt.value = code;
        opt.textContent = code;
        elMbti.appendChild(opt);
      });
    }

    function renderTraits(){
      if (!traitsBox) return;
      if (traitsBox.dataset.ready) return;
      traitsBox.dataset.ready = "1";

      const wrap = document.createElement("div");
      wrap.style.display = "grid";
      wrap.style.gridTemplateColumns = "repeat(auto-fit, minmax(150px, 1fr))";
      wrap.style.gap = "10px";

      (TRAIT_GROUPS || []).forEach(group=>{
        const card = document.createElement("div");
        card.style.padding = "10px";
        card.style.borderRadius = "14px";
        card.style.background = "rgba(255,255,255,.04)";
        card.style.border = "1px solid rgba(255,255,255,.10)";

        const title = document.createElement("div");
        title.style.fontWeight = "900";
        title.style.marginBottom = "6px";
        title.textContent = group.title;
        card.appendChild(title);

        group.items.forEach(t=>{
          const id = "trait_" + t.replace(/\s+/g,"_");
          const lab = document.createElement("label");
          lab.style.display = "flex";
          lab.style.alignItems = "center";
          lab.style.gap = "8px";
          lab.style.margin = "6px 0";
          lab.style.cursor = "pointer";

          const cb = document.createElement("input");
          cb.type = "checkbox";
          cb.setAttribute("data-trait", t);
          cb.addEventListener("change", ()=>{
            // enforce max traits
            const selected = getSelectedTraits();
            if (selected.length > MAX_TRAITS){
              cb.checked = false;
            }
            refreshTraitUI();
          });

          const span = document.createElement("span");
          span.textContent = t;

          lab.appendChild(cb);
          lab.appendChild(span);
          card.appendChild(lab);
        });

        wrap.appendChild(card);
      });

      traitsBox.innerHTML = "";
      traitsBox.appendChild(wrap);
      refreshTraitUI();
    }

    function updateTraitCounter(){
      if (!traitCount) return;
      const n = (getSelectedTraits() || []).length;
      traitCount.textContent = String(n);
      if (traitHint){
        traitHint.textContent = hasValueTrait(getSelectedTraits()) ? "" : "ê°€ì¹˜ê´€Â·ì‚¬ìƒ 1ê°œ ì´ìƒ ì„ íƒ!";
      }
    }

    function initFormUI(){
      renderMbtiOptions();
      buildTraitsUI();
      renderFeats();
    }

    const updateBtn = document.getElementById('updateBtn');
    const newBtn = document.getElementById('newBtn');
    const deleteBtn = document.getElementById('deleteBtn');

    const playBar = document.getElementById('playBar');
    const playBtn = document.getElementById('playBtn');

    const elQ = document.getElementById('q');
    const listEl = document.getElementById('list');
    const countText = document.getElementById('countText');

    const pvPick = document.getElementById('pvPick');
    const pvMbti = document.getElementById('pvMbti');
    const pvBlood = document.getElementById('pvBlood');
    const pvTraits = document.getElementById('pvTraits');

    const rightLoadToEdit = document.getElementById('rightLoadToEdit');
    const rightDelete = document.getElementById('rightDelete');

    const relCountText = document.getElementById('relCountText');
    const rq = document.getElementById('rq');
    const relList = document.getElementById('relList');

    const filterEl = document.getElementById('filter');
    const svg = document.getElementById('svg');
    const graphPill = document.getElementById('graphPill');
    const reloadBtn = document.getElementById('reload');
    const toggleLabelsBtn = document.getElementById('toggleLabels');
    const goSettingsBtn = document.getElementById('goSettings');

    // Story elements
    const storyRoster = document.getElementById('storyRoster');
    const storyBackSettings = document.getElementById('storyBackSettings');
    const storyGoGraph = document.getElementById('storyGoGraph');
    const storyPrevLogs = document.getElementById('storyPrevLogs');
    const storyNext = document.getElementById('storyNext');
    const storyReset = document.getElementById('storyReset');
    const logBox = document.getElementById('logBox');
    const storySub = document.getElementById('storySub');
    const storyHint = document.getElementById('storyHint');
    const storyDoneHint = document.getElementById('storyDoneHint');
    const sortingPanel = document.getElementById('sortingPanel');

    const archiveSub = document.getElementById('archiveSub');
    const archiveYearTabs = document.getElementById('archiveYearTabs');
    const archiveLogBox = document.getElementById('archiveLogBox');
    const archiveBackStory = document.getElementById('archiveBackStory');

    // State
    let characters = [];
    let selectedId = null;
    let relations = {};
    let showLabels = true;

    // Story state
    let story = {
      phase: "train",
      trainTurn: 0,
      prologueDone: false,
      greatHallIntroDone: false,
      arrivalDone: false,
      sortingMode: false,
      currentYear: 0,        // 0=í”„ë¡¤ë¡œê·¸, 1~7=í•™ë…„
      logsByYear: {},        // ì—°ë„ë³„ ì•„ì¹´ì´ë¸Œëœ ë¡œê·¸
      logsByVacation: {},    // ë°©í•™ ì•„ì¹´ì´ë¸Œ ë¡œê·¸ ("1-2" ë“±)
      logViewMode: "current",
      seasonIndex: 0,        // 0=ê°€ì„,1=ê²¨ìš¸,2=ë´„,3=ì—¬ë¦„
      seasonTurn: 0,         // ê° ê³„ì ˆë§ˆë‹¤ ì§„í–‰ëœ ë¡œê·¸ ìˆ˜
      vacationTurn: 0,       // ë°©í•™ ë™ì•ˆ ì§„í–‰ëœ ë¡œê·¸ ìˆ˜
      log: [],               // array of { turn, lines: [string], meta?: string }
      affinity: {},          // pairKey -> small numeric score for í˜¸ê°ë„
      readyForNewYear: false, // í•™ë…„ ì „í™˜ ì¤€ë¹„ í”Œë˜ê·¸
      owlExamByYear: {},     // ì—°ë„ë³„ O.W.L ì‹œí—˜ ë‹¹ì¼ ë³´ì •ê°’
      owlResultsByYear: {},  // ì—°ë„ë³„ O.W.L ì„±ì 
      owlResultsShownByYear: {} // ì—°ë„ë³„ ì„±ì  ì—´ëŒ ì—¬ë¶€
    };

    let owlTypingSkipRequested = false;


    let appOptions = { autoArchive: true };

    // Helpers
    const uid = () => (crypto?.randomUUID?.() || ("id_" + Math.random().toString(16).slice(2) + Date.now().toString(16)));
    const nowISO = () => new Date().toISOString();
    const normalize = (s) => (s || "").trim().replace(/\\s+/g, " ");
    function pickJosa(name, type){
      const s = String(name || "");
      if (!s) return "";

      const code = s.charCodeAt(s.length - 1);
      const HANGUL_BASE = 0xAC00;
      const HANGUL_LAST = 0xD7A3;

      let hasBatchim = false;
      let jong = 0;
      if (code >= HANGUL_BASE && code <= HANGUL_LAST){
        const offset = code - HANGUL_BASE;
        jong = offset % 28; // 0ì´ë©´ ë°›ì¹¨ ì—†ìŒ
        hasBatchim = jong !== 0;
      }

      switch (type){
        case "ì€ëŠ”":
          return hasBatchim ? "ì€" : "ëŠ”";
        case "ì´ê°€":
          return hasBatchim ? "ì´" : "ê°€";
        case "ì„ë¥¼":
          return hasBatchim ? "ì„" : "ë¥¼";
        case "ê³¼ì™€":
          return hasBatchim ? "ê³¼" : "ì™€";
        case "ìœ¼ë¡œë¡œ":
          // ë°›ì¹¨ ì—†ìœ¼ë©´ â†’ "ë¡œ", ë°›ì¹¨ ã„¹(jong===8)ì´ë©´ â†’ "ë¡œ", ê·¸ ì™¸ ë°›ì¹¨ ìˆìœ¼ë©´ â†’ "ìœ¼ë¡œ"
          if (!hasBatchim || jong === 8) return "ë¡œ";
          return "ìœ¼ë¡œ";
        default:
          return "";
      }
    }

    const pairKey = (a,b)=>[a,b].sort().join("::");

    function showToast(msg){
      toast.textContent = msg;
      toast.classList.add('show');
      window.clearTimeout(showToast._t);
      showToast._t = window.setTimeout(()=>toast.classList.remove('show'), 1200);
    }

    function setStatus(){
      const n = characters.length;
      statusText.textContent = `ì €ì¥: ${n}ëª…`;
      dot.classList.toggle('on', n > 0);
      countText.textContent = `${n}ëª…`;
    }

    function saveAll(){
      const payload = { version: 11, savedAt: nowISO(), selectedId, characters, relations, story, options: appOptions };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      setStatus();
      refreshGates();
    }

    function refreshGates(){
      const hasStart = characters.length >= 2; // user requested minimum 2
      playBar.classList.toggle('hidden', !hasStart);

      mainStory.classList.toggle('disabled', !hasStart);
      mainStory.setAttribute('aria-disabled', hasStart ? 'false' : 'true');

      // story controls
      storyNext.disabled = !hasStart || !story.prologueDone;
      storyReset.disabled = !hasStart;
      storyHint.textContent = "";
    }

    if (headerSettingsChip && settingsModalOverlay){
      headerSettingsChip.addEventListener('click', ()=>{
        // ì„¤ì • ëª¨ë‹¬ ì—´ê¸° + í˜„ì¬ ì˜µì…˜ ë°˜ì˜
        settingsModalOverlay.classList.add('on');
        settingsModalOverlay.setAttribute('aria-hidden','false');
        if (settingsAutoArchiveToggle){
          settingsAutoArchiveToggle.checked = !!appOptions.autoArchive;
        }
      });
    }

    function closeSettingsModal(){
      if (!settingsModalOverlay) return;
      settingsModalOverlay.classList.remove('on');
      settingsModalOverlay.setAttribute('aria-hidden','true');
    }

    if (settingsModalCloseBtn){
      settingsModalCloseBtn.addEventListener('click', closeSettingsModal);
    }
    if (settingsModalOverlay){
      settingsModalOverlay.addEventListener('click', (e)=>{
        if (e.target === settingsModalOverlay) closeSettingsModal();
      });
    }

    if (settingsAutoArchiveToggle){
      settingsAutoArchiveToggle.addEventListener('change', ()=>{
        appOptions.autoArchive = !!settingsAutoArchiveToggle.checked;
        const msg = appOptions.autoArchive
          ? "ìŠ¤í† ë¦¬ ìë™ ì €ì¥: ON (í•™ë…„ì´ ëë‚˜ë©´ 'ì´ì „ ë¡œê·¸ ë³´ê¸°'ì—ì„œ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.)"
          : "ìŠ¤í† ë¦¬ ìë™ ì €ì¥ì„ ê»ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ëˆ„ë¥´ë©´ ì¼¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.";
        showToast(msg);
        saveAll();
      });
    }

    if (btnExportSave){
      btnExportSave.addEventListener('click', ()=>{
        const payload = {
          version: 11,
          savedAt: nowISO(),
          selectedId,
          characters,
          relations,
          story,
          options: appOptions
        };
        try{
          const blob = new Blob([JSON.stringify(payload,null,2)], {type:"application/json"});
          const url = URL.createObjectURL(blob);
          const a = document.createElement("a");
          a.href = url;
          a.download = "hogwarts_save.hogsave";
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
          showToast("í˜„ì¬ ì§„í–‰ì„ íŒŒì¼ë¡œ ì €ì¥í–ˆìŠµë‹ˆë‹¤.");
        }catch(e){
          console.error(e);
          showToast("íŒŒì¼ ì €ì¥ ì¤‘ ì˜¤ë¥˜ê°€ ë‚¬ì–´.");
        }
      });
    }

    if (btnImportSave && fileInputSave){
      btnImportSave.addEventListener('click', ()=>{
        fileInputSave.value = "";
        fileInputSave.click();
      });

      fileInputSave.addEventListener('change', (e)=>{
        const file = e.target.files && e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev)=>{
          try{
            const data = JSON.parse(ev.target.result);
            if (!data || typeof data !== "object") throw new Error("invalid");
            localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
            showToast("ì €ì¥ íŒŒì¼ì„ ë¶ˆëŸ¬ì™”ì–´. í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ìƒˆë¡œê³ ì¹¨í• ê²Œ!");
            setTimeout(()=> location.reload(), 600);
          }catch(err){
            console.error(err);
            showToast("ì €ì¥ íŒŒì¼ì„ ì½ëŠ” ì¤‘ ì˜¤ë¥˜ê°€ ë‚¬ì–´.");
          }
        };
        reader.readAsText(file);
      });
    }


    function scrubRelations(){
      const ids = new Set(characters.map(c=>c.id));
      for (const k of Object.keys(relations)){
        const [a,b] = k.split("::");
        if (!ids.has(a) || !ids.has(b) || a===b) delete relations[k];
        else relations[k] = REL_BY_KEY[relations[k]] ? relations[k] : DEFAULT_REL;
      }
    }

    function ensureRelationsAllPairs(){
      for (let i=0;i<characters.length;i++){
        for (let j=i+1;j<characters.length;j++){
          const k = pairKey(characters[i].id, characters[j].id);
          if (!(k in relations)) relations[k] = DEFAULT_REL;
        }
      }
    }

    function migrateIfNeeded(){
      if (localStorage.getItem(STORAGE_KEY)) return;

      for (const key of LEGACY_KEYS){
        const raw = localStorage.getItem(key);
        if (!raw) continue;
        try{
          const data = JSON.parse(raw);
          characters = Array.isArray(data.characters) ? data.characters : [];

          // sanitize legacy feats / traits
          characters.forEach(c=>{
            if (!Array.isArray(c.feats)) c.feats = [];
            c.feats = c.feats.filter(f=>FEAT_LIST.includes(f)).slice(0, MAX_FEATS);

            if (!Array.isArray(c.traits)) c.traits = [];
            c.traits = c.traits.filter(t=>TRAITS_ALL.includes(t)).slice(0, MAX_TRAITS);
          });

          selectedId = data.selectedId || null;
          relations = (data.relations && typeof data.relations === "object") ? data.relations : {};
          story = (data.story && typeof data.story === "object") ? data.story : story;

          scrubRelations();
          ensureRelationsAllPairs();
          saveAll();
          return;
        }catch(e){}
      }
    }

function loadAll(){
      migrateIfNeeded();
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw){
        characters = [];
        selectedId = null;
        relations = {};
        setStatus();
        refreshGates();
        return;
      }
      try{
        const data = JSON.parse(raw);

        // characters
        characters = Array.isArray(data.characters) ? data.characters : [];
        characters.forEach(c=>{
          if (!Array.isArray(c.feats)) c.feats = [];
          c.feats = c.feats.filter(f=>FEAT_LIST.includes(f)).slice(0, MAX_FEATS);
        });

        // selection & relations
        selectedId = data.selectedId || null;
        relations = (data.relations && typeof data.relations === "object") ? data.relations : {};

        // story
        if (data.story && typeof data.story === "object"){
          story = data.story;
        }
        if (!story || typeof story !== "object"){
          story = {
            phase: "train",
            trainTurn: 0,
            prologueDone: false,
            greatHallIntroDone: false,
            arrivalDone: false,
            sortingMode: false,
            currentYear: 0,
            logsByYear: {},
            logsByVacation: {},
            logViewMode: "current",
            seasonIndex: 0,
            seasonTurn: 0,
            vacationTurn: 0,
            log: [],
            affinity: {},
            readyForNewYear: false,
            owlExamByYear: {},
            owlResultsByYear: {},
            owlResultsShownByYear: {}
          };
        }

        // normalize story fields
        story.phase = story.phase || "train";
        story.trainTurn = Number.isFinite(story.trainTurn) ? story.trainTurn : 0;
        story.prologueDone = !!story.prologueDone;
        story.greatHallIntroDone = !!story.greatHallIntroDone;
        story.arrivalDone = !!story.arrivalDone;
        story.sortingMode = !!story.sortingMode;
        story.currentYear = Number.isFinite(story.currentYear) ? story.currentYear : 0;
        if (!story.logsByYear || typeof story.logsByYear !== "object") story.logsByYear = {};
        if (!story.logsByVacation || typeof story.logsByVacation !== "object") story.logsByVacation = {};
        story.logViewMode = (story.logViewMode === "archive") ? "archive" : "current";
        story.seasonIndex = Number.isFinite(story.seasonIndex) ? story.seasonIndex : 0;
        story.seasonTurn = Number.isFinite(story.seasonTurn) ? story.seasonTurn : 0;
        story.vacationTurn = Number.isFinite(story.vacationTurn) ? story.vacationTurn : 0;
        story.log = Array.isArray(story.log) ? story.log : [];
        story.affinity = (story.affinity && typeof story.affinity === "object") ? story.affinity : {};
        if (!story.sortingState || typeof story.sortingState !== "object"){
          story.sortingState = { stage: "idle", currentId: null, suggestedHouse: null };
        }

        // options
        if (data.options && typeof data.options === "object"){
          appOptions = { ...appOptions, ...data.options };
        }
        if (!appOptions || typeof appOptions !== "object") appOptions = { autoArchive: true };
        if (typeof appOptions.autoArchive !== "boolean") appOptions.autoArchive = !!appOptions.autoArchive;

        scrubRelations();
        ensureRelationsAllPairs();
        setStatus();
        refreshGates();
      }catch(e){
        characters = [];
        selectedId = null;
        relations = {};
        setStatus();
        refreshGates();
      }
    }
    function findSelected(){ return characters.find(c=>c.id===selectedId) || null; }
    function nameOf(id){ return characters.find(c=>c.id===id)?.name || "???"; }
    function traitsOf(id){ return (characters.find(c=>c.id===id)?.traits || []); }

    // Tabs: settings / graph / story
    function setMain(which){
      const isSettings = which === "settings";
      const isGraph = which === "graph";
      const isStory = which === "story";
      const isArchive = which === "archive";

      if (isStory && characters.length < 2){
        showToast("ìŠ¤í† ë¦¬ëŠ” ìºë¦­í„° 2ëª… ì´ìƒë¶€í„° ì‹œì‘ë©ë‹ˆë‹¤!");
        return;
      }

      mainSettings.classList.toggle("active", isSettings);
      mainGraph.classList.toggle("active", isGraph);
      mainStory.classList.toggle("active", isStory);
      mainArchive.classList.toggle("active", isArchive);

      pageSettings.classList.toggle("hidden", !isSettings);
      pageGraph.classList.toggle("hidden", !isGraph);
      pageStory.classList.toggle("hidden", !isStory);
      pageArchive.classList.toggle("hidden", !isArchive);

      if (isSettings) renderRelationsSummary();
      if (isGraph) renderGraph();
      if (isStory) renderStory();
      if (isArchive) renderArchive();
    }

    mainSettings.addEventListener('click', ()=>setMain("settings"));
    mainGraph.addEventListener('click', ()=>setMain("graph"));
    mainStory.addEventListener('click', ()=>{
      if (mainStory.classList.contains('disabled')) return;
      setMain("story");
    });
    mainArchive.addEventListener('click', ()=>setMain("archive"));

    function initMbtiOptions(){
      const frag = document.createDocumentFragment();
      MBTI_LIST.forEach(m=>{
        const opt = document.createElement('option');
        opt.value = m; opt.textContent = m;
        frag.appendChild(opt);
      });
      elMbti.appendChild(frag);
    }

    // Traits UI
    function getSelectedTraits(){
      if (!traitsBox) return [];
      const cbs = traitsBox.querySelectorAll('input[type="checkbox"][data-trait]');
      const picked = [];
      cbs.forEach(cb=>{
        if (cb.checked){
          picked.push(cb.getAttribute('data-trait'));
        }
      });
      return picked;
    }
    function hasValueTrait(traits){
      return (traits || []).some(t=>VALUE_TRAITS.has(t));
    }
    function setTraitSelection(traits){
      const set = new Set(traits || []);
      traitsBox.querySelectorAll('input[type="checkbox"][data-trait]').forEach(cb=>{
        cb.checked = set.has(cb.getAttribute('data-trait'));
      });
      refreshTraitUI();
    }

    function refreshTraitUI(){
      const selected = getSelectedTraits();
      traitCount.textContent = String(selected.length);
      const maxed = selected.length >= MAX_TRAITS;

      traitsBox.querySelectorAll('label.chip').forEach(lbl=>{
        const cb = lbl.querySelector('input[type="checkbox"][data-trait]');
        const isChecked = cb.checked;
        if (maxed && !isChecked){
          lbl.classList.add('disabled'); cb.disabled = true;
        } else {
          lbl.classList.remove('disabled'); cb.disabled = false;
        }
        lbl.classList.toggle('on', isChecked);
      });

      if (!hasValueTrait(selected)){
        traitHint.innerHTML = `<span style="color:var(--danger);font-weight:950;">ê°€ì¹˜ê´€Â·ì‚¬ìƒ 1ê°œ ì´ìƒ í•„ìˆ˜!</span>`;
      } else {
        traitHint.textContent = selected.length ? `ì„ íƒë¨: ${selected.join(", ")}` : "í‚¤ì›Œë“œë¥¼ ì„ íƒí•´ ì£¼ì„¸ìš”. (ìµœëŒ€ 5ê°œ)";
      }
      updateButtons();
    }

    function refreshFeatUI(){
      if (!featsBox) return;
      const selected = getSelectedFeats();
      const maxed = selected.length >= MAX_FEATS;
      featsBox.querySelectorAll('label.chip').forEach(lbl=>{
        const cb = lbl.querySelector('input[type="checkbox"][data-feat]');
        const isChecked = cb.checked;
        if (maxed && !isChecked){
          lbl.classList.add('disabled'); cb.disabled = true;
        } else {
          lbl.classList.remove('disabled'); cb.disabled = false;
        }
        lbl.classList.toggle('on', isChecked);
      });
    }


    function buildTraitsUI(){
      traitsBox.innerHTML = "";
      TRAIT_GROUPS.forEach((group, gi)=>{
        const details = document.createElement('details');
        details.open = true;

        const summary = document.createElement('summary');
        const left = document.createElement('div'); left.textContent = group.title;
        const right = document.createElement('div');
        const badge = document.createElement('span'); badge.className="badge"; badge.textContent = `${group.items.length}ê°œ`;
        right.appendChild(badge);
        summary.appendChild(left); summary.appendChild(right);

        const grid = document.createElement('div'); grid.className="traitGrid";
        group.items.forEach(trait=>{
          const lbl = document.createElement('label');
          lbl.className = "chip" + (VALUE_TRAITS.has(trait) ? " value" : "");
          const d = document.createElement('span'); d.className="dot2";
          const cb = document.createElement('input'); cb.type="checkbox"; cb.setAttribute("data-trait", trait);

          cb.addEventListener("change", ()=>{
            const sel = getSelectedTraits();
            if (sel.length > MAX_TRAITS){
              cb.checked = false;
              showToast(`í‚¤ì›Œë“œëŠ” ìµœëŒ€ ${MAX_TRAITS}ê°œê¹Œì§€!`);
            }
            refreshTraitUI();
          });

          const tx = document.createElement('span'); tx.textContent = trait;
          lbl.appendChild(d); lbl.appendChild(cb); lbl.appendChild(tx);
          lbl.addEventListener('click', (e)=>{ if (cb.disabled){ e.preventDefault(); e.stopPropagation(); }});
          grid.appendChild(lbl);
        });

        details.appendChild(summary);
        details.appendChild(grid);
        traitsBox.appendChild(details);
      });

      refreshTraitUI();
    }

    // Character CRUD
    function getForm(){
      return { name: normalize(elName.value), mbti: elMbti.value || "", blood: elBlood.value || "", traits: getSelectedTraits(), feats: getSelectedFeats() };
    }
    function validate({name, mbti, blood, traits}){
      if (!name) return { ok:false, reason:"ì´ë¦„ì„ ì…ë ¥í•´ ì£¼ì„¸ìš”" };
      if (!mbti) return { ok:false, reason:"MBTIë¥¼ ì„ íƒí•´ ì£¼ì„¸ìš”" };
      if (!blood) return { ok:false, reason:"í˜ˆí†µì„ ì„ íƒí•´ ì£¼ì„¸ìš”" };
      if ((traits || []).length > MAX_TRAITS) return { ok:false, reason:`í‚¤ì›Œë“œëŠ” ìµœëŒ€ ${MAX_TRAITS}ê°œ!` };
      if (!hasValueTrait(traits || [])) return { ok:false, reason:"ê°€ì¹˜ê´€Â·ì‚¬ìƒ 1ê°œ ì´ìƒ í•„ìˆ˜!" };
      return { ok:true };
    }
    function fillForm(c){
      if (!c) return;
      elName.value = c.name || "";
      elMbti.value = (c.mbti || "").toUpperCase();
      elBlood.value = c.blood || "";

      // traits
      const set = new Set(c.traits || []);
      traitsBox.querySelectorAll('input[type="checkbox"][data-trait]').forEach(cb=>{
        const t = cb.getAttribute('data-trait');
        cb.checked = set.has(t);
      });
      refreshTraitUI();

      // feats
      if (featsBox){
        const validFeats = Array.isArray(c.feats) ? c.feats.filter(f=>FEAT_LIST.includes(f)).slice(0, MAX_FEATS) : [];
        const fset = new Set(validFeats);
        featsBox.querySelectorAll('input[type="checkbox"][data-feat]').forEach(cb=>{
          cb.checked = fset.has(cb.dataset.feat);
        });
        refreshFeatUI();
      }
    }
    function updateButtons(){
      const v = validate(getForm());
      addBtn.disabled = !v.ok;
      const sel = findSelected();
      updateBtn.disabled = !(sel && v.ok);
      deleteBtn.disabled = !sel;
    }
    function updateRightButtons(){
      const sel = findSelected();
      rightLoadToEdit.disabled = !sel;
      rightDelete.disabled = !sel;
    }
    function updatePreview(){
      const sel = findSelected();
      pvPick.textContent = sel ? sel.name : "â€”";
      pvMbti.textContent = sel ? sel.mbti : "â€”";
      pvBlood.textContent = sel ? sel.blood : "â€”";
      pvTraits.innerHTML = "";

      const traits = sel?.traits || [];
      const feats  = sel?.feats  || [];
      const hasAny = traits.length > 0 || feats.length > 0;

      if (!sel || !hasAny){
        const empty = document.createElement('span'); 
        empty.className="tag soft"; 
        empty.textContent="â€”";
        pvTraits.appendChild(empty);
      } else {
        traits.slice(0, MAX_TRAITS).forEach(t=>{
          const chip = document.createElement('span'); 
          chip.className="tag trait"; 
          chip.textContent=t;
          pvTraits.appendChild(chip);
        });
        // íŠ¹ì„±(feats)ë„ í•¨ê»˜ í‘œì‹œ (ìµœëŒ€ 2ê°œ)
        (feats || []).forEach(f=>{
          const chip = document.createElement('span');
          chip.className="tag feat";
          chip.textContent=f;
          pvTraits.appendChild(chip);
        });
      }
      updateRightButtons();
    }
    function matchesQuery(c, q){
      if (!q) return true;
      const traits = (c.traits || []).join(" ");
      const feats  = (c.feats  || []).join(" ");
      const hay = `${c.name} ${c.mbti} ${c.blood} ${traits} ${feats}`.toLowerCase();
      return hay.includes(q.toLowerCase());
    }
    function renderList(){
      const q = normalize(elQ.value);
      const filtered = characters
        .filter(c => matchesQuery(c, q))
        .slice()
        .sort((a,b)=> (b.updatedAt || "").localeCompare(a.updatedAt || ""));

      listEl.innerHTML = "";
      if (filtered.length === 0){
        const empty = document.createElement('div');
        empty.style.padding="12px"; empty.style.border="1px dashed var(--line)";
        empty.style.borderRadius="14px"; empty.style.color="var(--muted)";
        empty.style.fontSize="13px";
        empty.textContent = q ? "ê²€ìƒ‰ ê²°ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤." : "ì•„ì§ ìºë¦­í„°ê°€ ì—†ìŠµë‹ˆë‹¤. ì™¼ìª½ì—ì„œ ì¶”ê°€í•´ ì£¼ì„¸ìš”.";
        listEl.appendChild(empty);
        return;
      }

      filtered.forEach(c=>{
        const item = document.createElement('div');
        item.className = "item" + (c.id === selectedId ? " active" : "");
        item.tabIndex = 0;

        const meta = document.createElement('div'); meta.className="meta";
        const name = document.createElement('div'); name.className="name"; name.textContent=c.name;

        const tags = document.createElement('div'); tags.className="tags";
        const t1 = document.createElement('span'); t1.className="tag"; t1.textContent=c.mbti;
        const t2 = document.createElement('span'); t2.className="tag"; t2.textContent=c.blood;
        tags.appendChild(t1); tags.appendChild(t2);
        (c.traits || []).slice(0,MAX_TRAITS).forEach(tr=>{
          const t = document.createElement('span'); t.className="tag trait"; t.textContent=tr;
          tags.appendChild(t);
        });
        // íŠ¹ì„±(feats)ë„ íƒœê·¸ë¡œ í‘œì‹œ
        (c.feats || []).forEach(f=>{
          const t = document.createElement('span'); t.className="tag feat"; t.textContent=f;
          tags.appendChild(t);
        });
        meta.appendChild(name); meta.appendChild(tags);

        const right = document.createElement('div'); right.className="rightMini";
        const del = document.createElement('button'); del.type="button"; del.className="miniBtn"; del.textContent="ì‚­ì œ";
        del.addEventListener('click', (e)=>{ e.stopPropagation(); selectCharacter(c.id); deleteCharacter(true); });
        right.appendChild(del);

        item.appendChild(meta); item.appendChild(right);
        item.addEventListener('click', ()=> selectCharacter(c.id));
        item.addEventListener('keydown', (e)=>{ if(e.key==="Enter"||e.key===" ") selectCharacter(c.id); });

        listEl.appendChild(item);
      });
    }
    function selectCharacter(id){
      selectedId = id;
      const sel = findSelected();
      if (sel) fillForm(sel);
      saveAll();
      renderList();
      updatePreview();
      renderRelationsSummary();
      showToast("ë¶ˆëŸ¬ì™”ì–´!");
    }

    function addCharacter(){
      const data = getForm();
      const v = validate(data);
      if (!v.ok) return showToast(v.reason);

      const c = {
        id: `c_${Date.now()}_${Math.floor(Math.random()*99999)}`,
        name: data.name,
        mbti: data.mbti,
        blood: data.blood,
        traits: (data.traits || []).slice(0, MAX_TRAITS),
        feats: (data.feats || []).slice(0, MAX_FEATS),
        createdAt: nowISO(),
        updatedAt: nowISO()
      };
      characters.push(c);
      selectedId = c.id;

      ensureRelationsAllPairs();
      saveAll();
      renderList();
      updatePreview();
      renderRelationsSummary();
      showToast("ì¶”ê°€ ì™„ë£Œ!");
    }
    function updateCharacter(){
      const sel = findSelected();
      if (!sel) return showToast("ìˆ˜ì •í•  ìºë¦­í„°ë¥¼ ë¨¼ì € ì„ íƒí•´ ì£¼ì„¸ìš”");

      const data = getForm();
      const v = validate(data);
      if (!v.ok) return showToast(v.reason);

      sel.name = data.name;
      sel.mbti = data.mbti;
      sel.blood = data.blood;
      sel.traits = (data.traits||[]).slice(0,MAX_TRAITS);
      sel.feats = (data.feats||[]).slice(0,MAX_FEATS);
      sel.updatedAt = nowISO();

      saveAll();
      renderList();
      updatePreview();
      renderRelationsSummary();
      showToast("ìˆ˜ì • ì €ì¥!");
    }
    function deleteCharacter(instant=false){
      const sel = findSelected();
      if (!sel) return;

      if (!instant){
        if (!deleteCharacter._armed){
          deleteCharacter._armed = true;
          showToast("í•œ ë²ˆ ë” ëˆ„ë¥´ë©´ ì‚­ì œ!");
          window.clearTimeout(deleteCharacter._t);
          deleteCharacter._t = window.setTimeout(()=>{ deleteCharacter._armed = false; }, 1500);
          return;
        }
        deleteCharacter._armed = false;
      }

      const delId = selectedId;
      characters = characters.filter(c=>c.id!==delId);
      selectedId = characters.length ? characters[0].id : null;

      for (const k of Object.keys(relations)){
        if (k.includes(delId)) delete relations[k];
      }
      ensureRelationsAllPairs();

      // if story logs exist, keep them, but gates might close; we don't erase automatically.
      saveAll();
      renderList();
      updatePreview();
      renderRelationsSummary();
      if (pageStory && !pageStory.classList.contains("hidden")) renderStory();

      if (selectedId) fillForm(findSelected());
      else { elName.value=""; elMbti.value=""; elBlood.value=""; setTraitSelection([]); }
      updateButtons();
      showToast("ì‚­ì œí–ˆìŠµë‹ˆë‹¤.");
    }
    function newInput(){
      elName.value=""; elMbti.value=""; elBlood.value="";
      selectedId = null; setTraitSelection([]);
      saveAll(); renderList(); updatePreview(); updateButtons();
      showToast("ìƒˆ ì…ë ¥!");
    }

    rightLoadToEdit.addEventListener('click', ()=>{
      const sel = findSelected(); if (!sel) return;
      fillForm(sel);
      showToast("ì™¼ìª½ì— ë¶ˆëŸ¬ì™”ì–´!");
      window.scrollTo({ top: 0, behavior: "smooth" });
    });
    rightDelete.addEventListener('click', ()=> deleteCharacter(false));

    // Relations summary
    function relationPairs(){
      const ids = characters.map(c=>c.id);
      const map = ensureAffinityMap();
      const out = [];
      for (let i=0;i<ids.length;i++){
        for (let j=i+1;j<ids.length;j++){
          const k = pairKey(ids[i], ids[j]);
          const relKey = relations[k] || DEFAULT_REL;
          const score = Number.isFinite(map[k]) ? map[k] : 0;
          out.push({ aId: ids[i], bId: ids[j], relKey, rel: REL_BY_KEY[relKey] || REL_BY_KEY[DEFAULT_REL], score });
        }
      }
      return out;
    }
    function matchesRelQuery(p, q){
      if (!q) return true;
      const hay = `${nameOf(p.aId)} ${nameOf(p.bId)}`.toLowerCase();
      return hay.includes(q.toLowerCase());
    }
    function relPill(relKey){
      const rel = REL_BY_KEY[relKey] || REL_BY_KEY[DEFAULT_REL];
      const div = document.createElement('span');
      div.className = `relPill rel_${rel.key}`;
      const d = document.createElement('span'); d.className="relDot";
      const tx = document.createElement('span'); tx.className="relLabel"; tx.textContent=rel.label;
      div.appendChild(d); div.appendChild(tx);
      return div;
    }
    function renderRelationsSummary(){
      const q = normalize(rq.value).toLowerCase();
      const allPairs = relationPairs();
      const allIds = characters.map(c=>c.id);

      // ì´ë¦„ ê²€ìƒ‰ì–´ê°€ ìˆìœ¼ë©´, ê·¸ ì´ë¦„ì´ í¬í•¨ëœ ìºë¦­í„°ë§Œ íƒ­ì— ë³´ì—¬ì¤Œ
      const filteredIds = q
        ? allIds.filter(id => (nameOf(id)||"").toLowerCase().includes(q))
        : allIds.slice();

      // ì „ì²´ ìŒ ìˆ˜ëŠ” ê·¸ëŒ€ë¡œ í‘œì‹œ (ê²€ìƒ‰ê³¼ ë¬´ê´€)
      relCountText.textContent = `${allPairs.length}ìŒ`;
      relList.innerHTML = "";

      if (characters.length < 2){
        const empty = document.createElement('div');
        empty.style.padding="12px"; empty.style.border="1px dashed var(--line)";
        empty.style.borderRadius="14px"; empty.style.color="var(--muted)";
        empty.style.fontSize="13px";
        empty.textContent = "ìºë¦­í„°ë¥¼ 2ëª… ì´ìƒ ë§Œë“¤ì–´ì•¼ ê´€ê³„ê°€ ë³´ì…ë‹ˆë‹¤.";
        relList.appendChild(empty);
        return;
      }

      if (filteredIds.length === 0){
        const empty = document.createElement('div');
        empty.style.padding="12px"; empty.style.border="1px dashed var(--line)";
        empty.style.borderRadius="14px"; empty.style.color="var(--muted)";
        empty.style.fontSize="13px";
        empty.textContent = "í•´ë‹¹ ì´ë¦„ì„ ê°€ì§„ ìºë¦­í„°ê°€ ì—†ìŠµë‹ˆë‹¤.";
        relList.appendChild(empty);
        return;
      }

      // í˜„ì¬ í¬ì»¤ìŠ¤ ëŒ€ìƒ ìºë¦­í„° idë¥¼ ì „ì—­ìœ¼ë¡œ ê´€ë¦¬
      if (!window.relFocusId || !filteredIds.includes(window.relFocusId)){
        window.relFocusId = filteredIds[0];
      }
      const focusId = window.relFocusId;

      // ìƒë‹¨: ìºë¦­í„° ì´ë¦„ ì¹©ë“¤
      const tabWrap = document.createElement('div');
      tabWrap.className = "relTabs";
      filteredIds.forEach(id => {
        const btn = document.createElement('button');
        btn.type = "button";
        btn.className = "relTabChip" + (id === focusId ? " active" : "");
        btn.dataset.id = id;
        btn.textContent = nameOf(id) || "ì´ë¦„ ì—†ìŒ";
        tabWrap.appendChild(btn);
      });
      relList.appendChild(tabWrap);

      // í•˜ë‹¨: ì„ íƒëœ ìºë¦­í„°ì˜ ê´€ê³„ ìš”ì•½ë§Œ í‘œì‹œ
      const body = document.createElement('div');
      body.className = "relBody";
      const focusPairs = allPairs
        .filter(p => p.aId === focusId || p.bId === focusId)
        .sort((x,y)=> y.rel.rank - x.rel.rank);

      if (focusPairs.length === 0){
        const empty = document.createElement('div');
        empty.style.padding="12px"; empty.style.border="1px dashed var(--line)";
        empty.style.borderRadius="14px"; empty.style.color="var(--muted)";
        empty.style.fontSize="13px";
        empty.textContent = "ì´ ìºë¦­í„°ì™€ ì—°ê²°ëœ ê´€ê³„ê°€ ì•„ì§ ì—†ìŠµë‹ˆë‹¤.";
        body.appendChild(empty);
      } else {
        focusPairs.forEach(p=>{
          const item = document.createElement('div');
          item.style.border="1px solid var(--line)";
          item.style.borderRadius="14px";
          item.style.padding="12px";
          item.style.background="#fff";
          item.style.display="grid";
          item.style.gap="8px";

          const top = document.createElement('div');
          top.style.display="flex"; top.style.alignItems="center"; top.style.justifyContent="space-between"; top.style.gap="10px";

          const otherId = p.aId === focusId ? p.bId : p.aId;
          const pair = document.createElement('div');
          pair.style.fontWeight="950"; pair.style.fontSize="13px";
          pair.textContent = `${nameOf(focusId)} â†” ${nameOf(otherId)}`;

          top.appendChild(pair);

          const score = Number.isFinite(p.score) ? p.score : 0;

          const pill = relPill(p.relKey);
          const sc = Number.isFinite(p.score) ? p.score : 0;
          pill.dataset.score = String(sc);
          const sign = score > 0 ? "+" : "";
          pill.title = `í˜„ì¬ í˜¸ê°ë„: ${sign}${score}`;
          top.appendChild(pill);

          const bar = document.createElement('div');
          bar.style.height="10px"; bar.style.borderRadius="999px"; bar.style.border="1px solid var(--line)";
          bar.style.background="#fafafa"; bar.style.overflow="hidden";

          const fill = document.createElement('div');
          fill.style.height="100%";
          const width = Math.min(100, Math.abs(score));
          fill.style.width = `${width}%`;
          fill.style.background = p.rel.color;
          bar.appendChild(fill);

          item.appendChild(top);
          item.appendChild(bar);
          body.appendChild(item);
        });
      }

      relList.appendChild(body);
    }
    rq.addEventListener('input', renderRelationsSummary);

// ê´€ê³„ ì¹© í˜¸ë²„ ë§í’ì„ 
let relTipEl = null;
function ensureRelTipEl(){
      if (relTipEl) return relTipEl;
      relTipEl = document.createElement("div");
      relTipEl.className = "relTooltip";
      document.body.appendChild(relTipEl);
      return relTipEl;
    }

relList.addEventListener("mouseover", (ev)=>{
      const pill = ev.target.closest ? ev.target.closest(".relPill") : null;
      if (!pill) return;
      const scoreStr = pill.dataset.score;
      if (!scoreStr) return;
      const score = Number(scoreStr) || 0;
      const sign = score > 0 ? "+" : "";
      const tip = `í˜„ì¬ í˜¸ê°ë„: ${sign}${score}`;
      const el = ensureRelTipEl();
      el.textContent = tip;
      el.style.display = "block";
      const rect = pill.getBoundingClientRect();
      el.style.left = (rect.left + window.scrollX) + "px";
      el.style.top  = (rect.top + window.scrollY - 28) + "px";
    });

relList.addEventListener("mouseout", (ev)=>{
      if (!relTipEl) return;
      const pill = ev.target.closest ? ev.target.closest(".relPill") : null;
      if (pill) {
        relTipEl.style.display = "none";
      }
    });

// ì´ë¦„ ì¹© í´ë¦­ ì‹œ í¬ì»¤ìŠ¤ ë³€ê²½
relList.addEventListener('click', (ev)=>{
      const btn = ev.target.closest ? ev.target.closest('.relTabChip') : null;
      if (!btn) return;
      const id = btn.dataset.id;
      if (!id) return;
      window.relFocusId = id;
      renderRelationsSummary();
    });

    // Graph
    function clearSvg(){ while(svg.firstChild) svg.removeChild(svg.firstChild); }
    function make(tag, attrs={}){
      const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
      for (const [k,v] of Object.entries(attrs)) el.setAttribute(k, String(v));
      return el;
    }
    function renderGraph(){
      scrubRelations(); ensureRelationsAllPairs();

      const q = normalize(filterEl.value).toLowerCase();
      const filtered = q ? characters.filter(c => (c.name||"").toLowerCase().includes(q)) : characters.slice();

      const W=1000,H=640,cx=W/2,cy=H/2;
      const r = Math.min(W,H) * 0.34;

      const nodes = filtered.map((c,i)=>{
        const ang = (Math.PI*2) * (i / Math.max(1, filtered.length));
        return { id:c.id, name:c.name||"???", x: cx + r*Math.cos(ang), y: cy + r*Math.sin(ang) };
      });

      const ids = nodes.map(n=>n.id);
      const edges = [];
      for (let i=0;i<ids.length;i++){
        for (let j=i+1;j<ids.length;j++){
          const k=pairKey(ids[i], ids[j]);
          const relKey = relations[k] || DEFAULT_REL;
          if (relKey !== "moru") edges.push({a:ids[i], b:ids[j], relKey, rel: REL_BY_KEY[relKey]});
        }
      }

      clearSvg();
      svg.appendChild(make("rect",{x:0,y:0,width:W,height:H,fill:"#fff"}));

      edges.forEach(e=>{
        const A = nodes.find(n=>n.id===e.a);
        const B = nodes.find(n=>n.id===e.b);
        if (!A || !B) return;

        const line = make("line",{
          x1:A.x, y1:A.y, x2:B.x, y2:B.y,
          stroke: e.rel.color,
          "stroke-width": e.rel.width,
          "stroke-linecap":"round",
          opacity:0.78
        });
        svg.appendChild(line);

        if (showLabels){
          const mx=(A.x+B.x)/2, my=(A.y+B.y)/2;
          const label = e.rel.label;
          const w = Math.max(56, label.length*10 + 18);

          const bg = make("rect",{
            x:mx-(w/2),y:my-11,width:w,height:22,rx:10,ry:10,
            fill:"#fff",stroke:"#e5e7eb","stroke-width":1,opacity:0.96
          });
          const dot = make("circle",{cx: mx-(w/2)+12, cy: my, r:4, fill:e.rel.color, opacity:0.95});
          const tx = make("text",{
            x:mx-(w/2)+22,y:my+4,
            "text-anchor":"start",
            "font-size":"11","font-weight":"950",
            fill:"#111"
          });
          tx.textContent = label;

          svg.appendChild(bg); svg.appendChild(dot); svg.appendChild(tx);
        }
      });

      nodes.forEach(n=>{
        const g = make("g",{});
        g.appendChild(make("circle",{cx:n.x,cy:n.y,r:26,fill:"#fff",stroke:"#111","stroke-width":2}));
        const text = make("text",{x:n.x,y:n.y+4,"text-anchor":"middle","font-size":"11","font-weight":"950",fill:"#111"});
        text.textContent = n.name.length>7 ? n.name.slice(0,7)+"â€¦" : n.name;
        g.appendChild(text);
        svg.appendChild(g);
      });

      graphPill.textContent = `${nodes.length}ëª… Â· ${edges.length}ì„ `;
    }

    filterEl.addEventListener('input', renderGraph);
    reloadBtn.addEventListener('click', ()=>{ renderGraph(); showToast("ìƒˆë¡œê³ ì¹¨!"); });
    toggleLabelsBtn.addEventListener('click', ()=>{
      showLabels = !showLabels;
      toggleLabelsBtn.textContent = `ê´€ê³„ ë¼ë²¨: ${showLabels ? "ON" : "OFF"}`;
      renderGraph();
    });
    goSettingsBtn.addEventListener('click', ()=> setMain("settings"));

    // ===== Story generation (Train) =====
    function renderStoryRoster(){
      storyRoster.innerHTML = "";
      if (!characters.length){
        storyRoster.innerHTML = `<span class="muted">ìºë¦­í„°ê°€ ì—†ìŠµë‹ˆë‹¤.</span>`;
        return;
      }

      characters.forEach(c=>{
        const row = document.createElement("div");
        row.className = "pill";
        let dot = "";
        if (c.house && HOUSE_META[c.house]){
          dot = `<span class="houseDot ${HOUSE_META[c.house].cls}" title="${escapeHTML(c.house)}"></span>`;
        }
        row.innerHTML = `<span class="pillName">${escapeHTML(c.name)}</span>${dot}`;
        storyRoster.appendChild(row);
      });
    }

    function updateStoryHeader(){
  const trainDone = story.trainTurn >= TRAIN_TURNS_MAX;

  if (story.phase === "arrival"){
    storySub.textContent = "9ì›” 1í•™ë…„ Â· ë„ì°©";
    const done = !!story.arrivalDone;
    storyDoneHint.textContent = done ? "" : "ì—´ì°¨ê°€ ë©ˆì¶”ëŠ” ì†Œë¦¬ê°€ ë“¤ë¦½ë‹ˆë‹¤â€¦";
    storyNext.textContent = done ? "ë‹¤ìŒ" : "â€¦";
    storyNext.disabled = !done;
  } else if (story.phase === "great_hall"){
    storySub.textContent = "9ì›” 1í•™ë…„ Â· ëŒ€ì—°íšŒì¥";
    const introDone = !!story.greatHallIntroDone;

    const allAssigned = characters.length && characters.every(c=>c.house);
    if (!introDone){
      storyDoneHint.textContent = "ëŒ€ì—°íšŒì¥ ì¥ë©´ì´ ì¬ìƒ ì¤‘â€¦";
      storyNext.textContent = "â€¦";
      storyNext.disabled = true;
    } else if (!allAssigned){
      storyDoneHint.textContent = "";
      storyNext.textContent = "ê¸°ìˆ™ì‚¬ ë°°ì •";
      storyNext.disabled = false;
    } else {
      storyDoneHint.textContent = "ëª¨ë“  í•™ìƒì˜ ê¸°ìˆ™ì‚¬ê°€ ë°°ì •ë˜ì—ˆìŠµë‹ˆë‹¤.";
      storyNext.textContent = (story.currentYear === 0 ? "ìƒˆí•™ë…„ ì‹œì‘" : "ë‹¤ìŒ");
      storyNext.disabled = false;
    }
  } else if (story.phase === "school"){
    const maxPerSeason = 2;
    const idx = Number.isFinite(story.seasonIndex) ? Math.min(Math.max(story.seasonIndex, 0), 3) : 0;
    const doneInSeason = Math.min(story.seasonTurn, maxPerSeason);
    const seasonNames = ["ê°€ì„","ê²¨ìš¸","ë´„","ì—¬ë¦„"];
    const seasonEmojis = ["ğŸ‚","â„ï¸","ğŸŒ¸","â˜€ï¸"];
    const seasonName = seasonNames[idx] || "ê°€ì„";
    const seasonEmoji = seasonEmojis[idx] || "ğŸ‚";

    const isOwlSummer = (story.currentYear === 5 && idx === 3);
    const isNewtSummer = (story.currentYear === 7 && idx === 3);
    let suffix = "";
    if (isOwlSummer && doneInSeason >= maxPerSeason){
      suffix += " O.W.L";
    }
    if (isNewtSummer && doneInSeason >= maxPerSeason){
      suffix += suffix ? " Â· N.E.W.T" : " N.E.W.T";
    }
    storySub.textContent = `${story.currentYear}í•™ë…„ Â· ${seasonName} ${seasonEmoji} (${doneInSeason}/${maxPerSeason})${suffix}`;

    if (storyHint){
      if (doneInSeason < maxPerSeason){
        storyHint.textContent = "";
      } else if (idx < 3){
        storyHint.textContent = "";
      } else if (story.currentYear >= 1 && story.currentYear < 7){
        storyHint.textContent = "";
      } else {
        storyHint.textContent = "";
      }
    }

    if (doneInSeason < maxPerSeason){
      storyDoneHint.textContent = "";
      storyNext.textContent = "ë‹¤ìŒ";
      storyNext.disabled = false;
    } else if (idx < 3){
      storyDoneHint.textContent = `${seasonName} ì´ì•¼ê¸°ê°€ ì •ë¦¬ë˜ì—ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ê³„ì ˆë¡œ ë„˜ì–´ê°€ ì£¼ì„¸ìš”.`;
      storyNext.textContent = "ë‹¤ìŒ";
      storyNext.disabled = false;
    } else {
      storyDoneHint.textContent = `${story.currentYear}í•™ë…„ì˜ ì´ì•¼ê¸°ê°€ ëë‚¬ìŠµë‹ˆë‹¤.`;
      if (story.currentYear >= 1 && story.currentYear < 7){
        storyNext.textContent = "ë°©í•™ìœ¼ë¡œ";
        storyNext.disabled = false;
      } else if (story.currentYear >= 7){
        storyNext.textContent = "ì¡¸ì—…";
        storyNext.disabled = false;
      } else {
        storyNext.textContent = "ë‹¤ìŒ";
        storyNext.disabled = false;
      }
    }
  } else if (story.phase === "vacation"){
    const maxVac = 3;
    const vTurn = Math.min(story.vacationTurn, maxVac);
    const yearLabel = story.currentYear >= 1 ? `${story.currentYear}í•™ë…„ê³¼ ${story.currentYear+1}í•™ë…„ ì‚¬ì´ ë°©í•™` : "ë°©í•™";

    storySub.textContent = `${yearLabel} (${vTurn}/${maxVac})`;

    const isOwlYear = (story.currentYear === 5);
    const yearKey = String(story.currentYear || 0);

    if (isOwlYear){
      if (!story.owlResultsByYear || typeof story.owlResultsByYear !== "object") story.owlResultsByYear = {};
      if (!story.owlResultsShownByYear || typeof story.owlResultsShownByYear !== "object") story.owlResultsShownByYear = {};
      if (vTurn >= maxVac && !story.owlResultsByYear[yearKey]){
        calculateOwlResultsForYear(story.currentYear);
      }
    }

    const owlResultsReady = isOwlYear && story.owlResultsByYear && story.owlResultsByYear[yearKey];
    const owlResultsShown = isOwlYear && story.owlResultsShownByYear && story.owlResultsShownByYear[yearKey];

    if (storyHint){
      if (vTurn < maxVac){
        storyHint.textContent = "";
      } else if (isOwlYear && owlResultsReady && !owlResultsShown){
        storyHint.textContent = "";
      } else if (story.currentYear >= 1 && story.currentYear < 7){
        storyHint.textContent = "";
      } else {
        storyHint.textContent = "";
      }
    }

    if (vTurn < maxVac){
      storyDoneHint.textContent = "";
      storyNext.textContent = "ë‹¤ìŒ";
      storyNext.disabled = false;
    } else {
      storyDoneHint.textContent = "ë°©í•™ì´ ëª¨ë‘ ëë‚¬ìŠµë‹ˆë‹¤.";
      if (isOwlYear && owlResultsReady && !owlResultsShown){
        storyNext.textContent = "O.W.L ì„±ì  ì—´ëŒ";
        storyNext.disabled = false;
      } else if (story.currentYear >= 1 && story.currentYear < 7){
        storyNext.textContent = "ìƒˆí•™ë…„ìœ¼ë¡œ ê°€ê¸°";
        storyNext.disabled = false;
      } else {
        storyNext.textContent = "ì¡¸ì—…";
        storyNext.disabled = false;
      }
    }
  } else if (story.phase === "owlResult"){
    // O.W.L ì„±ì í‘œë¥¼ ë³´ê³  ìˆëŠ” ìƒíƒœ
    storySub.textContent = `${story.currentYear}í•™ë…„ Â· O.W.L ì„±ì í‘œ`;
    storyDoneHint.textContent = "";
    storyNext.textContent = "ìƒˆí•™ë…„ìœ¼ë¡œ ê°€ê¸°";
    storyNext.disabled = false;
  } else if (story.phase === "epilogue"){
    storySub.textContent = "ì—í•„ë¡œê·¸ Â· ì¡¸ì—…";
    storyHint.textContent = "";
    const step = typeof story.epilogueStep === "number" ? story.epilogueStep : 1;
    if (step <= 3){
      storyDoneHint.textContent = "ì¡¸ì—…ì„ ì•ë‘” ìˆœê°„ë“¤ì´ ì°¨ë¡€ë¡œ ë– ì˜¤ë¥´ê³  ìˆìŠµë‹ˆë‹¤.";
      storyNext.textContent = "ë‹¤ìŒ";
      storyNext.disabled = false;
    } else if (step === 4){
      storyDoneHint.textContent = "ë§ˆì§€ë§‰ í•œ ì¥ë©´ë§Œ ë‚¨ì•„ ìˆìŠµë‹ˆë‹¤.";
      storyNext.textContent = "ìŠ¤í† ë¦¬ ì§„í–‰";
      storyNext.disabled = false;
    } else {
      storyDoneHint.textContent = "";
      storyNext.disabled = true;
    }
  } else {
    storySub.textContent = `9ì›” 1í•™ë…„ Â· í˜¸ê·¸ì™€íŠ¸í–‰ ì—´ì°¨ ğŸš‚ (${Math.min(story.trainTurn, TRAIN_TURNS_MAX)}/${TRAIN_TURNS_MAX})`;
    storyDoneHint.textContent = trainDone ? "ì—´ì°¨ íŒŒíŠ¸ ì¢…ë£Œ" : "";
    // ì—´ì°¨ íŒŒíŠ¸ ì§„í–‰ ì¤‘ì—ëŠ” 'ë‹¤ìŒ', ëª¨ë“  ì—´ì°¨ ë¡œê·¸ê°€ ëë‚œ ë’¤ì—ëŠ” 'ìŠ¤í† ë¦¬ ì§„í–‰'ìœ¼ë¡œ í‘œê¸°
    storyNext.textContent = trainDone ? "ìŠ¤í† ë¦¬ ì§„í–‰" : "ë‹¤ìŒ";
    storyNext.disabled = (characters.length < 2) || !story.prologueDone;
  }

  refreshGates();
}

    function escapeHTML(s){
      return String(s).replace(/[&<>"']/g, (m)=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
    }

    function renderLog(){
      logBox.innerHTML = "";
      if (!story.log.length){
        const empty = document.createElement('div');
        empty.className = "logLine";
        empty.innerHTML = "ì•„ì§ ë¡œê·¸ê°€ ì—†ìŠµë‹ˆë‹¤. <em>ë‹¤ìŒ</em> ë²„íŠ¼ì„ ëˆŒëŸ¬ ë³´ì„¸ìš”.";
        logBox.appendChild(empty);
        return;
      }

      story.log.forEach(block=>{
        const turn = document.createElement('div');
        turn.className = "logTurn";
        const left = document.createElement('div');

        let title = (block && (block.title || block.label)) ? (block.title || block.label) : "";
        if (!title){
          if (block && block.meta === "O.W.L") title = "O.W.L ì„±ì ";
          else if (block.turn === 0) title = "í”„ë¡¤ë¡œê·¸";
          else if (block.turn > 0) title = `ì—´ì°¨ Â· ${block.turn}ë²ˆì§¸ ìƒí˜¸ì‘ìš©`;
          else if (block.turn === -1) title = "ëŒ€ì—°íšŒì¥";
          else if (block.turn === -2) title = "ë„ì°©";
          else title = "ë¡œê·¸";
        }
        left.innerHTML = `<b>${escapeHTML(title)}</b>`;

        const right = document.createElement('div');
        right.className = "logMeta";
        right.textContent = block.meta || "";
        turn.appendChild(left); turn.appendChild(right);
        logBox.appendChild(turn);

        (block.lines || []).forEach(line=>{
          const raw = line ?? "";
          const s = String(raw);
          const div = document.createElement('div');
          div.className = "logLine";
          if (s.startsWith("@@HTML@@")){
            div.innerHTML = s.slice(8);
          } else {
            div.innerHTML = escapeHTML(s).replaceAll("::", "<em>").replaceAll(";;", "</em>");
          }
          // ì™„ì „íˆ ë¹„ì–´ ìˆëŠ” ë¡œê·¸ ì¤„ì€ DOMì— ì¶”ê°€í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
          if (!div.textContent || !div.textContent.trim()){
            return;
          }
          logBox.appendChild(div);
        });
        // ì œëª©ê³¼ ë³¸ë¬¸ì´ ëª¨ë‘ ë¹„ì–´ ìˆëŠ” ë¡œê·¸ ë¸”ë¡ì€ ì œê±°í•©ë‹ˆë‹¤.
        if (!turn.textContent || !turn.textContent.trim()){
          turn.remove();
        }
      });

      // scroll to bottom
      logBox.scrollTop = logBox.scrollHeight;
    }

// Sorting interactions (event delegation on log box)

function handleOwlPickChar(id){
  if (!story || !characters.length) return;

  // í˜„ì¬ ë²„ì „ì—ì„œëŠ” O.W.L ì‹œí—˜ì´ 5í•™ë…„ í•œ ë²ˆë§Œ ì¡´ì¬í•˜ë¯€ë¡œ ì—°ë„ëŠ” 5ë¡œ ê³ ì •
  const year = 5;
  const yearKey = "5";

  // í•­ìƒ ìµœì‹  ìºë¦­í„°/ìŠ¤í† ë¦¬ ìƒíƒœë¥¼ ê¸°ì¤€ìœ¼ë¡œ 5í•™ë…„ ì„±ì ì„ ë‹¤ì‹œ ê³„ì‚°í•œë‹¤.
  calculateOwlResultsForYear(year);

  if (!story.owlResultsByYear || typeof story.owlResultsByYear !== "object") story.owlResultsByYear = {};
  const byYear = story.owlResultsByYear[yearKey] || {};

  // charId í‚¤ ë˜ëŠ” charId í•„ë“œë¥¼ ê¸°ì¤€ìœ¼ë¡œ ê²°ê³¼ ì°¾ê¸°
  let r = byYear[id] || byYear[String(id)];
  if (!r){
    const entries = Object.values(byYear);
    r = entries.find(v => v && (v.charId === id || String(v.charId) === String(id))) || null;
    if (!r) return;
  }

  // ì—°ë„ë³„ ìƒì„¸ ì—´ëŒ ê¸°ë¡ ë°°ì—´ ì¤€ë¹„
  if (!story.owlResultsShownDetailByYear || typeof story.owlResultsShownDetailByYear !== "object"){
    story.owlResultsShownDetailByYear = {};
  }
  if (!Array.isArray(story.owlResultsShownDetailByYear[yearKey])){
    story.owlResultsShownDetailByYear[yearKey] = [];
  }
  const shownList = story.owlResultsShownDetailByYear[yearKey];
  if (!shownList.includes(id)){
    shownList.push(id);
  }

  const who = characters.find(x=>x.id===id);
  const name = who && who.name ? who.name : "";

  const lines = [];
  lines.push(`::${name};;ì˜ O.W.L ì„±ì ì…ë‹ˆë‹¤.`);
  OWL_SUBJECTS.forEach(sub => {
    const g = (r.grades && r.grades[sub.id]) || "-";
    let label = g;
    switch(g){
      case "O": label = "O (Outstanding)"; break;
      case "E": label = "E (Exceeds Expectations)"; break;
      case "A": label = "A (Acceptable)"; break;
      case "P": label = "P (Poor)"; break;
      case "D": label = "D (Dreadful)"; break;
      case "T": label = "T (Troll)"; break;
      default: break;
    }
    lines.push(`${sub.label}: ${label}`);
  });
  if (r.summary){
    lines.push(r.summary);
  }

  // ìŠ¤í‚µ í”Œë˜ê·¸ ì´ˆê¸°í™”
  owlTypingSkipRequested = false;

  const fullLines = lines.slice();
  const block = {
    turn: 5100 + year,
    meta: "O.W.L",
    lines: []
  };
  story.log.push(block);

  // íƒ€ì´í•‘ ìŠ¤í‚µ ë²„íŠ¼ ë¸”ë¡
  const skipBlock = {
    turn: 5105 + year,
    meta: "O.W.L",
    lines: [
      '@@HTML@@<div class="logActionRow"><button class="logBtn" data-action="owl-skip-owl-typing">íƒ€ì´í•‘ ìŠ¤í‚µ</button></div>'
    ]
  };
  story.log.push(skipBlock);

  saveAll();
  renderLog();
  updateStoryHeader();

  const remaining = characters.filter(ch => !shownList.includes(ch.id));

  let owlLineIdx = 0;

  function finishOwl(){
    // ì´ í•´ì˜ ìŠ¤í‚µ ë²„íŠ¼ ë¡œê·¸ ì œê±°
    try{
      if (Array.isArray(story.log)){
        story.log = story.log.filter(l => !(l && l.meta === "O.W.L" && l.turn === (5105 + year)));
      }
    }catch(e){}

    // ì•„ì§ ì„±ì ì„ ì•ˆ ë³¸ ìºë¦­í„°ê°€ ë‚¨ì•„ ìˆìœ¼ë©´ ë‹¤ì‹œ ì§ˆë¬¸ ë¡œê·¸ ì¶œë ¥
    if (remaining.length){
      const againLines = [];
      againLines.push("Q. ëˆ„êµ¬ì˜ O.W.L ì„±ì ì„ ë” í™•ì¸í• ê¹Œ?");
      const againBtns = remaining.map(c2 => {
        const lbl2 = escapeHTML(c2.name || "");
        return `<button class="logBtn" data-action="owl-pick-char" data-id="${c2.id}">${lbl2}</button>`;
      }).join(" ");
      againLines.push(`@@HTML@@<div class="logActionRow">${againBtns}</div>`);
      story.log.push({
        turn: 5200 + year,
        meta: "O.W.L",
        lines: againLines
      });
    }

    saveAll();
    renderLog();
    updateStoryHeader();
  }

  function playNextOwlLine(){
    if (owlTypingSkipRequested){
      // ìŠ¤í‚µì´ ìš”ì²­ë˜ì—ˆìœ¼ë©´ ë‚¨ì€ ì¤„ì„ í•œ ë²ˆì— ì¶œë ¥
      while (owlLineIdx < fullLines.length){
        block.lines.push(fullLines[owlLineIdx]);
        owlLineIdx++;
      }
      finishOwl();
      return;
    }

    if (owlLineIdx >= fullLines.length){
      finishOwl();
      return;
    }

    typeLine(block, fullLines[owlLineIdx], ()=>{
      owlLineIdx++;
      setTimeout(playNextOwlLine, 500);
    });
  }

  playNextOwlLine();
}


// ê¸°ìˆ™ì‚¬ ë°°ì • / O.W.L ê²°ê³¼ ë“± ìŠ¤í† ë¦¬ ë¡œê·¸ ë²„íŠ¼ ì²˜ë¦¬
logBox.addEventListener("click", (e)=>{
  const btn = e.target.closest("button[data-action]");
  if (!btn) return;

  const action = btn.getAttribute("data-action");
  const id = btn.getAttribute("data-id");
  const house = btn.getAttribute("data-house");

  // ê° ë²„íŠ¼ì€ í•œ ë²ˆë§Œ ë™ì‘í•˜ë„ë¡ (O.W.L ì¬ì§ˆë¬¸ ë“± ìƒˆ ë²„íŠ¼ì€ ìƒˆë¡œ ìƒì„±ë¨)
  if (btn.disabled) return;
  btn.disabled = true;

  ensureSortingState();

  if (action === "pick-char"){
    const c = characters.find(x=>x.id===id);
    if (!c || c.house) return;
    if (!story.sortingState || story.sortingState.stage !== "picking") return;
    beginSortingFor(id);
    return;
  }

  if (action === "accept-house"){
    if (!story.sortingState || story.sortingState.stage !== "choice") return;
    if (story.sortingState.currentId !== id) return;
    const who = characters.find(x=>x.id===id);
    if (!who || who.house) return;
    const suggested = story.sortingState?.suggestedHouse || computeHouseSuggestion(who || {});
    applyHouse(id, suggested, false);
    return;
  }

  if (action === "reroll-house"){
    if (!story.sortingState || story.sortingState.stage !== "choice") return;
    if (story.sortingState.currentId !== id) return;
    const who = characters.find(x=>x.id===id);
    if (!who || who.house) return;
    showManualHousePick(id);
    return;
  }

  if (action === "pick-house"){
    if (!story.sortingState || story.sortingState.stage !== "manual") return;
    if (story.sortingState.currentId !== id) return;
    applyHouse(id, house, true);
    return;
  }

  if (action === "owl-skip-owl-typing"){
    owlTypingSkipRequested = true;
    return;
  }

  if (action === "owl-pick-char"){
    handleOwlPickChar(id);
    return;
  }
});




    
function typeLine(targetBlock, textLine, cb){
      if (!targetBlock || typeof textLine !== "string"){
        cb && cb();
        return;
      }

      // ë¹ˆ ë¬¸ìì—´ì´ë©´ íƒ€ì´í•‘ ì• ë‹ˆë©”ì´ì…˜ ì—†ì´ ë¹ˆ ì¤„ë§Œ ì¶”ê°€
      if (!textLine || textLine.length === 0){
        targetBlock.lines.push("");
        renderLog();
        cb && cb();
        return;
      }

      targetBlock.lines.push("");
      renderLog();
      let i = 0;
      const delay = (textLine && textLine.length <= 3) ? 200 : 40;
      const interval = setInterval(()=>{
        targetBlock.lines[targetBlock.lines.length - 1] += textLine[i];
        renderLog();
        i++;
        if (i >= textLine.length){
          clearInterval(interval);
          cb && cb();
        }
      }, delay);
    }

// Log action delegation (sorting buttons etc.)
    logBox.addEventListener("click", (e)=>{
      const btn = e.target.closest("button");
      if (!btn) return;
      const act = btn.getAttribute("data-act");
      if (!act) return;
      // í•œ ë²ˆ í´ë¦­ëœ ëª¨ì ë°°ì • ë²„íŠ¼ì€ ë‹¤ì‹œ ëˆŒë¦¬ì§€ ì•Šë„ë¡ ë°©ì§€
      if (btn.disabled) return;
      btn.disabled = true;

      if (act === "pickStudent"){
        const id = btn.getAttribute("data-id");
        // prevent picking already assigned
        const c = characters.find(x=>x.id===id);
        if (!c || c.house) return;
        runHatForStudent(id);
        return;
      }

      if (act === "acceptHouse"){
        const id = story.sorting.currentId;
        const house = story.sorting.pendingHouse;
        if (!id || !house) return;
        finalizeHouse(id, house);
        // continue loop
        story.sorting = { stage:"choose_student", currentId:null, pendingHouse:null };
        saveAll();
        logSortingQuestion();
        return;
      }

      if (act === "rerollHouse"){
        // ë‹¤ì‹œ ê³ ë¥¼ë˜ëŠ” confirm ë‹¨ê³„ì—ì„œë§Œ ì‘ë™
        if (!story.sorting || story.sorting.stage !== "confirm") return;
        showHouseChoice();
        return;
      }

      if (act === "pickHouse"){
        const id = story.sorting.currentId;
        const house = btn.getAttribute("data-house");
        if (!id || !house) return;
        finalizeHouse(id, house);
        story.sorting = { stage:"choose_student", currentId:null, pendingHouse:null };
        saveAll();
        logSortingQuestion();
        return;
      }
    });

    function relRankBetween(aId, bId){
      const k = pairKey(aId, bId);
      const relKey = relations[k] || DEFAULT_REL;
      return (REL_BY_KEY[relKey] || REL_BY_KEY[DEFAULT_REL]).rank;
    }

    function ensureAcquaintance(aId, bId){
      const k = pairKey(aId, bId);
      const currentKey = relations[k] || DEFAULT_REL;
      const currentMeta = REL_BY_KEY[currentKey] || REL_BY_KEY[DEFAULT_REL];
      if (currentMeta.rank < 1){
        relations[k] = "aneun";
      }
    }

    function ensureGroupAcquaintances(group){
      if (!group || group.length < 2) return;
      for (let i=0;i<group.length;i++){
        for (let j=i+1;j<group.length;j++){
          ensureAcquaintance(group[i], group[j]);
        }
      }
    }


function hasTrait(id, t){
      return (traitsOf(id) || []).includes(t);
    }

    function ensureAffinityMap(){
      if (!story.affinity || typeof story.affinity !== "object"){
        story.affinity = {};
      }
      return story.affinity;
    }

    
    function changeAffinity(aId, bId, delta){
      if (!delta) return;
      const map = ensureAffinityMap();
      const k = pairKey(aId, bId);
      const cur = Number.isFinite(map[k]) ? map[k] : 0;

      // deltaëŠ” ì´ë²¤íŠ¸ ê°•ë„(ìƒì§•ê°’)ë¡œ ì‚¬ìš©í•˜ê³ , ì‹¤ì œ í˜¸ê°ë„ ë³€í™”ëŸ‰ì€ ë‹¨ê³„ë³„ë¡œ ìŠ¤ì¼€ì¼ë§
      let step = 0;
      if (delta === 1) step = 8;          // ë³´í†µ ì¢‹ì€ ìƒí˜¸ì‘ìš© (ì¡°ê¸ˆ ë” í¬ê²Œ)
      else if (delta === -1) step = -8;   // ë³´í†µ ë‚˜ìœ ìƒí˜¸ì‘ìš© (ì¡°ê¸ˆ ë” í¬ê²Œ)
      else if (delta > 1) step = 16;      // ê°•í•˜ê²Œ ì¢‹ì€ ìƒí˜¸ì‘ìš©
      else if (delta < -1) step = -16;    // ê°•í•˜ê²Œ ë‚˜ìœ ìƒí˜¸ì‘ìš©

      let next = cur + step;
      if (next > 100) next = 100;
      if (next < -100) next = -100;
      map[k] = next;

      // í˜¸ê°ë„ ìˆ˜ì¹˜ë¥¼ ê´€ê³„ ë‹¨ê³„ í‚¤ë¡œ ë§µí•‘ (-100 ~ +100)
let relKey = "moru";
if (next <= -60) relKey = "hate";
else if (next <= -20) relKey = "dislike";
else if (next < 0) relKey = "moru";
else if (next < 20) relKey = "aneun";       // 0 ì´ìƒë¶€í„° ì•„ëŠ” ì‚¬ì´ (ì„  ìƒì„±)
else if (next < 60) relKey = "friend";      // 20 ì´ìƒ ì¹œêµ¬
else if (next < 85 || (story.currentYear || 0) < 5) relKey = "best"; // 5í•™ë…„ ì´ì „ì—ëŠ” ì—°ì¸ ëŒ€ì‹  ì ˆì¹œê¹Œì§€ë§Œ
else relKey = "love";

relations[k] = relKey;
    }

    function tunePairAffinityForTraits(aId, bId, sentence, baseDelta, contextKey){
      let delta = baseDelta;

      const A = nameOf(aId);
      const B = nameOf(bId);
      const traitsA = traitsOf(aId) || [];
      const traitsB = traitsOf(bId) || [];
      const bloodA = (typeof bloodOf === "function" ? bloodOf(aId) : "") || "";
      const bloodB = (typeof bloodOf === "function" ? bloodOf(bId) : "") || "";
      const mbtiA = (typeof mbtiOf === "function" ? mbtiOf(aId) : "") || "";
      const mbtiB = (typeof mbtiOf === "function" ? mbtiOf(bId) : "") || "";

      const distanceRegex = /(ê±°ë¦¬ê°|ì´ì§ˆê°|ì„œë¨¹|ì–´ìƒ‰í•œ ë¶„ìœ„ê¸°|ì–´ìƒ‰í•œ ê³µê¸°|ëƒ‰ë­í•œ|ì–¸ìŸ|ë‹¤íˆ¬|ë‹¤íˆ¼|ì‹¸ì›€|í‹°ê²©íƒœê²©|ëŒ€ë¦½|ê°ˆë“±)/;
      if (distanceRegex.test(sentence)){
        delta = Math.min(delta, -1);
      }

      // í‰í™”ë¡œìš´ ë¶„ìœ„ê¸°ì˜ ê°ìƒí˜• ì´ë²¤íŠ¸(ëˆˆ/í’ê²½ ê°ìƒ ë“±)ëŠ” -í˜¸ê°ë„ë¡œ ë§Œë“¤ì§€ ì•ŠëŠ”ë‹¤.
      const peacefulRegex = /(ëˆˆ ë‚´ë¦¬ëŠ” ì°½ê°€|í•˜ì–—ê²Œ ë®ì¸ í˜¸ê·¸ì™€íŠ¸|í’ê²½ì„ ë°”ë¼ë³´ì•˜ìŠµë‹ˆë‹¤|ì¡°ìš©íˆ ì°½ë°–ì„ ë°”ë¼ë³´ì•˜ìŠµë‹ˆë‹¤)/;
      if (peacefulRegex.test(sentence) && delta < 0){
        delta = 1;
      }

      // êµì‹¤ ì°½ê°€ì— ë‚˜ë€íˆ ì•‰ì•„ ìˆ˜ì—…ì„ ë“£ëŠ” ì¥ë©´ ë“±, ì¼ìƒì ì´ê³  ì”ì”í•œ ì¥ë©´ë„ -í˜¸ê°ë„ë¡œ ë§Œë“¤ì§€ ì•ŠëŠ”ë‹¤.
      const seatRegex = /(êµì‹¤ ì°½ê°€ ìë¦¬ì— ë‚˜ë€íˆ ì•‰ì•„ ìˆ˜ì—…ì„ ë“¤ì—ˆìŠµë‹ˆë‹¤|ë‚˜ë€íˆ ì•‰ì•„ ìˆ˜ì—…ì„ ë“¤ì—ˆìŠµë‹ˆë‹¤)/;
      if (seatRegex.test(sentence) && delta < 0){
        delta = 1;
      }



      if (contextKey !== "vacation"){
      const VALUE_LIST = ["ì´ìƒì£¼ì˜","í˜„ì‹¤ì£¼ì˜","í˜ˆí†µì¤‘ì‹œ","í‰ë“±ì£¼ì˜","ê¶Œìœ„ì¡´ì¤‘","ë°˜ê¶Œìœ„"];
      const aVal = traitsA.find(t=>VALUE_LIST.includes(t)) || null;
      const bVal = traitsB.find(t=>VALUE_LIST.includes(t)) || null;

      const valSet = new Set([aVal, bVal].filter(Boolean));
      const isOppositeValue =
        (valSet.has("ì´ìƒì£¼ì˜") && valSet.has("í˜„ì‹¤ì£¼ì˜")) ||
        (valSet.has("í˜ˆí†µì¤‘ì‹œ") && valSet.has("í‰ë“±ì£¼ì˜")) ||
        (valSet.has("ê¶Œìœ„ì¡´ì¤‘") && valSet.has("ë°˜ê¶Œìœ„"));

      if (isOppositeValue){
        delta = Math.min(delta, -1);
        if (!distanceRegex.test(sentence)){
          sentence = `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ${aVal}ì™€ ${bVal}ì— ëŒ€í•œ ì´ì•¼ê¸°ë¥¼ ë‚˜ëˆ„ë‹¤ ë³´ë‹ˆ, ìƒê° ì°¨ì´ë¡œ ì¸í•´ ë¯¸ë¬˜í•œ ê¸´ì¥ì„ ëŠê¼ˆìŠµë‹ˆë‹¤.`;
        }
      }

      const mixedBlood =
        (bloodA === "ë¨¸ê¸€ íƒœìƒ" && bloodB === "ìˆœí˜ˆ") ||
        (bloodB === "ë¨¸ê¸€ íƒœìƒ" && bloodA === "ìˆœí˜ˆ");

      if (mixedBlood){
        const aEqual = traitsA.includes("í‰ë“±ì£¼ì˜");
        const bEqual = traitsB.includes("í‰ë“±ì£¼ì˜");
        const aBloodFocus = traitsA.includes("í˜ˆí†µì¤‘ì‹œ");
        const bBloodFocus = traitsB.includes("í˜ˆí†µì¤‘ì‹œ");

        if (aBloodFocus || bBloodFocus){
          delta = Math.min(delta, -1);
          if (!distanceRegex.test(sentence)){
            sentence = `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ì„œë¡œ ë‹¤ë¥¸ í˜ˆí†µì„ ì˜ì‹í•˜ë©° ëŒ€í™”ë¥¼ ë‚˜ëˆ„ëŠ” ë™ì•ˆ, ë§ë¡œ í‘œí˜„í•˜ê¸° ì–´ë ¤ìš´ ê±°ë¦¬ê°ì„ ëŠê¼ˆìŠµë‹ˆë‹¤.`;
          }
        } else if (aEqual || bEqual){
          if (delta > 0) delta = 0;
        }
      }


      const conflictTraits = ["ë¶„ë…¸ì¡°ì ˆê³¤ë€","ì´ì¤‘ì„±","ì˜ì‹¬ë§ìŒ"];
      const calmTraits = ["ì˜¨í™”í•¨","ì¹¨ì°©í•¨","ìƒëƒ¥í•¨"];
      const hasConflict =
        traitsA.some(t=>conflictTraits.includes(t)) ||
        traitsB.some(t=>conflictTraits.includes(t));
      const hasCalm =
        traitsA.some(t=>calmTraits.includes(t)) ||
        traitsB.some(t=>calmTraits.includes(t));

      if (hasConflict && !hasCalm){
        delta = Math.min(delta, -1);
      }

      
      }

      // í•­ìƒ ê¸ì •ì ì´ì–´ì•¼ í•˜ëŠ” ì´ë²¤íŠ¸ ë³´í˜¸
      // ì˜ˆ: ì´ˆì½œë¦¿ì„ ë‚˜ëˆ„ì–´ ë¨¹ëŠ” ì¥ë©´, í•¨ê»˜ í¬ê²Œ ì›ƒëŠ” ì¥ë©´ ë“±ì€ -í˜¸ê°ë„ë¡œ ë–¨ì–´ì§€ì§€ ì•Šë„ë¡ ë§‰ëŠ”ë‹¤.
      const alwaysPositiveRegex = /(ì´ˆì½œë¦¿ì„ ë‚˜ëˆ„ì–´ ë¨¹ì—ˆìŠµë‹ˆë‹¤)/;
      const cheerfulRegex = /(ë– ë“¤ì©í•˜ê²Œ ì›ƒì—ˆìŠµë‹ˆë‹¤|ìƒˆ í•™ê¸° ì´ì•¼ê¸°ë¥¼ ë‚˜ëˆ„ë©° ë– ë“¤ì©í•˜ê²Œ ì›ƒì—ˆìŠµë‹ˆë‹¤)/;
      // ì¡°ìš©íˆ í•¨ê»˜ ì±…ì„ ì½ëŠ” ì¥ë©´ì€ -í˜¸ê°ë„ë¡œ ë³€í•˜ì§€ ì•Šë„ë¡ ë³´í˜¸
      const calmReadingRegex = /(ê°™ì€ ì±…ì„ ë‚˜ë€íˆ ì½ì—ˆìŠµë‹ˆë‹¤|í•¨ê»˜ ì±…ì„ ì½ì—ˆìŠµë‹ˆë‹¤|ì¡°ìš©íˆ ì±…ì„ ì½ì—ˆìŠµë‹ˆë‹¤)/;
      // ì¦ê±°ìš´/í‰í™”ë¡œìš´ ì¥ë©´ì€ ìµœì†Œ +1 í˜¸ê°ë„ë¡œ ê³ ì •
      if (alwaysPositiveRegex.test(sentence) || cheerfulRegex.test(sentence) || calmReadingRegex.test(sentence) || calmWalkRegex.test(sentence)){
        if (delta < 1) delta = 1;
      }

      // í•­ìƒ ë¶€ì •ì ì´ì–´ì•¼ í•˜ëŠ” ì´ë²¤íŠ¸ ë³´í˜¸
      // ì˜ˆ: ìƒì²˜ê°€ ë˜ëŠ” ë°œì–¸, ì„ ì„ ê¸‹ëŠ” ì¥ë©´ ë“±ì€ +í˜¸ê°ë„ë¡œ ì˜¬ë¼ê°€ì§€ ì•Šë„ë¡ ë§‰ëŠ”ë‹¤.
      const alwaysNegativeRegex = /(ìƒì²˜ê°€ ë  ë§ì„ í•´ ë²„ë ¸ìŠµë‹ˆë‹¤|ì„ ì„ ê¸‹ëŠ” ëª¨ìŠµì„ ë³´ì˜€ê³ , ë‘ ì‚¬ëŒ ì‚¬ì´ì—ëŠ” ì ì‹œ ì–´ìƒ‰í•œ ê³µê¸°ê°€ í˜ë €ìŠµë‹ˆë‹¤|í˜ˆí†µ' ë¬¸ì œë¥¼ ë‘ê³  ì˜ê²¬ì´ ê°•í•˜ê²Œ ëŒ€ë¦½í–ˆìŠµë‹ˆë‹¤)/;
      if (alwaysNegativeRegex.test(sentence) && delta > 0){
        delta = -1;
      }

// --- ìµœì¢… ì¼ê´€ì„± ë³´ì • ---
// (ìë™ìœ¼ë¡œ ë¶€ì •ì ì¸ ê¼¬ë¦¬ ë¬¸ì¥ì„ ë¶™ì´ì§€ ì•Šê³ ,
// ì´ë¯¸ ë¬¸ì¥ì— ë‹´ê¸´ ë‚´ìš©ë§Œìœ¼ë¡œ ê´€ê³„ ë³€í™”ë¥¼ í‘œí˜„í•œë‹¤.)


      // --- ì¶”ê°€ ë³´í˜¸ ê·œì¹™ ---
      // 'í˜ˆí†µì¤‘ì‹œ ì„±í–¥ì„ ë¶„ëª…í•˜ê²Œ ë“œëŸ¬ëƒˆìŠµë‹ˆë‹¤' ë¥˜ì˜ í™•ì • ê°ˆë“± ë¬¸êµ¬ì¸ë°
      // ìƒëŒ€ê°€ í‰ë“±ì£¼ì˜/ë°˜í˜ˆí†µ ê°€ì¹˜ê´€ì´ë¼ë©´ +í˜¸ê°ë„ë¡œ ë‚˜ì˜¤ëŠ” ê²ƒì„ ë°©ì§€
      try{
        const explicitBloodPride = /(í˜ˆí†µì¤‘ì‹œ.*ë¶„ëª…í•˜ê²Œ ë“œëŸ¬ëƒˆìŠµë‹ˆë‹¤)/;
        if(explicitBloodPride.test(sentence)){
          if(contextKey !== "vacation"){
            // ë‘ ìºë¦­í„°ì˜ ê°€ì¹˜ê´€ í‰ê°€
            const a = characters.find(c=>c.id===aId);
            const b = characters.find(c=>c.id===bId);
            const safeGet = c => Array.isArray(c?.traits) ? c.traits : [];
            const allA = safeGet(a).concat(safeGet(a?.feats));
            const allB = safeGet(b).concat(safeGet(b?.feats));
            const isBlood = (arr)=>arr.some(t=>/(í˜ˆí†µ|ìˆœí˜ˆ|í˜ˆí†µì¤‘ì‹œ)/.test(t));
            const isEquality = (arr)=>arr.some(t=>/(í‰ë“±|ë¨¸ê¸€|í¬ìš©|ë°˜í˜ˆí†µ)/.test(t));
            if((isBlood(allA) && isEquality(allB)) || (isBlood(allB) && isEquality(allA))) {
                if(delta > 0) delta = -1;
            }
          }
        }
      }catch(e){}

      // í‰ë“±ì£¼ì˜ / ì‚¬êµì  / ê¶Œìœ„ì¡´ì¤‘ ì¡°í•©ì— ëŒ€í•œ ìµœì¢… ë³´ì •
      // - í‰ë“±ì£¼ì˜ + ì‚¬êµì : ++í˜¸ê°ë„
      // - í‰ë“±ì£¼ì˜ (ì‚¬êµì  ì—†ìŒ): +í˜¸ê°ë„
      // - ê¶Œìœ„ì¡´ì¤‘ì´ í•œ ëª…ì´ë¼ë„ ë¼ì–´ ìˆìœ¼ë©´: ìµœëŒ€ +1ê¹Œì§€ë§Œ í—ˆìš©
      try{
        if (delta > 0){
          const hasEqualityA = traitsA.includes("í‰ë“±ì£¼ì˜");
          const hasEqualityB = traitsB.includes("í‰ë“±ì£¼ì˜");
          const hasAnyEquality = hasEqualityA || hasEqualityB;

          if (hasAnyEquality){
            const hasAuthorityA = traitsA.includes("ê¶Œìœ„ì¡´ì¤‘");
            const hasAuthorityB = traitsB.includes("ê¶Œìœ„ì¡´ì¤‘");
            const hasAuthority = hasAuthorityA || hasAuthorityB;

            const sociableA = traitsA.includes("ì‚¬êµì ");
            const sociableB = traitsB.includes("ì‚¬êµì ");
            const equalityAndSociable =
              (hasEqualityA && sociableA) ||
              (hasEqualityB && sociableB);

            if (hasAuthority){
              // ê¶Œìœ„ì¡´ì¤‘ ìºë¦­í„°ì™€ í‰ë“±ì£¼ì˜ ìºë¦­í„°ê°€ ëª…í™•íˆ ë§ˆì£¼ì¹˜ëŠ” ê²½ìš°: ê°ˆë“±ìœ¼ë¡œ ì²˜ë¦¬í•œë‹¤.
              const authorityOnlyA = hasAuthorityA && !hasEqualityA;
              const authorityOnlyB = hasAuthorityB && !hasEqualityB;
              const equalityOnlyA = hasEqualityA && !hasAuthorityA;
              const equalityOnlyB = hasEqualityB && !hasAuthorityB;
              const strictConflict =
                (authorityOnlyA && equalityOnlyB) ||
                (authorityOnlyB && equalityOnlyA);

              if (strictConflict){
                // ì´ë¯¸ ìŒìˆ˜ë©´ ìœ ì§€í•˜ë˜, 0 ì´ìƒì´ë©´ ìµœì†Œ -1ê¹Œì§€ ë–¨ì–´ëœ¨ë¦°ë‹¤.
                if (delta >= 0) delta = -1;
              } else {
                // ê·¸ ë°–ì˜ ì¡°í•©ì—ì„œëŠ” ê³¼ë„í•œ ì¹œë°€ë„ ìƒìŠ¹ë§Œ ë§‰ëŠ”ë‹¤.
                if (delta > 1) delta = 1;
              }
            } else {
              if (equalityAndSociable){
                // í‰ë“±ì£¼ì˜ì´ë©´ì„œ ì‚¬êµì ì¸ ìºë¦­í„°ê°€ ë¼ì–´ ìˆìœ¼ë©´ ++í˜¸ê°ë„ë¡œ ê³ ì •
                if (delta < 2) delta = 2;
              } else {
                // í‰ë“±ì£¼ì˜ì´ì§€ë§Œ ì‚¬êµì ì´ì§€ ì•Šì€ ê²½ìš°: +1ë¡œ í†µì¼
                if (delta < 1) delta = 1;
                if (delta > 1) delta = 1;
              }
            }
          }
        }
      }catch(e){}
      // ë¬¸ì¥ ì–´ê°ê³¼ í˜¸ê°ë„ ë¶€í˜¸ì˜ ìµœì¢… ì¼ê´€ì„± ì ê²€
      try{
        const negativeTone = /(ê¸´ì¥ê°ì´ ê°ëŒì•˜ìŠµë‹ˆë‹¤|ê¸´ì¥ëœ ë¶„ìœ„ê¸°ê°€ ê°ëŒì•˜ìŠµë‹ˆë‹¤|ì–´ìƒ‰í•œ ê³µê¸°ê°€ í˜ë €ìŠµë‹ˆë‹¤|ê±°ë¦¬ê°ì„ ëŠê¼ˆìŠµë‹ˆë‹¤|ì°¨ê°‘ê²Œ ëŒ€í–ˆìŠµë‹ˆë‹¤|ì–¸ìŸì´ ì˜¤ê°”ìŠµë‹ˆë‹¤|ì‹¸ì›€ì´ ë²Œì–´ì¡ŒìŠµë‹ˆë‹¤|ì”ì“¸í•œ í‘œì •ìœ¼ë¡œ ë¬¼ëŸ¬ë‚¬ìŠµë‹ˆë‹¤|ë§ˆìŒì†ì— ë¯¸ë¬˜í•œ ë¶ˆí¸í•¨ì´ ë‚¨ì•˜ìŠµë‹ˆë‹¤|í™”ë¥¼ ì´ê¸°ì§€ ëª»í•˜ê³ |ë‹¤íˆ¼ì„ ë²Œì˜€ìŠµë‹ˆë‹¤|ì„ ì„ ê¸‹ëŠ” ëª¨ìŠµì„ ë³´ì˜€ê³ |ê³ ë…í•œ í¸ì¸)/;
        const positiveTone = /(ë¯¸ì†Œë¥¼ ì§€ì—ˆìŠµë‹ˆë‹¤|ë¯¸ì†Œë¥¼ ì£¼ê³ ë°›ì•˜ìŠµë‹ˆë‹¤|ì›ƒì—ˆìŠµë‹ˆë‹¤|ë”°ëœ»í•œ ë¶„ìœ„ê¸°ì˜€ìŠµë‹ˆë‹¤|ë”°ëœ»í•œ ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤|ì•ˆë„ê°ì´ ê°ëŒì•˜ìŠµë‹ˆë‹¤|ê¸°ëŒ€ê°ì´ ê°€ë“í–ˆìŠµë‹ˆë‹¤|í‰í™”ë¡œìš´ ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤|í¸ì•ˆí•œ ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤|í¸ì•ˆí•œ ë¶„ìœ„ê¸°ë¥¼ ìœ ì§€í–ˆìŠµë‹ˆë‹¤|ë†ë‹´ì„ ì£¼ê³ ë°›ìœ¼ë©°|ê°™ì€ ì±…ì„ ë‚˜ë€íˆ ì½ì—ˆìŠµë‹ˆë‹¤|ì±…ì„ í•¨ê»˜ ì½ì—ˆìŠµë‹ˆë‹¤|ë‚˜ë€íˆ ì•‰ì•„ ì±…ì„ ì½ì—ˆìŠµë‹ˆë‹¤|í•¨ê»˜ ì‹œê°„ì„ ë³´ë‚´ë©°|í•¨ê»˜ ì‹œê°„ì„ ë³´ë‚´ê³  ìˆì—ˆìŠµë‹ˆë‹¤)/;

        const hasNegTone = negativeTone.test(sentence);
        const hasPosTone = positiveTone.test(sentence);

        if (hasNegTone && !hasPosTone && delta >= 0){
          delta = -1;
        } else if (hasPosTone && !hasNegTone && delta < 0){
          delta = 1;
        }
      }catch(e){}

      
      // íŠ¹ì • ë¶€ì • ë¬¸ì¥ì€ ì–´ë–¤ ê°’ì´ë”ë¼ë„ ìµœì¢…ì ìœ¼ë¡œ -í˜¸ê°ë„ë¡œ ê³ ì •
      try{
        const hardNegativeSentence = /(ê³ ë…í•œ í¸ì¸ ::.+?;;ëŠ” í•¨ê»˜ ìˆë˜ ::.+?;;ì—ê²Œë„ ì„ ì„ ê¸‹ëŠ” ëª¨ìŠµì„ ë³´ì˜€ê³ , ë‘ ì‚¬ëŒ ì‚¬ì´ì—ëŠ” ì ì‹œ ì–´ìƒ‰í•œ ê³µê¸°ê°€ í˜ë €ìŠµë‹ˆë‹¤\.)/;
        if (hardNegativeSentence.test(sentence) && delta > -1){
          delta = -1;
        }
      }catch(e){}
// ìµœì¢… ë³´ì • ì´í›„ì—ë„ ë²”ìœ„ë¥¼ ë„˜ì–´ê°€ëŠ” ê°’ì€ í´ë¨í•‘
      if (delta > 2) delta = 2;
      if (delta < -2) delta = -2;

      return { sentence, delta };
    }


function formatAffinityTag(delta){
      if (!delta) return "";
      if (delta === 1) return "(+í˜¸ê°ë„)";
      if (delta === -1) return "(-í˜¸ê°ë„)";
      if (delta > 1) return "(++í˜¸ê°ë„)";
      return "(--í˜¸ê°ë„)";
    }

    function formatPairRelationLabel(aId, bId){
      const k = pairKey(aId, bId);
      const relKey = relations[k] || DEFAULT_REL;
      // ì•„ëŠ” ì‚¬ì´ëŠ” ì œì™¸í•˜ê³ , 2ì¸ ê´€ê³„ íƒœê·¸ë§Œ ë¶™ì´ê¸°
      if (relKey === "friend") return "[ì¹œêµ¬]";
      if (relKey === "best") return "[ì ˆì¹œ]";
      if (relKey === "love") return "[ì—°ì¸]";
      if (relKey === "dislike") return "[ì‹«ì–´í•˜ëŠ” ì‚¬ì´]";
      if (relKey === "hate") return "[í˜ì˜¤í•˜ëŠ” ì‚¬ì´]";
      return "";
    }

    function makeRelationFlavorSentence(A, B, aId, bId){
      const k = pairKey(aId, bId);
      const relKey = relations[k] || DEFAULT_REL;
      const pair = `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;`;
      let pool = [];
      if (relKey === "friend"){
        pool = [
          `${pair}ëŠ” ì‚¬ì†Œí•œ ë†ë‹´ì„ ì£¼ê³ ë°›ìœ¼ë©° í¸ì•ˆí•œ ë¶„ìœ„ê¸°ë¥¼ ìœ ì§€í–ˆìŠµë‹ˆë‹¤.`,
          `${pair}ëŠ” ê°™ì€ ìë¦¬ì— ì•‰ì•„ ìì—°ìŠ¤ëŸ½ê²Œ í•˜ë£¨ ì´ì•¼ê¸°ë¥¼ ë‚˜ëˆ„ì—ˆìŠµë‹ˆë‹¤.`
        ];
      } else if (relKey === "best"){
        pool = [
          `${pair}ëŠ” ë§í•˜ì§€ ì•Šì•„ë„ ì„œë¡œì˜ ìƒê°ì„ ì§ì‘í•  ë§Œí¼ ê°€ê¹Œì›Œ ë³´ì˜€ìŠµë‹ˆë‹¤.`,
          `${pair}ì˜ ëŒ€í™”ì—ëŠ” ì˜¤ëœ ì‹œê°„ ìŒ“ì¸ ì‹ ë¢°ê°€ ê³ ìŠ¤ë€íˆ ë¬»ì–´ë‚¬ìŠµë‹ˆë‹¤.`
        ];
      } else if (relKey === "love"){
        pool = [
          `${pair}ëŠ” ë³µë„ ëì—ì„œ ëˆˆì´ ë§ˆì£¼ì¹˜ì ì ì‹œ ì£¼ë³€ ì†Œë¦¬ê°€ ëª¨ë‘ ì‚¬ë¼ì§„ ë“¯ ëŠê¼ˆìŠµë‹ˆë‹¤.`,
          `${pair}ëŠ” ì‚¬ëŒë“¤ í‹ˆ ì‚¬ì´ì—ì„œë„ ìì—°ìŠ¤ëŸ½ê²Œ ì„œë¡œë¥¼ ì°¾ì•„ ë‚˜ë€íˆ ê±·ê¸° ì‹œì‘í–ˆìŠµë‹ˆë‹¤.`
        ];
      } else if (relKey === "dislike"){
        pool = [
          `${pair}ëŠ” ê°™ì€ ì¡°ê°€ ë˜ìë§ˆì ëˆˆì— ë„ê²Œ í‘œì •ì´ êµ³ì–´ì¡ŒìŠµë‹ˆë‹¤.`,
          `${pair}ëŠ” í•„ìš”í•œ ë§ë§Œ ì§§ê²Œ ì£¼ê³ ë°›ìœ¼ë©° ì°¨ê°€ìš´ ê±°ë¦¬ë¥¼ ìœ ì§€í–ˆìŠµë‹ˆë‹¤.`
        ];
      } else if (relKey === "hate"){
        pool = [
          `${pair}ëŠ” ê°€ëŠ¥í•œ í•œ ì„œë¡œë¥¼ ë³´ì§€ ì•Šìœ¼ë ¤ ì• ì“°ëŠ” ë“¯ ë³´ì˜€ìŠµë‹ˆë‹¤.`,
          `${pair}ê°€ ë§ˆì£¼ì¹˜ëŠ” ìˆœê°„, ì£¼ë³€ ê³µê¸°ê¹Œì§€ ì„œëŠ˜í•´ì§€ëŠ” ë“¯í•œ ê¸´ì¥ì´ ê°ëŒì•˜ìŠµë‹ˆë‹¤.`
        ];
      }
      if (!pool.length) return "";
      return pick(pool);
    }

    function shuffle(arr){
      const a = arr.slice();
      for (let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]]=[a[j],a[i]];
      }
      return a;
    }

    // pick group sizes so that everyone appears exactly once (coverage-based)
    function makeGroups(charIds){
      const ids = shuffle(charIds);

      // Special case: 2 characters
      // 65%: together (1 log), 35%: separate (2 logs)
      if (ids.length === 2){
        return (Math.random() < 0.25) ? [[ids[0], ids[1]]] : [[ids[0]],[ids[1]]];
      }

      // Mixed variation mode (for 3+):
      // Each character independently tends to be solo with 40% ì •ë„ í™•ë¥ .
      // ë‚¨ì€ ìºë¦­í„°ë“¤ì€ ë‘˜ ì´ìƒìœ¼ë¡œ ë¬¶ì–´ (ì¼ë°˜ì ìœ¼ë¡œ 2ì¸, ê°€ë” 3ì¸) ì´ë²¤íŠ¸ë¥¼ ë§Œë“ ë‹¤.
      const solos = [];
      const together = [];

      ids.forEach(id=>{
        (Math.random() < 0.40 ? solos : together).push(id);
      });

      // Avoid impossible leftover: if together has exactly 1, move one solo over.
      if (together.length === 1){
        together.push(solos.pop());
      }

      // Group solos
      const groups = [];
      solos.forEach(id=> groups.push([id]));

      // Group the rest: occasional trio if it helps
      let pool = together.slice();

      if (pool.length >= 3 && Math.random() < 0.25){
        if (pool.length % 2 === 1){
          groups.push(pool.splice(0,3));
        }
      }

      while (pool.length > 0){
        if (pool.length === 1){
          groups.push([pool.shift()]);
          break;
        }
        const a = pool.shift();
        const b = pool.shift();
        groups.push([a,b]);
      }

      return shuffle(groups);
    }

    // sentence templates (report-style)
    const SOLO_TEMPLATES = [
      (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ì°½ ë°–ì„ ë°”ë¼ë³´ë©° ë¯¸ë˜ë¥¼ ê¸°ëŒ€í–ˆìŠµë‹ˆë‹¤.`,
      (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ì£¼ë³€ì„ ì‚´í”¼ë©° ì¡°ìš©íˆ ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`,
      (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ë°°ì •ì‹ì´ ì–´ë–¤ ëª¨ìŠµì¼ì§€ ìƒìƒí–ˆìŠµë‹ˆë‹¤.`,
      (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} í˜¸ê·¸ì™€íŠ¸ì—ì„œ ì–´ë–¤ ì¹œêµ¬ë“¤ì„ ë§Œë‚˜ê²Œ ë ì§€ ìƒìƒí–ˆìŠµë‹ˆë‹¤.`,
      (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} í†µë¡œë¥¼ ì§€ë‚˜ê°€ë©° ë‹¤ë¥¸ í•™ìƒë“¤ì„ ê´€ì°°í–ˆìŠµë‹ˆë‹¤.`
    ];

    const PAIR_TEMPLATES = [
      (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ë§ˆì£¼ì•‰ì•„ ì´ˆì½œë¦¿ì„ ë‚˜ëˆ„ì–´ ë¨¹ì—ˆìŠµë‹ˆë‹¤.`,
      (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ê°€ê³  ì‹¶ì€ ê¸°ìˆ™ì‚¬ì— ëŒ€í•´ ì´ì•¼ê¸°ë¥¼ ë‚˜ëˆ„ì—ˆìŠµë‹ˆë‹¤.`,
      (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ê°™ì€ ì¹¸ì— ì•‰ì•„ ì—´ì°¨ê°€ ë‹¬ë¦¬ëŠ” í’ê²½ì„ ë°”ë¼ë³´ì•˜ìŠµë‹ˆë‹¤.`,
      (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ê°„ì‹ ìƒìë¥¼ ì‚¬ì´ì— ë‘ê³  ì§§ì€ ëŒ€í™”ë¥¼ ì´ì–´ê°”ìŠµë‹ˆë‹¤.`,
      (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} í˜¸ê·¸ì™€íŠ¸ì— ëŒ€í•œ ì†Œë¬¸ì„ ì£¼ê³ ë°›ì•˜ìŠµë‹ˆë‹¤.`
    ];

    const TRIO_TEMPLATES = [
      (A,B,C)=> `::${A};;, ::${B};;, ::${C};;${pickJosa(C,"ì€ëŠ”")} í•œ ì¹¸ì— ëª¨ì—¬ ê°„ì‹ì„ ë‚˜ëˆ„ì–´ ë¨¹ì—ˆìŠµë‹ˆë‹¤.`,
      (A,B,C)=> `::${A};;, ::${B};;, ::${C};;${pickJosa(C,"ì€ëŠ”")} ì„œë¡œì˜ ë°°ì •ì‹ ì˜ˆìƒì— ëŒ€í•´ ì˜ê²¬ì„ ë‚˜ëˆ„ì—ˆìŠµë‹ˆë‹¤.`,
      (A,B,C)=> `::${A};;, ::${B};;, ::${C};;${pickJosa(C,"ì€ëŠ”")} ì—´ì°¨ ì•ˆì˜ ë¶„ìœ„ê¸°ë¥¼ ì‚´í”¼ë©° ëŒ€í™”ë¥¼ ì´ì–´ê°”ìŠµë‹ˆë‹¤.`
    ];

    // Add flavor based on traits / values (still short)
    function maybeFlavorLine(group){
      // small chance to add a second line? User wanted ê°„ë‹¨, so keep OFF by default.
      return null;
    }

    function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }

    function tagForLog(id){
      const c = characters.find(c=>c.id===id);
      if (!c) return "";
      const mb = String(c.mbti || "").toUpperCase();
      if (mb) return `[${mb}] `;
      const ts = (c.traits || []);
      let picked = ts.find(x=>VALUE_TRAITS.has(x)) || ts[0];
      if (picked) return `[${picked}] `;
      if (c.house) return `[${c.house}] `;
      if (c.blood) return `[${c.blood}] `;
      return "";
    }


    // í•™ê¸°(í•™ë…„) ì§„í–‰ìš© ì‹œì¦Œ ì´ë²¤íŠ¸ í…œí”Œë¦¿
    const SEASON_KEYS = ["autumn","winter","spring","summer"];
    const SEASON_NAME_MAP = {
      autumn: "ê°€ì„",
      winter: "ê²¨ìš¸",
      spring: "ë´„",
      summer: "ì—¬ë¦„"
    };

    // 1ì¸ ì¼ë°˜ ì´ë²¤íŠ¸ (ê³„ì ˆë³„)
    const SEASON_SOLO_GENERAL = {
      autumn: [
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ë‚¡ì€ ë§ˆë²•ì„œë¥¼ í¼ì³ ìƒˆ í•™ê¸° ì£¼ë¬¸ì— ë°‘ì¤„ì„ ê·¸ì—ˆìŠµë‹ˆë‹¤.`,
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ì‹ í•™ê¸°ì˜ ê³µê¸°ê°€ ë°´ ëŒë°”ë‹¥ ë³µë„ë¥¼ ì²œì²œíˆ ê±¸ì—ˆìŠµë‹ˆë‹¤.`,
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ë‚™ì—½ì´ í©ë‚ ë¦¬ëŠ” ì°½ë°–ì„ ë³´ë©° í˜¸ê·¸ì™€íŠ¸ ìƒí™œì„ ìƒìƒí–ˆìŠµë‹ˆë‹¤.`,
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ê¸°ìˆ™ì‚¬ ê³µìš©ì‹¤ ë‚œë¡œ ì•ì—ì„œ ì¡°ìš©íˆ ì±…ì„ í¼ì³¤ìŠµë‹ˆë‹¤.`
      ],
      winter: [
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ë‚œë¡œ ì˜†ì—ì„œ ë‘êº¼ìš´ ë¡œë¸Œë¥¼ ì—¬ë¯¸ê³  ë§ˆë²• ì´ë¡ ì„œë¥¼ ì½ì—ˆìŠµë‹ˆë‹¤.`,
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ì°½ë°–ì— ë‚´ë¦¬ëŠ” ëˆˆì„ ë°”ë¼ë³´ë©° ë¬µì§í•œ ìƒê°ì— ì ê²¼ìŠµë‹ˆë‹¤.`,
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ì°¨ê°€ìš´ ê³µê¸° ì†ì—ì„œë„ ë˜ì „ ìˆ˜ì—…ì„ ë¬µë¬µíˆ ë”°ë¼ê°”ìŠµë‹ˆë‹¤.`,
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ë”°ëœ»í•œ í˜¸ë°• ì£¼ìŠ¤ë¥¼ ë§ˆì‹œë©° ì–‘í”¼ì§€ì— ë©”ëª¨ë¥¼ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤.`
      ],
      spring: [
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ë”°ëœ»í•œ í–‡ì‚´ ì•„ë˜ í˜¸ìˆ˜ ê·¼ì²˜ë¥¼ ì‚°ì±…í•˜ë©° ë¨¸ë¦¬ë¥¼ ì‹í˜”ìŠµë‹ˆë‹¤.`,
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ì„± ë°– ì–¸ë•ì„ ì˜¤ë¥´ë‚´ë¦¬ë©° ë´„ê¸°ìš´ì„ ì‹¤ì»· ëŠê¼ˆìŠµë‹ˆë‹¤.`,
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ì˜¨ì‹¤ ê·¼ì²˜ë¥¼ ì§€ë‚˜ë©° í—ˆë¸Œí•™ ìˆ˜ì—…ì„ ë– ì˜¬ë ¸ìŠµë‹ˆë‹¤.`,
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ê¸°ìˆ™ì‚¬ ì°½ê°€ì— ê¸°ëŒ€ ì•‰ì•„ í”¼ì–´ë‚œ ê½ƒë“¤ì„ í•œë™ì•ˆ ë°”ë¼ë³´ì•˜ìŠµë‹ˆë‹¤.`
      ],
      summer: [
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} í›„í…ì§€ê·¼í•œ ê³µê¸° ì†ì—ì„œë„ ì—°ìŠµì¥ì„ í´ê³  ì£¼ë¬¸ì„ ë˜ë‡Œì—ˆìŠµë‹ˆë‹¤.`,
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} í˜¸ìˆ˜ì—ì„œ ë¶ˆì–´ì˜¤ëŠ” ë°”ëŒì„ ë§ìœ¼ë©° ë‹¤ê°€ì˜¤ëŠ” ì‹œí—˜ì„ ê±±ì •í–ˆìŠµë‹ˆë‹¤.`,
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ëœ¨ê±°ìš´ í–‡ì‚´ì„ í”¼í•´ ê³µìš©ì‹¤ ê·¸ëŠ˜ì§„ ì†ŒíŒŒì— ëª¸ì„ íŒŒë¬»ì—ˆìŠµë‹ˆë‹¤.`,
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ëŠ¦ì€ ì €ë…, ë³„ì´ ë– ì˜¤ë¥¸ ì°½ì„ ì˜¬ë ¤ë‹¤ë³´ë©° ì˜¤ëŠ˜ í•˜ë£¨ë¥¼ ë˜ì§šì—ˆìŠµë‹ˆë‹¤.`
      ]
    };

    // 2ì¸ ì¼ë°˜ ì´ë²¤íŠ¸
    const SEASON_PAIR_GENERAL = {
      autumn: [
        (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ë§ˆë²•ì•½ ê³¼ì œ ì´ì•¼ê¸°ë¥¼ ë‚˜ëˆ„ë©° ì„± ì•ˆ ë³µë„ë¥¼ í•¨ê»˜ ê±¸ì—ˆìŠµë‹ˆë‹¤.`,
        (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ëŒ€ì—°íšŒì¥ì˜ ê¸´ í…Œì´ë¸”ì—ì„œ ë§ˆì£¼ ì•‰ì•„ ì €ë…ì„ ë¨¹ì—ˆìŠµë‹ˆë‹¤.`,
        (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ê³µìš©ì‹¤ í•œì¼ ì—ì„œ ê°™ì€ ì±…ì„ ë‚˜ë€íˆ ì½ì—ˆìŠµë‹ˆë‹¤.`
      ],
      winter: [
        (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ê¸°ìˆ™ì‚¬ ê³µìš©ì‹¤ ë‚œë¡œ ì• ì†ŒíŒŒì— ë‚˜ë€íˆ ì•‰ì•„ ì´ì•¼ê¸°ë¥¼ ë‚˜ëˆ„ì—ˆìŠµë‹ˆë‹¤.`,
        (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ì‹œí—˜ì„ ì•ë‘ê³  ë§ˆë²• ì´ë¡ ì„ í•¨ê»˜ ë³µìŠµí–ˆìŠµë‹ˆë‹¤.`,
        (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ëˆˆ ë‚´ë¦¬ëŠ” ì°½ê°€ì— ì„œì„œ í•˜ì–—ê²Œ ë®ì¸ í˜¸ê·¸ì™€íŠ¸ ë§ˆë‹¹ì„ ë°”ë¼ë³´ì•˜ìŠµë‹ˆë‹¤.`
      ],
      spring: [
        (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ë´„ë°”ëŒ ë¶€ëŠ” í˜¸ê·¸ì™€íŠ¸ ì•ë§ˆë‹¹ì„ í•¨ê»˜ ê±¸ì—ˆìŠµë‹ˆë‹¤.`,
        (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ìˆ˜ì—…ì´ ëë‚œ ë’¤ í€´ë””ì¹˜ ê²½ê¸°ì¥ ê·¼ì²˜ ì”ë””ë°­ì„ ì²œì²œíˆ ê±°ë‹ì—ˆìŠµë‹ˆë‹¤.`,
        (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} êµì‹¤ ì°½ê°€ ìë¦¬ì— ë‚˜ë€íˆ ì•‰ì•„ ìˆ˜ì—…ì„ ë“¤ì—ˆìŠµë‹ˆë‹¤.`
      ],
      summer: [
        (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ì‹œì›í•˜ê²Œ ì‹íŒ í˜¸ë°• ì£¼ìŠ¤ë¥¼ ì‚¬ì´ì— ë‘ê³  ì´ì•¼ê¸°ë¥¼ ë‚˜ëˆ„ì—ˆìŠµë‹ˆë‹¤.`,
        (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ë”ìœ„ë¥¼ í”¼í•´ ê³µìš©ì‹¤ ê·¸ëŠ˜ì§„ êµ¬ì„ì— ë‚˜ë€íˆ ì•‰ì•˜ìŠµë‹ˆë‹¤.`,
        (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ëŠ¦ì€ ì‹œê°„, ì¡°ìš©í•œ ë¹ˆ êµì‹¤ì—ì„œ í•¨ê»˜ ë§ˆë²• ìˆ™ì œë¥¼ í•´ê²°í–ˆìŠµë‹ˆë‹¤.`
      ]
    };

    // 2ì¸ íŠ¹ì„± ì´ë²¤íŠ¸ (íƒœê·¸ ì—†ì´ ê´€ê³„ ì¤‘ì‹¬)
    const SEASON_PAIR_TRAIT = {
      autumn: [
        (aId,bId)=> {
          const A = nameOf(aId), B = nameOf(bId);
          return `ìƒˆ í•™ê¸°ì— ê¸´ì¥í•œ ::${A};;ì—ê²Œ ::${B};;${pickJosa(B,"ì´ê°€")} ë¨¼ì € ë§ì„ ê±¸ì–´ ì£¼ì—ˆìŠµë‹ˆë‹¤.`;
        },
        (aId,bId)=> {
          const A = nameOf(aId), B = nameOf(bId);
          return `::${A};;${pickJosa(A,"ì€ëŠ”")} ë‚¯ì„  í™˜ê²½ì´ ë¶ˆì•ˆí–ˆì§€ë§Œ, ::${B};;${pickJosa(B,"ê³¼ì™€")} í•¨ê»˜ ìˆìœ¼ë‹ˆ ì¡°ê¸ˆ ì•ˆì‹¬ì´ ë˜ì—ˆìŠµë‹ˆë‹¤.`;
        }
      ],
      winter: [
        (aId,bId)=> {
          const A = nameOf(aId), B = nameOf(bId);
          return `::${A};;${pickJosa(A,"ì´ê°€")} ì¶”ì›Œí•˜ëŠ” ëª¨ìŠµì„ ë³¸ ::${B};;${pickJosa(B,"ì´ê°€")} ë¡œë¸Œë¥¼ ì¡°ê¸ˆ ë‚´ì£¼ì—ˆìŠµë‹ˆë‹¤.`;
        },
        (aId,bId)=> {
          const A = nameOf(aId), B = nameOf(bId);
          return `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ì‹œí—˜ì„ ì•ë‘ê³  ì„œë¡œì—ê²Œ ì†”ì§í•œ ê³ ë¯¼ì„ í„¸ì–´ë†“ì•˜ìŠµë‹ˆë‹¤.`;
        }
      ],
      spring: [
        (aId,bId)=> {
          const A = nameOf(aId), B = nameOf(bId);
          return `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ë´„ ê¸°ë¶„ì— ë“¤ë–  í•œë™ì•ˆ ì¡ë‹´ì„ ì´ì–´ê°”ìŠµë‹ˆë‹¤.`;
        },
        (aId,bId)=> {
          const A = nameOf(aId), B = nameOf(bId);
          return `::${A};;${pickJosa(A,"ì€ëŠ”")} ì§€ì¹œ ::${B};;ì—ê²Œ ì ê¹ ë°–ì— ë‚˜ê°€ìê³  ì œì•ˆí–ˆìŠµë‹ˆë‹¤.`;
        }
      ],
      summer: [
        (aId,bId)=> {
          const A = nameOf(aId), B = nameOf(bId);
          return `ë”ìœ„ì— ì§€ì¹œ ::${A};;ì—ê²Œ ::${B};;${pickJosa(B,"ì´ê°€")} ì‹œì›í•œ ìŒë£Œë¥¼ ê±´ë„¤ì£¼ì—ˆìŠµë‹ˆë‹¤.`;
        },
        (aId,bId)=> {
          const A = nameOf(aId), B = nameOf(bId);
          return `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ì¡°ìš©í•œ ì˜¤í›„ë¥¼ í•¨ê»˜ ë³´ë‚´ë©° ì¡°ê¸ˆ ë” ê°€ê¹Œì›Œì¡ŒìŠµë‹ˆë‹¤.`;
        }
      ]
    };

    // 3ì¸ ì´ìƒ ì¼ë°˜ ì´ë²¤íŠ¸
    const SEASON_GROUP_GENERAL = {
      autumn: [
        (names)=> `${names} ìƒˆ í•™ê¸° ì´ì•¼ê¸°ë¥¼ ë‚˜ëˆ„ë©° ë– ë“¤ì©í•˜ê²Œ ì›ƒì—ˆìŠµë‹ˆë‹¤.`
      ],
      winter: [
        (names)=> `${names} ë‚œë¡œ ì•ì— ëª¨ì—¬ ì„œë¡œì˜ ì‹œí—˜ ëŒ€ë¹„ ê³„íšì„ ê³µìœ í–ˆìŠµë‹ˆë‹¤.`
      ],
      spring: [
        (names)=> `${names} ë´„ë°”ëŒì´ ë¶€ëŠ” êµì •ì„ í•¨ê»˜ ë›°ì–´ë‹¤ë…”ìŠµë‹ˆë‹¤.`
      ],
      summer: [
        (names)=> `${names} ì‹œì›í•œ ê³µìš©ì‹¤ì— ëª¨ì—¬ í•œê°€ë¡œìš´ ì˜¤í›„ë¥¼ ë³´ëƒˆìŠµë‹ˆë‹¤.`
      ]
    };

    function joinNamesForGroupSubject(ids){
      const plain = ids.map(id => nameOf(id));
      if (!plain.length) return "";
      const last = plain[plain.length - 1] || "";
      const code = last.charCodeAt(last.length - 1);
      const hasBatchim = (code - 0xAC00) % 28 !== 0;
      const lastParticle = hasBatchim ? "ì´ëŠ”" : "ëŠ”";
      if (plain.length === 1){
        return `::${last};;${lastParticle}`;
      }
      const front = plain.slice(0, -1).map(n => `::${n};;`).join(", ");
      const lastMarkup = `::${last};;${lastParticle}`;
      return `${front}, ${lastMarkup}`;
    }


    function mbtiOf(id){
      const mb = (characters.find(c=>c.id===id)?.mbti || "").toUpperCase();
      return mb;
    }

    function houseOf(id){
      const c = characters.find(c=>c.id===id);
      return c && c.house ? c.house : "";
    }

    function bloodOf(id){
      const c = characters.find(c=>c.id===id);
      return c && c.blood ? c.blood : "";
    }

    function seasonSoloTraitLine(id, key){
      const tag = tagForLog(id);
      const A = nameOf(id);
      const mb = mbtiOf(id);
      const upper = mb || "";
      const isI = upper.startsWith("I");
      const isE = upper.startsWith("E");
      const isN = upper.length >= 2 && upper[1] === "N";
      const isS = upper.length >= 2 && upper[1] === "S";
      const isT = upper.length >= 3 && upper[2] === "T";
      const isF = upper.length >= 3 && upper[2] === "F";
      const isJ = upper.length >= 4 && upper[3] === "J";
      const isP = upper.length >= 4 && upper[3] === "P";

      if (key === "autumn"){
        if (isI) return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ìƒˆ í•™ê¸° ë¶„ìœ„ê¸°ë¥¼ ë©€ë¦¬ì„œ ì§€ì¼œë³´ë©° ì¡°ìš©íˆ ì ì‘í–ˆìŠµë‹ˆë‹¤.`;
        if (isE) return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ìƒˆ í•™ê¸°ì— ë“¤ë–  ì—¬ëŸ¬ ì‚¬ëŒì—ê²Œ ë¨¼ì € ë§ì„ ê±¸ì—ˆìŠµë‹ˆë‹¤.`;
        if (isN) return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ì•ìœ¼ë¡œ ë²Œì–´ì§ˆ ì¼ë“¤ì„ ìƒìƒí•˜ë©° ì°½ë°–ì„ ë°”ë¼ë³´ì•˜ìŠµë‹ˆë‹¤.`;
        if (isS) return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ë§ˆë²•ì„œì™€ ì‹œê°„í‘œë¥¼ ê¼¼ê¼¼íˆ í™•ì¸í•˜ë©° ê³„íšì„ ì„¸ì› ìŠµë‹ˆë‹¤.`;
        return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ìƒˆ í•™ê¸°ë¥¼ ì–´ë–»ê²Œ ë³´ë‚¼ì§€ ì²œì²œíˆ ìƒê°í–ˆìŠµë‹ˆë‹¤.`;
      }

      if (key === "winter"){
        if (isF) return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ë‚œë¡œ ê³ì—ì„œ ì¡°ìš©íˆ ë§ˆìŒì„ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤.`;
        if (isT) return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ì‹œí—˜ ëŒ€ë¹„ ê³„íšì„ ì„¸ìš°ë©° ì°¨ë¶„íˆ ë…¸íŠ¸ë¥¼ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤.`;
        if (isI) return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ì¡°ìš©í•œ êµ¬ì„ì—ì„œ í˜¼ì ê³µë¶€í•  ìë¦¬ë¥¼ ì°¾ì•˜ìŠµë‹ˆë‹¤.`;
        if (isE) return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ì¶”ìš´ ë‚ ì”¨ì—ë„ ì¹œêµ¬ë“¤ê³¼ í•¨ê»˜ ìˆìœ¼ë ¤ê³  ê³µìš©ì‹¤ì— ë‚˜ê°”ìŠµë‹ˆë‹¤.`;
        return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ì°¨ê°€ìš´ ê³µê¸° ì†ì—ì„œë„ ë¬µë¬µíˆ ê³µë¶€ë¥¼ ì´ì–´ê°”ìŠµë‹ˆë‹¤.`;
      }

      if (key === "spring"){
        if (isP) return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ê°‘ìê¸° ë– ì˜¤ë¥¸ ìƒê°ì— ì´ëŒë ¤ ë´„ë°”ëŒ ë¶€ëŠ” êµì •ì„ ê±¸ì—ˆìŠµë‹ˆë‹¤.`;
        if (isJ) return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ë´„ì—ë„ ííŠ¸ëŸ¬ì§€ì§€ ì•Šìœ¼ë ¤ ê³„íšëŒ€ë¡œ ê³µë¶€ë¥¼ ì´ì–´ê°”ìŠµë‹ˆë‹¤.`;
        if (isN) return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ì°½ë°–ì˜ ê½ƒì„ ë³´ë©° ì•ìœ¼ë¡œì˜ ê°€ëŠ¥ì„±ì„ ìƒìƒí–ˆìŠµë‹ˆë‹¤.`;
        if (isS) return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ì£¼ë³€ì˜ ì‘ì€ ë³€í™”ë“¤ì„ ëˆˆì—¬ê²¨ë³´ë©° í•˜ë£¨ë¥¼ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
        return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ë”°ëœ»í•œ ë´„ ê³µê¸° ì†ì—ì„œ ì¡°ìš©íˆ ë§ˆìŒì„ ê°€ë‹¤ë“¬ì—ˆìŠµë‹ˆë‹¤.`;
      }

      if (key === "summer"){
        if (isE) return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ë”ìš´ ë‚ ì”¨ì—ë„ ì¹œêµ¬ë“¤ê³¼ ì–´ìš¸ë¦¬ë©° í™œê¸°ë¥¼ ìƒì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`;
        if (isI) return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ì‹œì›í•œ ì‹¤ë‚´ë¥¼ ì°¾ì•„ í˜¼ìë§Œì˜ ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
        if (isP) return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ëŠê¸‹í•œ ë¶„ìœ„ê¸°ì— íœ©ì“¸ë ¤ ì ì‹œ ê³µë¶€ë¥¼ ë¯¸ë¤˜ë‹¤ê°€ ë‹¤ì‹œ ì±…ì„ í¼ì³¤ìŠµë‹ˆë‹¤.`;
        if (isJ) return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ë”ìš´ ë‚ ì”¨ì—ë„ ì¼ì •í‘œë¥¼ ì§€í‚¤ë ¤ ë…¸ë ¥í–ˆìŠµë‹ˆë‹¤.`;
        return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ë”ìš´ ë‚ ì”¨ íƒ“ì— ì ì‹œ ì§‘ì¤‘ë ¥ì„ ìƒì—ˆë‹¤ê°€ ë‹¤ì‹œ ë§ˆìŒì„ ë‹¤ì¡ì•˜ìŠµë‹ˆë‹¤.`;
      }

      return `${tag}::${A};;${pickJosa(A,"ì€ëŠ”")} ì˜¤ëŠ˜ í•˜ë£¨ë¥¼ ì¡°ìš©íˆ ëŒì•„ë³´ì•˜ìŠµë‹ˆë‹¤.`;
    }

    function currentSeasonKey(){
      const idx = Number.isFinite(story.seasonIndex) ? Math.min(Math.max(story.seasonIndex, 0), 3) : 0;
      return SEASON_KEYS[idx] || "autumn";
    }

    
    function formatBloodLabel(blood){
      if (blood === "ë¶ˆëª…") return "í˜ˆí†µ ë¶ˆëª…";
      return blood || "";
    }

    function soloTraitSentence(name, trait){
      switch(trait){
        case "ë‚™ì²œì ":
          return `[ë‚™ì²œì ] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì‚¬ì†Œí•œ ì¼ì—ë„ ì›ƒìŒì„ í„°ëœ¨ë¦¬ë©° ì£¼ë³€ ë¶„ìœ„ê¸°ë¥¼ ë°ê²Œ ë§Œë“¤ì—ˆìŠµë‹ˆë‹¤.`;
        case "ì‹ ì¤‘í•¨":
          return `[ì‹ ì¤‘í•¨] ::${name};;${pickJosa(name,"ì€ëŠ”")} ê²°ì •ì„ ë‚´ë¦¬ê¸° ì „ì— ì—¬ëŸ¬ ë²ˆ ê³ ë¯¼í•˜ë©° ë…¸íŠ¸ë¥¼ ê¼¼ê¼¼íˆ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤.`;
        case "ëƒ‰ì •í•¨":
          return `[ëƒ‰ì •í•¨] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì£¼ë³€ì˜ ì†Œë€ì—ë„ íœ©ì“¸ë¦¬ì§€ ì•Šê³  ë‹´ë‹´í•˜ê²Œ ìƒí™©ì„ ì§€ì¼œë³´ì•˜ìŠµë‹ˆë‹¤.`;
        case "í˜¸ê¸°ì‹¬":
          return `[í˜¸ê¸°ì‹¬] ::${name};;${pickJosa(name,"ì€ëŠ”")} ìƒˆë¡œìš´ ë§ˆë²•ê³¼ ì†Œë¬¸ì— ëŒ€í•´ ëŠì„ì—†ì´ ì§ˆë¬¸ì„ ë˜ì¡ŒìŠµë‹ˆë‹¤.`;
        case "ì„±ì‹¤í•¨":
          return `[ì„±ì‹¤í•¨] ::${name};;${pickJosa(name,"ì€ëŠ”")} ëª¨ë‘ê°€ ì‰¬ëŠ” ì‹œê°„ì—ë„ ë‚¨ì€ ìˆ™ì œë¥¼ ì±™ê²¨ ë§ˆì³¤ìŠµë‹ˆë‹¤.`;
        case "ì‚¬êµì ":
          return `[ì‚¬êµì ] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì²˜ìŒ ë³´ëŠ” ì¹œêµ¬ì—ê²Œë„ ìì—°ìŠ¤ëŸ½ê²Œ ë§ì„ ê±¸ë©° ê¸ˆì„¸ ì–´ìš¸ë ¸ìŠµë‹ˆë‹¤.`;
        case "ê³ ë…í•¨":
          return `[ê³ ë…í•¨] ::${name};;${pickJosa(name,"ì€ëŠ”")} í˜¼ì ì¡°ìš©í•œ êµ¬ì„ì„ ì°¾ì•„ ì±…ì„ ì½ìœ¼ë©° ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
        case "ì¹´ë¦¬ìŠ¤ë§ˆ":
          return `[ì¹´ë¦¬ìŠ¤ë§ˆ] ::${name};;${pickJosa(name,"ì€ëŠ”")} ë³„ë‹¤ë¥¸ ë§ ì—†ì´ë„ ì£¼ë³€ ì‚¬ëŒë“¤ì˜ ì‹œì„ ì„ ì‚¬ë¡œì¡ì•˜ìŠµë‹ˆë‹¤.`;
        case "ëˆˆì¹˜ë¹ ë¦„":
          return `[ëˆˆì¹˜ë¹ ë¦„] ::${name};;${pickJosa(name,"ì€ëŠ”")} ë¶„ìœ„ê¸°ê°€ ë¯¸ë¬˜í•´ì§€ì ì¬ë¹¨ë¦¬ í™”ì œë¥¼ ëŒë ¸ìŠµë‹ˆë‹¤.`;
        case "ì˜ì¡´ì ":
          return `[ì˜ì¡´ì ] ::${name};;${pickJosa(name,"ì€ëŠ”")} ìµìˆ™í•œ ì¹œêµ¬ë¥¼ ì°¾ì•„ë‹¤ë‹ˆë©° ê³ì— ìˆìœ¼ë ¤ í–ˆìŠµë‹ˆë‹¤.`;
        case "í˜ˆí†µì¤‘ì‹œ":
          return `[í˜ˆí†µì¤‘ì‹œ] ::${name};;${pickJosa(name,"ì€ëŠ”")} ëª…ë¬¸ ê°€ë¬¸ ì´ì•¼ê¸°ë¥¼ êº¼ë‚´ë©° ì€ê·¼í•œ ìë¶€ì‹¬ì„ ë“œëŸ¬ëƒˆìŠµë‹ˆë‹¤.`;
        case "í‰ë“±ì£¼ì˜":
          return `[í‰ë“±ì£¼ì˜] ::${name};;${pickJosa(name,"ì€ëŠ”")} í˜ˆí†µê³¼ ìƒê´€ì—†ì´ ëª¨ë‘ê°€ ë™ë“±í•´ì•¼ í•œë‹¤ëŠ” ìƒê°ì„ êµ³ê²Œ ì§€ì¼°ìŠµë‹ˆë‹¤.`;
        case "ê¶Œìœ„ì¡´ì¤‘":
          return `[ê¶Œìœ„ì¡´ì¤‘] ::${name};;${pickJosa(name,"ì€ëŠ”")} êµìˆ˜ì™€ ì„ ë°°ë“¤ì˜ ì§€ì‹œì— ìµœëŒ€í•œ ë”°ë¥´ë ¤ ë…¸ë ¥í–ˆìŠµë‹ˆë‹¤.`;
        case "ë°˜ê¶Œìœ„":
          return `[ë°˜ê¶Œìœ„] ::${name};;${pickJosa(name,"ì€ëŠ”")} í•™êµ ê·œì¹™ê³¼ ì „í†µì— ëŒ€í•´ ì‘ì€ ë¶ˆí‰ì„ í˜ë¦¬ê³¤ í–ˆìŠµë‹ˆë‹¤.`;
        case "ì´ìƒì£¼ì˜":
          return `[ì´ìƒì£¼ì˜] ::${name};;${pickJosa(name,"ì€ëŠ”")} ë” ë‚˜ì€ ë§ˆë²• ì„¸ê³„ë¥¼ ìƒìƒí•˜ë©° ê¿ˆê°™ì€ ê³„íšì„ ì„¸ì› ìŠµë‹ˆë‹¤.`;
        case "í˜„ì‹¤ì£¼ì˜":
          return `[í˜„ì‹¤ì£¼ì˜] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì‹œí—˜ ì ìˆ˜ì™€ ì§„ë¡œë¶€í„° ë¨¼ì € ê³„ì‚°í•´ ë³´ì•˜ìŠµë‹ˆë‹¤.`;
        case "ì•¼ì‹¬ê°€":
          return `[ì•¼ì‹¬ê°€] ::${name};;${pickJosa(name,"ì€ëŠ”")} ìƒìœ„ê¶Œ ì„±ì ê³¼ ì•ìœ¼ë¡œì˜ ì»¤ë¦¬ì–´ë¥¼ ë– ì˜¬ë¦¬ë©° ë§ˆìŒì„ ë‹¤ì¡ì•˜ìŠµë‹ˆë‹¤.`;
        case "ëª¨í—˜ê°€":
          return `[ëª¨í—˜ê°€] ::${name};;${pickJosa(name,"ì€ëŠ”")} í‰ì†Œ ì˜ ê°€ì§€ ì•ŠëŠ” ë³µë„ì™€ ê³„ë‹¨ì„ ê¸°ì›ƒê±°ë¦¬ë©° ëª¨í—˜ì„ ê¿ˆê¾¸ì—ˆìŠµë‹ˆë‹¤.`;
        case "ê¸°íšŒì£¼ì˜ì":
          return `[ê¸°íšŒì£¼ì˜ì] ::${name};;${pickJosa(name,"ì€ëŠ”")} êµìˆ˜ì˜ ëˆˆì¹˜ë¥¼ ì‚´í”¼ë©° ì¹­ì°¬ì„ ë“¤ì„ ìˆ˜ ìˆëŠ” ë§ì„ ê³¨ë¼ í–ˆìŠµë‹ˆë‹¤.`;
        case "ì§‘ì°©í˜•":
          return `[ì§‘ì°©í˜•] ::${name};;${pickJosa(name,"ì€ëŠ”")} í•œ ê°€ì§€ ìƒê°ì— ì‚¬ë¡œì¡í˜€ ë‹¤ë¥¸ ì¼ì—ëŠ” ì¢€ì²˜ëŸ¼ ì§‘ì¤‘í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.`;
        case "ì™„ë²½ì£¼ì˜":
          return `[ì™„ë²½ì£¼ì˜] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì´ë¯¸ ëë‚¸ ë…¸íŠ¸ë¥¼ ë‹¤ì‹œ ê³ ì³ ì“°ë©° ì‘ì€ ì‹¤ìˆ˜ê¹Œì§€ ì¡ì•„ëƒˆìŠµë‹ˆë‹¤.`;
        case "ì¶©ë™ì ":
          return `[ì¶©ë™ì ] ::${name};;${pickJosa(name,"ì€ëŠ”")} ìƒê°ë³´ë‹¤ ë¨¼ì € ëª¸ì´ ì›€ì§ì—¬ ë²„ë ¤, ë’¤ëŠ¦ê²Œ ìƒí™©ì„ ìˆ˜ìŠµí•´ì•¼ í–ˆìŠµë‹ˆë‹¤.`;
        case "ì˜ì‹¬ë§ìŒ":
          return `[ì˜ì‹¬ë§ìŒ] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì£¼ë³€ì—ì„œ ë“¤ë ¤ì˜¤ëŠ” ë§ë“¤ì„ ê³§ì´ê³§ëŒ€ë¡œ ë¯¿ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.`;
        case "ë¶„ë…¸ì¡°ì ˆê³¤ë€":
          return `[ë¶„ë…¸ì¡°ì ˆê³¤ë€] ::${name};;${pickJosa(name,"ì€ëŠ”")} í™”ë¥¼ ì°¸ì§€ ëª»í•˜ê³  ì¹œêµ¬ì™€ ì–¸ìŸì„ ë²Œì˜€ìŠµë‹ˆë‹¤.`;
        case "í—ˆë¬´ì£¼ì˜":
          return `[í—ˆë¬´ì£¼ì˜] ::${name};;${pickJosa(name,"ì€ëŠ”")} ëª¨ë“  ê²ƒì´ ê´œíˆ ì˜ë¯¸ ì—†ì–´ ë³´ì´ëŠ” ìˆœê°„ì„ ê²ªì—ˆìŠµë‹ˆë‹¤.`;
        case "ì´ì¤‘ì„±":
          return `[ì´ì¤‘ì„±] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì‚¬ëŒë“¤ ì•ê³¼ ë’¤ì—ì„œ ì „í˜€ ë‹¤ë¥¸ íƒœë„ë¥¼ ë³´ì˜€ìŠµë‹ˆë‹¤.`;
        default:
          return `[${trait}] ::${name};;${pickJosa(name,"ì€ëŠ”")} ìì‹ ì˜ ì„±í–¥ì´ ë“œëŸ¬ë‚˜ëŠ” í–‰ë™ì„ ì—¬ëŸ¬ ë²ˆ ë³´ì˜€ìŠµë‹ˆë‹¤.`;
      }
    }

    function soloBloodSentence(name, blood, traits){
      const label = formatBloodLabel(blood);
      const tset = new Set(Array.isArray(traits) ? traits : []);
      const isBrave = tset.has("í‰ë“±ì£¼ì˜") || tset.has("ë°˜ê¶Œìœ„") || tset.has("ë‚™ì²œì ");
      const isHierarchy = tset.has("í˜ˆí†µì¤‘ì‹œ") || tset.has("ê¶Œìœ„ì¡´ì¤‘");

      switch(blood){
        case "ë¨¸ê¸€ íƒœìƒ":
          if (isBrave){
            return `[${label}] ::${name};;${pickJosa(name,"ì€ëŠ”")} ìˆœí˜ˆ í•™ìƒë“¤ì˜ ì†ì‚­ì„ì„ ëŒ€ìˆ˜ë¡­ì§€ ì•Šê²Œ ì—¬ê¸°ë©°, ìŠ¤ìŠ¤ë¡œì˜ ê°€ì¹˜ë¥¼ ë¯¿ê¸°ë¡œ í–ˆìŠµë‹ˆë‹¤.`;
          } else if (isHierarchy){
            return `[${label}] ::${name};;${pickJosa(name,"ì€ëŠ”")} ìˆœí˜ˆ í•™ìƒë“¤ì˜ ì†ì‚­ì„ì— ì‰½ê²Œ ìœ„ì¶•ë˜ê³¤ í–ˆìŠµë‹ˆë‹¤.`;
          } else {
            return `[${label}] ::${name};;${pickJosa(name,"ì€ëŠ”")} ìˆœí˜ˆ í•™ìƒë“¤ì˜ ì†ì‚­ì„ì— ì‚´ì§ ë§ˆìŒì´ ìƒí–ˆìŠµë‹ˆë‹¤.`;
          }
        case "ë¶ˆëª…":
          return `[${label}] ::${name};;${pickJosa(name,"ì€ëŠ”")} í˜ˆí†µì„ ê¶ê¸ˆí•´í•˜ëŠ” ì‹œì„ ì„ ëŠë¼ê³  ì¡°ê¸ˆ ë¶ˆí¸í•´í–ˆìŠµë‹ˆë‹¤.`;
        case "í˜¼í˜ˆ":
          return `[${label}] ::${name};;${pickJosa(name,"ì€ëŠ”")} ë‘ ì„¸ê³„ ì‚¬ì´ì— ì„œ ìˆëŠ” ë“¯í•œ ê¸°ë¶„ì„ ì¢…ì¢… ë– ì˜¬ë ¸ìŠµë‹ˆë‹¤.`;
        case "ìˆœí˜ˆ":
          return `[${label}] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì˜¤ë˜ëœ ê°€ë¬¸ì˜ ì „í†µ ì´ì•¼ê¸°ë¥¼ ë“¤ìœ¼ë©° ë¬˜í•œ ì±…ì„ê°ì„ ëŠê¼ˆìŠµë‹ˆë‹¤.`;
        default:
          return `[${label}] ::${name};;${pickJosa(name,"ì€ëŠ”")} ìì‹ ì˜ ë°°ê²½ì„ ë– ì˜¬ë¦¬ë©° ì˜¤ëŠ˜ í•˜ë£¨ë¥¼ ëŒì•„ë³´ì•˜ìŠµë‹ˆë‹¤.`;
      }
    }

    function prettyTraitK(trait){
      if(!trait) return trait;
      return trait.replace(/ìŒ$/, "ì€").replace(/í•¨$/, "í•œ");
    }

    function pairTraitSentence(A, B, trait, c0, c1){
      // íŠ¹ìˆ˜ ì¼€ì´ìŠ¤: í˜ˆí†µì¤‘ì‹œ vs í‰ë“±ì£¼ì˜ -> ë°˜ë“œì‹œ ê°ˆë“±ìœ¼ë¡œ ì²˜ë¦¬
      const tA = (c0 && Array.isArray(c0.traits)) ? c0.traits : [];
      const tB = (c1 && Array.isArray(c1.traits)) ? c1.traits : [];
      const has = (arr, key)=> Array.isArray(arr) && arr.includes(key);
      if ((has(tA, 'í˜ˆí†µì¤‘ì‹œ') && has(tB, 'í‰ë“±ì£¼ì˜')) || (has(tB, 'í˜ˆí†µì¤‘ì‹œ') && has(tA, 'í‰ë“±ì£¼ì˜'))) {
        return `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ë§ˆë²•ì‚¬ ì‚¬íšŒì˜ 'í˜ˆí†µ' ë¬¸ì œë¥¼ ë‘ê³  ì˜ê²¬ì´ ê°•í•˜ê²Œ ëŒ€ë¦½í–ˆìŠµë‹ˆë‹¤.`;
      }

      switch(trait){
        case "ë‚™ì²œì ":
          return `ë‚™ì²œì ì¸ ::${A};;${pickJosa(A,"ì€ëŠ”")} ::${B};;${pickJosa(B,"ê³¼ì™€")} ì‚¬ì†Œí•œ ì¼ì—ë„ ì›ƒìŒì„ í„°ëœ¨ë¦¬ë©° ê¸ˆì„¸ ë¶„ìœ„ê¸°ë¥¼ ë„ì› ìŠµë‹ˆë‹¤.`;
        case "ì‹ ì¤‘í•¨":
          return `ì‹ ì¤‘í•œ ::${A};;${pickJosa(A,"ì€ëŠ”")} ::${B};;${pickJosa(B,"ê³¼ì™€")} ìƒì˜í•œ ëì— ì¡°ì‹¬ìŠ¤ëŸ½ê²Œ ê²°ì •ì„ ë‚´ë ¸ìŠµë‹ˆë‹¤.`;
        case "ì™„ë²½ì£¼ì˜":
          return `ì™„ë²½ì£¼ì˜ì ì¸ ::${A};;${pickJosa(A,"ì€ëŠ”")} ::${B};;${pickJosa(B,"ê³¼ì™€")} í•¨ê»˜ ìˆ™ì œë¥¼ í•˜ë©° ì‚¬ì†Œí•œ ë¶€ë¶„ê¹Œì§€ ë‹¤ì‹œ í™•ì¸í–ˆìŠµë‹ˆë‹¤.`;
        case "ë¶„ë…¸ì¡°ì ˆê³¤ë€":
          return `::${A};;${pickJosa(A,"ì€ëŠ”")} í™”ë¥¼ ì´ê¸°ì§€ ëª»í•˜ê³  ì‚¬ì†Œí•œ ì¼ë¡œ ::${B};;${pickJosa(B,"ê³¼ì™€")} ë‹¤íˆ¼ì„ ë²Œì˜€ìŠµë‹ˆë‹¤.`;
        case "ì‚¬êµì ":
          return `ì‚¬êµì ì¸ ::${A};;${pickJosa(A,"ì€ëŠ”")} ::${B};;${pickJosa(B,"ì„ë¥¼")} ë‹¤ë¥¸ ì¹œêµ¬ë“¤ì—ê²Œ ìì—°ìŠ¤ëŸ½ê²Œ ì†Œê°œí–ˆìŠµë‹ˆë‹¤.`;
        case "ê³ ë…í•¨":
          return `ê³ ë…í•œ í¸ì¸ ::${A};;${pickJosa(A,"ì€ëŠ”")} í•¨ê»˜ ìˆë˜ ::${B};;ì—ê²Œë„ ì„ ì„ ê¸‹ëŠ” ëª¨ìŠµì„ ë³´ì˜€ê³ , ë‘ ì‚¬ëŒ ì‚¬ì´ì—ëŠ” ì ì‹œ ì–´ìƒ‰í•œ ê³µê¸°ê°€ í˜ë €ìŠµë‹ˆë‹¤.`;
        default:
          return `${prettyTraitK(trait)} ì„±í–¥ì˜ ::${A};;${pickJosa(A,"ì€ëŠ”")} ::${B};;${pickJosa(B,"ê³¼ì™€")} í•¨ê»˜ ì‹œê°„ì„ ë³´ë‚´ë©° ìì‹ ì˜ ì„±í–¥ì„ ë“œëŸ¬ëƒˆìŠµë‹ˆë‹¤.`;
      }
    }

    function pairBloodSentence(A, B, ba, bb){
      const la = formatBloodLabel(ba);
      const lb = formatBloodLabel(bb);
      if (ba === "ë¨¸ê¸€ íƒœìƒ" && bb === "ìˆœí˜ˆ"){
        return `ë¨¸ê¸€ íƒœìƒì¸ ::${A};;${pickJosa(A,"ì€ëŠ”")} ìˆœí˜ˆì¸ ::${B};;ì˜ ë§ì„ ë“¤ìœ¼ë©° ë³µì¡í•œ ê°ì •ê³¼ í•¨ê»˜, ì¡°ê¸ˆì€ ë” ê·¸ë¥¼ ì´í•´í•˜ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.`;
      }
      if (bb === "ë¨¸ê¸€ íƒœìƒ" && ba === "ìˆœí˜ˆ"){
        return `ìˆœí˜ˆì¸ ::${A};;${pickJosa(A,"ì€ëŠ”")} ë¨¸ê¸€ íƒœìƒì¸ ::${B};;ì—ê²Œ ë¬´ì‹¬ì½” ìƒì²˜ê°€ ë  ë§ì„ ê±´ë„¨ ë’¤, ìŠ¤ìŠ¤ë¡œë„ ë§ì˜ ë¬´ê²Œë¥¼ ê³±ì”¹ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.`;
      }
      if (ba === "ë¶ˆëª…" || bb === "ë¶ˆëª…"){
        return `í˜ˆí†µì´ ë¶ˆëª…í™•í•œ ::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ì„œë¡œì˜ ì‚¬ì •ì„ ì¡°ì‹¬ìŠ¤ë ˆ ë¬¼ì–´ë³´ë©° ê±°ë¦¬ë¥¼ ì¢í˜”ìŠµë‹ˆë‹¤.`;
      }
      return `ì„œë¡œ ë‹¤ë¥¸ ë°°ê²½ì˜ ::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ì ì‹œ ì–´ìƒ‰í•´í–ˆë‹¤ê°€ ì´ë‚´ ì†”ì§í•œ ì´ì•¼ê¸°ë¥¼ ë‚˜ëˆ„ì—ˆìŠµë‹ˆë‹¤.`;
    }


    // ==== O.W.L ê´€ë ¨ ìƒìˆ˜ ë° í•¨ìˆ˜ ====
    const OWL_SUBJECTS = [
      { id: "transfiguration", label: "ë³€ì‹ ìˆ " },
      { id: "potions",         label: "ë§ˆë²•ì•½" },
      { id: "charms",          label: "ì£¼ìˆ " },
      { id: "herbology",       label: "ì•½ì´ˆí•™" },
      { id: "history",         label: "ë§ˆë²• ì—­ì‚¬" },
      { id: "astronomy",       label: "ì²œë¬¸í•™" },
      { id: "dada",            label: "ì–´ë‘ ì˜ ë§ˆë²• ë°©ì–´ìˆ " }
    ];

    function owlGradeFromScore(score){
      // Softer curve: PëŠ” ë“œë¬¼ê²Œë§Œ ëœ¨ë„ë¡ ë²”ìœ„ë¥¼ ì¢í˜”ìŠµë‹ˆë‹¤.
      if (score >= 88) return "O";
      if (score >= 78) return "E";
      if (score >= 68) return "A";
      if (score >= 52) return "P";
      if (score >= 40) return "D";
      return "T";
    }

    function owlMbtiBonus(charObj, subjectId){
      const mbti = String(charObj.mbti || "").toUpperCase();
      if (!mbti) return 0;
      let b = 0;
      const has = ch => mbti.includes(ch);
      // N/S: ì´ë¡  vs ì‹¤ìš©
      if (subjectId === "history" || subjectId === "astronomy"){
        if (has("N")) b += 3;
        else if (has("S")) b += 1;
      }
      if (subjectId === "potions" || subjectId === "transfiguration"){
        if (has("T")) b += 3;
      }
      if (subjectId === "charms" || subjectId === "dada"){
        if (has("E")) b += 2;
      }
      if (has("J")) b += 2;
      return b;
    }

    function owlTraitBonus(charObj, subjectId){
      const traits = Array.isArray(charObj.traits) ? charObj.traits : [];
      let b = 0;
      if (traits.includes("ì™„ë²½ì£¼ì˜")) b += 4;
      if (traits.includes("ì„±ì‹¤í•¨")) b += 3;
      if (traits.includes("í˜¸ê¸°ì‹¬") && (subjectId === "history" || subjectId === "astronomy")) b += 3;
      if (traits.includes("ìœ ë¦¬ ë©˜íƒˆ")) b -= 3;
      if (traits.includes("ì¶©ë™ì ")) b -= 2;
      return b;
    }

    function owlFeatBonus(charObj, subjectId){
      const feats = Array.isArray(charObj.feats) ? charObj.feats : [];
      let b = 0;
      if (feats.includes("ì²œì¬")) b += 8;
      if (feats.includes("ì±…ë²Œë ˆ")){
        if (subjectId === "history" || subjectId === "astronomy" || subjectId === "herbology" || subjectId === "transfiguration"){
          b += 5;
        } else {
          b += 2;
        }
      }
      if (feats.includes("ìš´ë™ê´‘") && (subjectId === "charms" || subjectId === "dada")){
        b += 2;
      }
      if (feats.includes("ë³‘ì•½")){
        b -= 3;
      }
      if (feats.includes("í–‰ìš´ì•„")){
        // ì¼ë¶€ ê³¼ëª©ì—ì„œë§Œ ê°•í•˜ê²Œ ìš´ì´ ì‘ìš©
        if (Math.random() < 0.3) b += 8;
      }
      return b;
    }

    function calculateOwlResultsForYear(year){
      if (!story || !characters.length) return;
      const yearKey = String(year);
      if (!story.owlExamByYear || typeof story.owlExamByYear !== "object") story.owlExamByYear = {};
      if (!story.owlResultsByYear || typeof story.owlResultsByYear !== "object") story.owlResultsByYear = {};
      if (!story.owlResultsShownByYear || typeof story.owlResultsShownByYear !== "object") story.owlResultsShownByYear = {};
      const examMods = story.owlExamByYear[yearKey] || {};
      if (!story.owlCurveByYear || typeof story.owlCurveByYear !== "object") story.owlCurveByYear = {};
      if (typeof story.owlCurveByYear[yearKey] !== "number"){
        const baseCurve = 6;
        const extra = Math.floor(Math.random() * 5); // 0~4 => ì´ +6~+10
        story.owlCurveByYear[yearKey] = baseCurve + extra;
      }
      const yearCurve = story.owlCurveByYear[yearKey];
      const resultsForYear = {};

      characters.forEach(c => {
        const charId = c.id;
        const grades = {};
        OWL_SUBJECTS.forEach(sub => {
          let score = 60;
          score += owlMbtiBonus(c, sub.id);
          score += owlTraitBonus(c, sub.id);
          score += owlFeatBonus(c, sub.id);
          const rand = (Math.random() * 30) - 15; // -15 ~ +15
          score += rand;
          if (typeof examMods[charId] === "number"){
            score += examMods[charId];
          }
          // í•´ë‹¹ ì—°ë„ì˜ ì „ì²´ ë‚œì´ë„ ì»¤ë¸Œ ì ìš© (+6 ~ +10)
          score += yearCurve;
          score = Math.max(0, Math.min(100, Math.round(score)));
          grades[sub.id] = owlGradeFromScore(score);
        });
        const name = c.name || "";
        const subjectValues = Object.values(grades);
        const highCount = subjectValues.filter(g => g === "O" || g === "E").length;
        const lowCount = subjectValues.filter(g => g === "D" || g === "T").length;
        const eligibleForNewt = highCount >= 5;
        let summary = "";
        if (highCount >= 4 && lowCount === 0){
          summary = `::${name};;${pickJosa(name,"ì€ëŠ”")} ëŒ€ë¶€ë¶„ ê³¼ëª©ì—ì„œ ë›°ì–´ë‚œ ì„±ì ì„ ê±°ë‘ë©°, 5í•™ë…„ì„ ìë‘ìŠ¤ëŸ½ê²Œ ë§ˆë¬´ë¦¬í–ˆìŠµë‹ˆë‹¤.`;
        } else if (highCount >= 2 && lowCount <= 1){
          summary = `::${name};;${pickJosa(name,"ì€ëŠ”")} ì¼ë¶€ ê³¼ëª©ì—ì„œ íŠ¹íˆ ì¢‹ì€ ì„±ì ì„ ë°›ì•„, ì „ë°˜ì ìœ¼ë¡œ ë§Œì¡±ìŠ¤ëŸ¬ìš´ ê²°ê³¼ë¥¼ ì–»ì—ˆìŠµë‹ˆë‹¤.`;
        } else if (lowCount >= 2){
          summary = `::${name};;${pickJosa(name,"ì€ëŠ”")} ëª‡ëª‡ ê³¼ëª©ì—ì„œ ì•„ì‰¬ìš´ ì„±ì ì„ ë°›ì•„, ë‹¤ìŒì„ ê¸°ì•½í•˜ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.`;
        } else {
          summary = `::${name};;${pickJosa(name,"ì€ëŠ”")} í¬ê²Œ ë‘ë“œëŸ¬ì§€ì§€ëŠ” ì•Šì§€ë§Œ, ë¬´ë‚œí•˜ê²Œ O.W.L ì‹œí—˜ì„ ë§ˆì³¤ìŠµë‹ˆë‹¤.`;
        }
        if (eligibleForNewt){
          summary += " ë˜í•œ, N.E.W.T ì‘ì‹œ ìê²©ì„ ì¶©ì¡±í–ˆìŠµë‹ˆë‹¤.";
        }
        resultsForYear[charId] = { charId, grades, summary, newtEligible: eligibleForNewt };
      });
      story.owlResultsByYear[yearKey] = resultsForYear;
      story.owlResultsShownByYear[yearKey] = false;
      saveAll();
    }

    function showOwlResultsForYear(year){
      if (!story || !characters.length) return;
      const yearKey = String(year);
      const byYear = story.owlResultsByYear && story.owlResultsByYear[yearKey];
      if (!byYear) return;

      // O.W.L ì„±ì  ì•ˆë‚´ + ìºë¦­í„° ì„ íƒì§€ ì¶œë ¥
      story.log = [];
      const block = {
        turn: 5000 + year,
        title: `O.W.L ì„±ì í‘œ (${year}í•™ë…„)`,
        meta: "O.W.L",
        lines: []
      };
      block.lines.push(`${year}í•™ë…„ ë™ì•ˆ ì¹˜ë¥¸ O.W.L ì„±ì ì´ ê³µê°œë˜ì—ˆìŠµë‹ˆë‹¤.`);
      block.lines.push("Q. ëˆ„êµ¬ì˜ O.W.L ì„±ì ì„ í™•ì¸í• ê¹Œ?");

      const btns = characters.map(c=>{
        const label = escapeHTML(c.name || "");
        return `<button class="logBtn" data-action="owl-pick-char" data-id="${c.id}">${label}</button>`;
      }).join(" ");

      block.lines.push(`@@HTML@@<div class="logActionRow">${btns || "<span class='muted'>í™•ì¸í•  í•™ìƒì´ ì—†ìŠµë‹ˆë‹¤.</span>"}</div>`);

      story.log.push(block);
      saveAll();
      renderLog();
      updateStoryHeader();
    }

    function makeOwlExamSentenceAndMod(charObj, name){
      const traits = Array.isArray(charObj.traits) ? charObj.traits : [];
      const feats = Array.isArray(charObj.feats) ? charObj.feats : [];
      let score = Math.random(); // 0~1
      if (traits.includes("ì™„ë²½ì£¼ì˜") || traits.includes("ì„±ì‹¤í•¨")) score += 0.15;
      if (feats.includes("ì±…ë²Œë ˆ") || feats.includes("ì²œì¬")) score += 0.2;
      if (feats.includes("í–‰ìš´ì•„")) score += 0.1;
      if (traits.includes("ìœ ë¦¬ ë©˜íƒˆ") || feats.includes("ë³‘ì•½")) score -= 0.15;
      if (score < 0) score = 0;
      if (score > 1) score = 1;

      let category = "ok";
      let mod = 0;
      if (score >= 0.8){
        category = "great";
        mod = 8;
      } else if (score >= 0.55){
        category = "ok";
        mod = 3;
      } else if (score >= 0.3){
        category = "bad";
        mod = -3;
      } else {
        category = "terrible";
        mod = -8;
      }

      sentence = "";
      if (category === "great"){
        if (feats.includes("í–‰ìš´ì•„")){
          sentence = `[O.W.L] [í–‰ìš´] ::${name};;${pickJosa(name,"ì€ëŠ”")} í‰ì†Œ ëŒ€ì¶© í›‘ì–´ë³¸ ë¶€ë¶„ì´ ê·¸ëŒ€ë¡œ ì¶œì œë˜ì–´, ë†€ë¼ìš¸ ì •ë„ë¡œ ìˆ ìˆ  ë‹µì•ˆì„ ì ì–´ ë‚´ë ¤ê°”ìŠµë‹ˆë‹¤.`;
        } else if (traits.includes("ì™„ë²½ì£¼ì˜")){
          sentence = `[O.W.L] ::${name};;${pickJosa(name,"ì€ëŠ”")} ë¯¸ë¦¬ ì¤€ë¹„í•´ ë‘” ë‹µì•ˆì„ í™•ì¸í•˜ë“¯ ì ì–´ ë‚´ë ¤ê°€ë©°, ê±°ì˜ ì‹¤ìˆ˜ ì—†ì´ ì‹œí—˜ì„ ë§ˆì³¤ìŠµë‹ˆë‹¤.`;
        } else {
          sentence = `[O.W.L] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì¤€ë¹„í•œ ë‚´ìš©ê³¼ ë¹„ìŠ·í•œ ë¬¸ì œê°€ ë‚˜ì™€, ì°¨ë¶„í•˜ê²Œ ë‹µì•ˆì„ ì±„ì›Œ ë‚˜ê°”ìŠµë‹ˆë‹¤.`;
        }
      } else if (category === "ok"){
        sentence = `[O.W.L] ::${name};;${pickJosa(name,"ì€ëŠ”")} í¬ê²Œ ë§‰íˆëŠ” ë¬¸ì œ ì—†ì´, ë¬´ë‚œí•˜ê²Œ ì‹œí—˜ì§€ë¥¼ ì±„ì›Œ ë‚˜ê°”ìŠµë‹ˆë‹¤.`;
      } else if (category === "bad"){
        if (traits.includes("ìœ ë¦¬ ë©˜íƒˆ")){
          sentence = `[O.W.L] ::${name};;${pickJosa(name,"ì€ëŠ”")} ëª‡ ë¬¸ì œì—ì„œ ë§‰íŒ ë’¤ë¡œ ë§ˆìŒì´ ë¶ˆì•ˆí•´ì ¸, ë’¤ìª½ ë¬¸ì œì— ì œëŒ€ë¡œ ì§‘ì¤‘í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.`;
        } else {
          sentence = `[O.W.L] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì¤€ë¹„í•˜ì§€ ëª»í•œ ìœ í˜•ì˜ ë¬¸ì œê°€ ë‚˜ì™€, ëª‡ëª‡ ì¹¸ì„ ë¹„ì›Œ ë‘˜ ìˆ˜ë°–ì— ì—†ì—ˆìŠµë‹ˆë‹¤.`;
        }
      } else {
        // terrible
        if (feats.includes("ë³‘ì•½")){
          sentence = `[O.W.L] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì»¨ë””ì…˜ì´ ì¢‹ì§€ ì•Šì•„, ì‹œí—˜ ë‚´ë‚´ ë¨¸ë¦¬ê°€ ë©í•œ ì±„ë¡œ ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
        } else {
          sentence = `[O.W.L] ::${name};;${pickJosa(name,"ì€ëŠ”")} ëê¹Œì§€ ë‹µì„ ì±„ìš°ì§€ ëª»í•œ ë¬¸ì œë“¤ì´ ëˆˆì— ë°Ÿí˜€, ì‹œí—˜ì¥ì„ ë‚˜ì„œë©° ê¹Šì€ í•œìˆ¨ì„ ë‚´ì‰¬ì—ˆìŠµë‹ˆë‹¤.`;
        }
      }

      return { sentence, mod };
    }

    function makeOwlPrepSentence(charObj, name){
      const traits = Array.isArray(charObj.traits) ? charObj.traits : [];
      const feats = Array.isArray(charObj.feats) ? charObj.feats : [];
      const mbti = String(charObj.mbti || "").toUpperCase();
      const pool = [];
      const pick = arr => arr[Math.floor(Math.random()*arr.length)];

      if (feats.includes("ì±…ë²Œë ˆ") || traits.includes("ì±…ë²Œë ˆ")){
        pool.push(`[O.W.L ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} ë„ì„œê´€ì—ì„œ ì§€ë‚œ ì‹œí—˜ ë¬¸ì œë“¤ì„ ì •ë¦¬í•˜ë©°, ë…¸íŠ¸ë¥¼ ë¹½ë¹½í•˜ê²Œ ì±„ì›Œ ë„£ì—ˆìŠµë‹ˆë‹¤.`);
      }
      if (feats.includes("ì²œì¬")){
        pool.push(`[O.W.L ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} êµê³¼ì„œë¥¼ í•œ ë²ˆ í›‘ì–´ë³¸ ë’¤, ìŠ¤ìŠ¤ë¡œ ì˜ˆìƒ ë¬¸ì œë¥¼ ë§Œë“¤ë©° ë¨¸ë¦¿ì†ìœ¼ë¡œ ë‹µì•ˆì„ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤.`);
      }
      if (traits.includes("ì™„ë²½ì£¼ì˜") || traits.includes("ì„±ì‹¤í•¨")){
        pool.push(`[O.W.L ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} ê³¼ëª©ë³„ë¡œ ì„¸ë¶€ ê³„íšì„ ì„¸ì›Œ, ì˜¤ëŠ˜ë„ ì •í•´ ë‘” ë¶„ëŸ‰ì„ ê¼¼ê¼¼í•˜ê²Œ ì±„ì›Œ ë‚˜ê°”ìŠµë‹ˆë‹¤.`);
      }
      if (feats.includes("ë³‘ì•½")){
        pool.push(`[O.W.L ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì²´ë ¥ì´ ê¸ˆì„¸ ë–¨ì–´ì§€ëŠ” ê²ƒì„ ê±±ì •í•˜ë©°, ë¬´ë¦¬í•˜ì§€ ì•ŠëŠ” ì„ ì—ì„œ ì¡°ê¸ˆì”© ê³µë¶€ë¥¼ ì´ì–´ ê°”ìŠµë‹ˆë‹¤.`);
      }
      if (feats.includes("í–‰ìš´ì•„")){
        pool.push(`[O.W.L ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} 'ì–´ì°¨í”¼ ì–´ë–»ê²Œë“  ë˜ê² ì§€'ë¼ë©° ê°€ë³ê²Œ êµê³¼ì„œë¥¼ ë„˜ê²¨ë³´ë‹¤ê°€, ìš°ì—°íˆ ì¤‘ìš”í•œ ë¶€ë¶„ì„ ì—¬ëŸ¬ ë²ˆ ì½ê²Œ ë˜ì—ˆìŠµë‹ˆë‹¤.`);
      }
      if (mbti.includes("E")){
        pool.push(`[O.W.L ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì¹œêµ¬ë“¤ê³¼ í•¨ê»˜ ëª¨ì—¬ ë¬¸ì œë¥¼ ë‚´ê³  ë§íˆëŠ” ì‹ìœ¼ë¡œ, ì‹œë„ëŸ½ì§€ë§Œ íš¨ìœ¨ì ì¸ ê³µë¶€ ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`);
      }
      if (mbti.includes("I")){
        pool.push(`[O.W.L ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì‚¬ëŒ ì—†ëŠ” ì¡°ìš©í•œ êµ¬ì„ì— ìë¦¬ë¥¼ ì¡ê³ , í˜¼ìë§Œì˜ ì†ë„ë¡œ ì°¨ë¶„íˆ ì •ë¦¬ ë…¸íŠ¸ë¥¼ ë§Œë“¤ì–´ ê°”ìŠµë‹ˆë‹¤.`);
      }

      if (!pool.length){
        pool.push(`[O.W.L ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì±…ì¥ì„ ë®ì—ˆë‹¤ í¼ì¹˜ê¸°ë¥¼ ë°˜ë³µí•˜ë©°, ë§ˆìŒ í•œêµ¬ì„ì— ìë¦¬ ì¡ì€ O.W.Lì„ ì˜ì‹í•˜ê³  ìˆì—ˆìŠµë‹ˆë‹¤.`);
      }
      return pick(pool);
    }


    // ==== O.W.L ê´€ë ¨ ìƒìˆ˜ ë° í•¨ìˆ˜ ë ====



    function isNewtEligible(charId){
      if (!story || !story.owlResultsByYear) return false;
      const byYear5 = story.owlResultsByYear["5"];
      if (!byYear5) return false;
      const r = byYear5[charId];
      if (!r) return false;
      if (typeof r.newtEligible === "boolean") return r.newtEligible;
      const grades = r.grades || {};
      const values = Object.values(grades);
      const highCount = values.filter(g => g === "O" || g === "E").length;
      return highCount >= 5;
    }

    function makeNewtPrepSentence(charObj, name){
      const traits = Array.isArray(charObj.traits) ? charObj.traits : [];
      const feats = Array.isArray(charObj.feats) ? charObj.feats : [];
      const mbti = String(charObj.mbti || "").toUpperCase();
      const pool = [];

      if (feats.includes("ì±…ë²Œë ˆ")){
        pool.push(`[N.E.W.T ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} O.W.L ë•Œ ë§Œë“¤ì–´ ë‘” ìš”ì•½ ë…¸íŠ¸ë¥¼ ë‹¤ì‹œ êº¼ë‚´, í•„ìš”í•œ ê³¼ëª©ë§Œ ì¶”ë ¤ ë” ê¹Šì´ íŒŒê³ ë“¤ì—ˆìŠµë‹ˆë‹¤.`);
      }
      if (feats.includes("ì²œì¬")){
        pool.push(`[N.E.W.T ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} ê³ ê¸‰ ë‚œì´ë„ì˜ ì—°ìŠµ ë¬¸ì œë¥¼ ìŠ¤ìŠ¤ë¡œ ë§Œë“¤ë©°, ì‹œí—˜ì—ì„œ ë‚˜ì˜¬ ë²•í•œ ì‘ìš© ìƒí™©ì„ ë¨¸ë¦¿ì†ìœ¼ë¡œ ì‹œë®¬ë ˆì´ì…˜í–ˆìŠµë‹ˆë‹¤.`);
      }
      if (traits.includes("ì™„ë²½ì£¼ì˜") || traits.includes("ì„±ì‹¤í•¨")){
        pool.push(`[N.E.W.T ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} ë‚¨ì€ ê¸°ê°„ì„ ì£¼ ë‹¨ìœ„ë¡œ ë‚˜ëˆ„ì–´ ê³„íší‘œë¥¼ ì„¸ìš°ê³ , ë¹ˆì¹¸ ì—†ì´ ë¹¼ê³¡í•˜ê²Œ ì±„ì›Œ ë‚˜ê°€ê³  ìˆìŠµë‹ˆë‹¤.`);
      }
      if (traits.includes("ìœ ë¦¬ ë©˜íƒˆ")){
        pool.push(`[N.E.W.T ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} "í˜¹ì‹œ ì´ë²ˆì— ë§ì¹˜ë©´ ì–´ë–¡í•˜ì§€" í•˜ëŠ” ë¶ˆì•ˆê°ì„ ëŠë¼ë©´ì„œë„, ì±…ì„ ë®ì§€ ì•Šê³  ì¡°ê¸ˆì”© ë‹¤ì‹œ í¼ì³ ë´…ë‹ˆë‹¤.`);
      }
      if (mbti.includes("E")){
        pool.push(`[N.E.W.T ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} ëª‡ ì•ˆ ë˜ëŠ” ë™ë£Œ ìˆ˜í—˜ìƒë“¤ê³¼ í•¨ê»˜ ìŠ¤í„°ë””ë¥¼ ê¾¸ë ¤, ë¬¸ì œë¥¼ ì„œë¡œ ë‚´ ì£¼ê³  í† ë¡ í•˜ë©° ì¤€ë¹„í•˜ê³  ìˆìŠµë‹ˆë‹¤.`);
      }
      if (mbti.includes("I")){
        pool.push(`[N.E.W.T ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì¡°ìš©í•œ ìë¦¬ì—ì„œ í˜¼ì ì—°ìŠµ ë¬¸ì œë¥¼ í’€ë©°, ë‹µì•ˆ ì‘ì„± ì‹œê°„ì„ ì¬ ë³´ë©° ì°¨ë¶„í•˜ê²Œ í˜ì´ìŠ¤ë¥¼ ë§ì¶° ê°€ê³  ìˆìŠµë‹ˆë‹¤.`);
      }

      if (!pool.length){
        pool.push(`[N.E.W.T ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} O.W.L ë•Œì˜ ê²½í—˜ì„ ë– ì˜¬ë¦¬ë©°, ì´ë²ˆì—ë„ ì–´ë–»ê²Œë“  í•´ë‚´ê² ë‹¤ê³  ë§ˆìŒì„ ë‹¤ì¡ì•˜ìŠµë‹ˆë‹¤.`);
      }
      return pick(pool);
    }

    
    function makeNewtExamSentence(charObj, name){
      const traits = Array.isArray(charObj.traits) ? charObj.traits : [];
      const feats = Array.isArray(charObj.feats) ? charObj.feats : [];
      const mbti = String(charObj.mbti || "").toUpperCase();
      const pool = [];

      // ì—´ì‹¬íˆ ì¤€ë¹„í•œ íƒ€ì…
      if (feats.includes("ì±…ë²Œë ˆ") || traits.includes("ì„±ì‹¤í•¨") || traits.includes("ì™„ë²½ì£¼ì˜")){
        pool.push(`[N.E.W.T] ::${name};;${pickJosa(name,"ì€ëŠ”")} ë§ˆì§€ë§‰ê¹Œì§€ ì •ë¦¬í•´ ë‘” ë…¸íŠ¸ë¥¼ ë– ì˜¬ë¦¬ë©°, ì¤€ë¹„í•œ ë§Œí¼ì€ í•´ëƒˆë‹¤ëŠ” ë§ˆìŒìœ¼ë¡œ ì‹œí—˜ì„ ë§ˆë¬´ë¦¬í–ˆìŠµë‹ˆë‹¤.`);
      }
      // ì²œì¬ / ì§ê´€í˜•
      if (feats.includes("ì²œì¬") || mbti.includes("N")){
        pool.push(`[N.E.W.T] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì˜ˆìƒí•˜ì§€ ëª»í•œ ë¬¸ì œê°€ ë‚˜ì™€ë„, ê·¸ë™ì•ˆ ìŒ“ì•„ ì˜¨ ê°ê°ì„ ë¯¿ê³  ì°¨ë¶„íˆ ë‹µì•ˆì„ ì¨ ë‚´ë ¤ê°”ìŠµë‹ˆë‹¤.`);
      }
      // ìœ ë¦¬ ë©˜íƒˆ / ë¶ˆì•ˆ ë§ì€ íƒ€ì…
      if (traits.includes("ìœ ë¦¬ ë©˜íƒˆ")){
        pool.push(`[N.E.W.T] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì‹œí—˜ ë‚´ë‚´ ê¸´ì¥ì„ ëŠ¦ì¶”ì§€ ëª»í–ˆì§€ë§Œ, ëê¹Œì§€ ìë¦¬ë¥¼ ì§€í‚¤ë©° ìì‹ ì´ ì“¸ ìˆ˜ ìˆëŠ” ë‹µì•ˆì„ ëª¨ë‘ ì±„ì›Œ ë„£ì—ˆìŠµë‹ˆë‹¤.`);
      }
      // ì™¸í–¥í˜•: ì‚¬ëŒ/ë¶„ìœ„ê¸° ì˜ì‹
      if (mbti.startsWith("E")){
        pool.push(`[N.E.W.T] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì‹œí—˜ì¥ì„ ë‚˜ì„œë©° í•¨ê»˜ ì‘ì‹œí•œ ì¹œêµ¬ë“¤ì˜ í‘œì •ì„ ì‚´í”¼ê³ , ì„œë¡œì˜ ê³ ìƒì„ ì§§ê²Œ ì¹­ì°¬í–ˆìŠµë‹ˆë‹¤.`);
      }
      // ë‚´í–¥í˜•: í˜¼ì ê³±ì”¹ëŠ” íƒ€ì…
      if (mbti.startsWith("I")){
        pool.push(`[N.E.W.T] ::${name};;${pickJosa(name,"ì€ëŠ”")} í˜¼ì ì¡°ìš©í•œ ë³µë„ë¥¼ ê±¸ìœ¼ë©°, ë°©ê¸ˆ ì ì–´ ë‚´ë ¤ê°„ ë‹µì•ˆê³¼ ì‹¤ìˆ˜í–ˆì„ì§€ë„ ëª¨ë¥¼ ë¶€ë¶„ë“¤ì„ ë¨¸ë¦¿ì†ì—ì„œ ë‹¤ì‹œ í•œ ë²ˆ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤.`);
      }
      // Jí˜•: ê³„íší˜•
      if (mbti.includes("J")){
        pool.push(`[N.E.W.T] ::${name};;${pickJosa(name,"ì€ëŠ”")} ë¯¸ë¦¬ ì„¸ì›Œ ë‘” ì‹œê°„ ê³„íšëŒ€ë¡œ ì‹œí—˜ì„ ë§ˆì³¤ë‹¤ëŠ” ì‚¬ì‹¤ì—, ê²°ê³¼ì™€ëŠ” ë³„ê°œë¡œ ì‘ì€ ì•ˆë„ê°ì„ ëŠê¼ˆìŠµë‹ˆë‹¤.`);
      }
      // Pí˜•: ì¦‰í¥í˜•
      if (mbti.includes("P")){
        pool.push(`[N.E.W.T] ::${name};;${pickJosa(name,"ì€ëŠ”")} ë§‰íŒê¹Œì§€ ë‹µì•ˆì„ ê³ ì¹˜ë‹¤ê°€, ê²°êµ­ "ì´ ì •ë„ë©´ ëì§€"ë¼ëŠ” ë§ˆìŒìœ¼ë¡œ íœì„ ë‚´ë ¤ë†“ì•˜ìŠµë‹ˆë‹¤.`);
      }

      if (!pool.length){
        pool.push(`[N.E.W.T] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì˜¤ëœ ì¤€ë¹„ ëì— ìµœì¢… ì‹œí—˜ì„ ë¬´ì‚¬íˆ ì¹˜ë €ìŠµë‹ˆë‹¤. ê²°ê³¼ê°€ ì–´ë–»ë“ , ì§€ê¸ˆê¹Œì§€ì˜ ë…¸ë ¥ì´ ë– ì˜¬ë¼ ë³µì¡í•œ ë§ˆìŒìœ¼ë¡œ ì‹œí—˜ì¥ì„ ë‚˜ì„°ìŠµë‹ˆë‹¤.`);
      }
      return pick(pool);
    }

function makeGraduationPrepSentence(charObj, name){
      const mbti = String(charObj.mbti || "").toUpperCase();
      const traits = Array.isArray(charObj.traits) ? charObj.traits : [];
      const pool = [];

      if (mbti.startsWith("E")){
        pool.push(`[ì¡¸ì—… ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì¹œêµ¬ë“¤ê³¼ ë§ˆì§€ë§‰ í•™ê¸° ì¼ì •í‘œë¥¼ ë‚˜ëˆ  ë³´ë©°, ì¡¸ì—… ì „ê¹Œì§€ ê¼­ í•¨ê»˜ í•˜ê³  ì‹¶ì€ ë²„í‚·ë¦¬ìŠ¤íŠ¸ë¥¼ ì •ë¦¬í–ˆìŠµë‹ˆë‹¤.`);
      }
      if (mbti.startsWith("I")){
        pool.push(`[ì¡¸ì—… ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì¡°ìš©í•œ ê¸°ìˆ™ì‚¬ ë°©ì—ì„œ, ì§€ë‚œ 7ë…„ ë™ì•ˆì˜ ì¶”ì–µì„ ë– ì˜¬ë¦¬ë©° ì¡¸ì—… í›„ ê³„íšì„ ë…¸íŠ¸ì— ì°¨ë¶„íˆ ì ì–´ ë‚´ë ¤ê°”ìŠµë‹ˆë‹¤.`);
      }
      if (mbti.includes("J")){
        pool.push(`[ì¡¸ì—… ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì§„ë¡œ ìƒë‹´ ì¼ì •ê³¼ ì…í•™ ì§€ì› ë§ˆê° ë‚ ì§œë¥¼ í‘œë¡œ ì •ë¦¬í•´, ë†“ì¹˜ì§€ ì•Šë„ë¡ ê¼¼ê¼¼íˆ ì²´í¬í–ˆìŠµë‹ˆë‹¤.`);
      }
      if (mbti.includes("P")){
        pool.push(`[ì¡¸ì—… ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì•„ì§ ì‹œê°„ì´ ìˆì„ ê±°ë¼ë©° ëŠê¸‹í•´ í•˜ë©´ì„œë„, ë§‰ìƒ ì¡¸ì—… ì„œë¥˜ì™€ ê°ì¢… ì œì¶œ ë¬¸ì„œë¥¼ í™•ì¸í•˜ê³ ëŠ” ìŠ¬ì© í•œìˆ¨ì„ ë‚´ì‰¬ì—ˆìŠµë‹ˆë‹¤.`);
      }
      if (traits.includes("ì´ìƒì£¼ì˜")){
        pool.push(`[ì¡¸ì—… ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} ë§ˆë²•ì‚¬ë¡œì„œ ì–´ë–¤ ì„¸ìƒì„ ë§Œë“¤ê³  ì‹¶ì€ì§€ ê³ ë¯¼í•˜ë©°, ì¡¸ì—… í›„ ìì‹ ì´ ì„œ ìˆì„ ìë¦¬ë¥¼ ìƒìƒí–ˆìŠµë‹ˆë‹¤.`);
      }
      if (traits.includes("í˜„ì‹¤ì£¼ì˜")){
        pool.push(`[ì¡¸ì—… ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì·¨ì—…ê³¼ ìƒí™œë¹„, ì§„ë¡œ ì „ë§ ê°™ì€ í˜„ì‹¤ì ì¸ ì¡°ê±´ë“¤ì„ ë¹„êµí•´ ë³´ë©°, ì¡¸ì—… ì´í›„ì˜ ê³„íšì„ ì¡°ì •í–ˆìŠµë‹ˆë‹¤.`);
      }

      if (!pool.length){
        pool.push(`[ì¡¸ì—… ì¤€ë¹„] ::${name};;${pickJosa(name,"ì€ëŠ”")} ì¡¸ì—…ì´ ê°€ê¹Œì›Œì¡Œë‹¤ëŠ” ì‚¬ì‹¤ì„ ì‹¤ê°í•˜ë©°, ìŠ¬ìŠ¬ ì§ì„ ì •ë¦¬í•˜ê³  ë¬¸ì„œë“¤ì„ ì±™ê¸°ê¸° ì‹œì‘í–ˆìŠµë‹ˆë‹¤.`);
      }

      return pick(pool);
    }

function generateSchoolTurn(){
      if (!characters.length){
        showToast("ìºë¦­í„°ë¥¼ ë¨¼ì € ë§Œë“¤ì–´ì¤˜!");
        return;
      }
      const maxPerSeason = 2;
      if (story.seasonTurn >= maxPerSeason){
        showToast("ì´ ê³„ì ˆì€ ì´ë¯¸ ì¶©ë¶„íˆ ì§„í–‰ë˜ì—ˆìŠµë‹ˆë‹¤.");
        return;
      }

      const ids = characters.map(c=>c.id);
      const groups = makeGroups(ids);

      // í•¨ê»˜ ë“±ì¥í•œ ìºë¦­í„°ë“¤ì€ ìµœì†Œí•œ 'ì•„ëŠ” ì‚¬ì´'ë¡œ ìœ ì§€
      groups.forEach(g => ensureGroupAcquaintances(g));

      const key = currentSeasonKey();
      const lines = [];
      let owlPrepUsedThisTurn = false;

      const isOwlExamDay = (story.currentYear === 5 && key === "summer" && story.seasonTurn === maxPerSeason - 1);
      const isOwlPrepSeason = (story.currentYear === 5 && (key === "spring" || key === "summer") && !isOwlExamDay);

      const isNewtExamDay = (story.currentYear === 7 && key === "summer" && story.seasonTurn === maxPerSeason - 1);
      // N.E.W.T ì¤€ë¹„ ì‹œì¦Œ: 7í•™ë…„ ê°€ì„/ê²¨ìš¸ + ë´„/ì—¬ë¦„(ì‹œí—˜ì¼ ì œì™¸)
      const isNewtPrepSeason = (story.currentYear === 7 && (
        key === "autumn" ||
        key === "winter" ||
        key === "spring" ||
        (key === "summer" && !isNewtExamDay)
      ));
      // ì¡¸ì—… ì¤€ë¹„ ì‹œì¦Œ: 7í•™ë…„ ë´„/ì—¬ë¦„(ì‹œí—˜ì¼ ì œì™¸)
      const isGraduationPrepSeason = (story.currentYear === 7 && (
        key === "spring" ||
        (key === "summer" && !isNewtExamDay)
      ));

      if (isOwlExamDay){
        const year = story.currentYear || 5;
        if (!story.owlExamByYear || typeof story.owlExamByYear !== "object") story.owlExamByYear = {};
        const yearKey = String(year);
        if (!story.owlExamByYear[yearKey] || typeof story.owlExamByYear[yearKey] !== "object"){
          story.owlExamByYear[yearKey] = {};
        }
        const examMods = story.owlExamByYear[yearKey];

        ids.forEach(id=>{
          const charObj = characters.find(c=>c.id===id);
          if (!charObj) return;
          const A = nameOf(id);
          const r = makeOwlExamSentenceAndMod(charObj, A);
          lines.push(r.sentence);
          const prev = typeof examMods[id] === "number" ? examMods[id] : 0;
          examMods[id] = prev + r.mod;
        });
      } else if (isNewtExamDay){
        ids.forEach(id=>{
          const charObj = characters.find(c=>c.id===id);
          if (!charObj) return;
          const A = nameOf(id);

          if (isNewtEligible(id)){
            const examSentence = makeNewtExamSentence(charObj, A);
            lines.push(examSentence);
          } else {
            const soloGen = (SEASON_SOLO_GENERAL[key] || []);
            let sentence = "";
            if (soloGen.length){
              const f = pick(soloGen);
              sentence = (typeof f === "function") ? f(A) : f;
            }
            if (!sentence) sentence = `${A}ì˜ í•˜ë£¨ëŠ” í‰ì†Œì²˜ëŸ¼ í˜ëŸ¬ê°”ìŠµë‹ˆë‹¤.`;
            lines.push(sentence);
          }
        });
      } else {

      groups.forEach(g=>{
        if (!g.length) return;

        // 5í•™ë…„ ë´„/ì—¬ë¦„ O.W.L ëŒ€ë¹„ ì‹œì¦Œ:
        // - ê¸°ë³¸ì ìœ¼ë¡œëŠ” ì¼ë°˜/2ì¸ ë¡œê·¸ë¥¼ ì‚¬ìš©í•˜ë˜
        // - ì¼ì • í™•ë¥ ë¡œë§Œ [O.W.L ì¤€ë¹„] ì „ìš© ë¡œê·¸ë¥¼ ì¶œë ¥í•œë‹¤.
        if (isOwlPrepSeason && Math.random() < 0.55){
          g.forEach(id=>{
            const c0 = characters.find(c=>c.id===id);
            if (!c0) return;
            const A = nameOf(id);
            const prepSentence = makeOwlPrepSentence(c0, A);
            lines.push(prepSentence);
          });
          owlPrepUsedThisTurn = true;
          return;
        }

        if (g.length === 1){
          const id = g[0];
          const A = nameOf(id);

          const soloGen = (SEASON_SOLO_GENERAL[key] || []);
          let sentence = "";

// ì„±ê²© í‚¤ì›Œë“œ / í˜ˆí†µ íƒœê·¸ ìš°ì„  ì‹œë„
const c0 = characters.find(c=>c.id===id);
const traits = (c0 && Array.isArray(c0.traits)) ? c0.traits : [];
const blood = c0 && c0.blood ? c0.blood : "";

// 7í•™ë…„ N.E.W.T / ì¡¸ì—… ì¤€ë¹„ ì „ìš© ë¡œê·¸
// - ê°€ì„/ê²¨ìš¸ì—ëŠ” ì£¼ë¡œ N.E.W.T ì¤€ë¹„ ë¡œê·¸
// - ë´„/ì—¬ë¦„ì—ëŠ” [N.E.W.T ì¤€ë¹„]ì™€ [ì¡¸ì—… ì¤€ë¹„]ê°€ ë¹„ìŠ·í•œ ë¹ˆë„ë¡œ ì„ì´ë„ë¡ ì²˜ë¦¬

if (!sentence && (isNewtPrepSeason || isGraduationPrepSeason)){
  const canNewt = isNewtPrepSeason && isNewtEligible(id);
  const canGrad = isGraduationPrepSeason;
  const prepTypes = [];
  if (canNewt) prepTypes.push("newt");
  if (canGrad) prepTypes.push("grad");

  if (prepTypes.length){
    // ê¸°ë³¸ ì¤€ë¹„ ë¡œê·¸ ë“±ì¥ í™•ë¥ 
    let prepProb = 0.6;
    let newtBias = 0.5;

    // ê° ìºë¦­í„°ë§ˆë‹¤ ìµœì†Œ í•œ ë²ˆì€ [ì¡¸ì—… ì¤€ë¹„] ë¡œê·¸ë¥¼ ë³´ì¥í•˜ê¸° ìœ„í•œ í”Œë˜ê·¸
    // - 7í•™ë…„ ì¡¸ì—… ì¤€ë¹„ ì‹œì¦Œì—, ì•„ì§ í•œ ë²ˆë„ ì¡¸ì—… ì¤€ë¹„ ë¡œê·¸ë¥¼ ë³¸ ì ì´ ì—†ëŠ” ìºë¦­í„°ë¼ë©´
    //   ì²« ì¤€ë¹„ ë¡œê·¸ë¥¼ ë¬´ì¡°ê±´ ì¡¸ì—… ì¤€ë¹„ë¡œ ê³ ì •í•œë‹¤.
    if (!story.graduationPrepSeenByChar || typeof story.graduationPrepSeenByChar !== "object"){
      story.graduationPrepSeenByChar = {};
    }
    const gradSeenMap = story.graduationPrepSeenByChar;
    const gradKey = String(id);

    // 7í•™ë…„ ë´„/ì—¬ë¦„(ì‹œí—˜ì¼ ì œì™¸)ì—ëŠ” ì¤€ë¹„ ë¡œê·¸ë¥¼ ì¢€ ë” ìì£¼ ì‚¬ìš©
    // - ë´„: ì¤€ë¹„ ë¡œê·¸ê°€ ìì£¼ ë‚˜ì˜¤ì§€ë§Œ, ë‹¤ë¥¸ ì¼ìƒ ë¡œê·¸ë„ ì•½ê°„ ì„ì„
    // - ì—¬ë¦„ 1/2Â·2/2: ì‹œí—˜ì¼ì´ ì•„ë‹Œ ë‚ ì—ëŠ” ê±°ì˜ í•­ìƒ N.E.W.T / ì¡¸ì—… ì¤€ë¹„ ë¡œê·¸ê°€ ë‚˜ì˜¤ë„ë¡ í™•ë¥  ê°•í™”
    if (story.currentYear === 7){
      if (key === "summer" && !isNewtExamDay){
        prepProb = 1.0;
        newtBias = 0.6;
      } else if (key === "spring"){
        prepProb = 0.8;
        newtBias = 0.6;
      }
    }

    // ì´ í„´ì— 'ì¤€ë¹„' ê³„ì—´ ë¡œê·¸ë¥¼ ì“¸ì§€ ìì²´ë¥¼ ë¨¼ì € ê²°ì •
    if (Math.random() < prepProb){
      let chosen;

      // ì¡¸ì—… ì¤€ë¹„ ì‹œì¦Œì´ê³  ì•„ì§ ì´ ìºë¦­í„°ê°€ í•œ ë²ˆë„ ì¡¸ì—… ì¤€ë¹„ ë¡œê·¸ë¥¼ ë³¸ ì ì´ ì—†ë‹¤ë©´,
      // ì²« ì¤€ë¹„ ë¡œê·¸ëŠ” ë¬´ì¡°ê±´ [ì¡¸ì—… ì¤€ë¹„]ë¡œ ê³ ì •í•œë‹¤.
      if (canGrad && !gradSeenMap[gradKey]){
        chosen = "grad";
      } else if (prepTypes.length === 1){
        chosen = prepTypes[0];
      } else {
        // ë‘ ì¢…ë¥˜ ëª¨ë‘ ê°€ëŠ¥í•  ë•ŒëŠ” biasë¥¼ ë°˜ì˜í•´ì„œ ì„ íƒ
        const r = Math.random();
        if (r < newtBias){
          chosen = "newt";
        } else {
          chosen = "grad";
        }
      }

      if (chosen === "newt"){
        sentence = makeNewtPrepSentence(c0, A);
      } else {
        sentence = makeGraduationPrepSentence(c0, A);
        gradSeenMap[gradKey] = true;
      }
    }
  }
}

// íŠ¹ì„± / ì„±ê²© / í˜ˆí†µ / MBTI 1ì¸ ë¡œê·¸ë¥¼ ê· ë“± í™•ë¥ ë¡œ ì„ íƒ (5í•™ë…„ O.W.L, 7í•™ë…„ N.E.W.T/ì¡¸ì—… ì¤€ë¹„ëŠ” ìœ„ì—ì„œ ì²˜ë¦¬)
  if (!sentence){
    const featsArr = (c0 && Array.isArray(c0.feats)) ? c0.feats : [];
    const feats = featsArr;
    const hasF = (f)=> feats.includes(f);
    const hasT = (t)=> traits.includes(t);

    const flavorPool = [];
    if (featsArr.length) flavorPool.push("feat");
    if (traits.length) flavorPool.push("trait");
    if (blood) flavorPool.push("blood");
    // MBTIëŠ” í•­ìƒ ì‹œë„ ê°€ëŠ¥í•˜ë‹¤ê³  ë³´ê³  ë„£ì–´ ë‘”ë‹¤.
    flavorPool.push("mbti");

    if (flavorPool.length){
      const pickIdx = Math.floor(Math.random()*flavorPool.length);
      const flavor = flavorPool[pickIdx];

      if (flavor === "feat"){
        if (hasF("ê°€ë¬¸ì˜ í›„ê³„ì") && hasT("ê¶Œìœ„ì¡´ì¤‘")){
          sentence = `[ê°€ë¬¸ì˜ í›„ê³„ì] ::${A};;${pickJosa(A,"ì€ëŠ”")} ê°€ë¬¸ì´ ê¸°ëŒ€í•˜ëŠ” 'ëª¨ë²” í›„ê³„ì'ë‹µê²Œ ìˆ˜ì—… íƒœë„ í•˜ë‚˜ê¹Œì§€ ì‹ ê²½ ì“°ë©° í•˜ë£¨ë¥¼ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
        } else if (hasF("ê°€ë¬¸ì˜ í›„ê³„ì")){
          sentence = `[ê°€ë¬¸ì˜ í›„ê³„ì] ::${A};;${pickJosa(A,"ì€ëŠ”")} ìˆ˜ì—… ì¤‘ì—ë„ ê°€ë¬¸ì—ì„œ ë§¡ê¸´ ê³¼ì œë¥¼ ë– ì˜¬ë¦¬ë©°, ë¨¸ë¦¿ì†ì´ ë³µì¡í•´ì¡ŒìŠµë‹ˆë‹¤.`;
        } else if (hasF("ë¶€ìœ í•œ ì§‘ì•ˆ") && (hasT("ë‚™ì²œì ") || hasT("ì‚¬êµì "))){
          sentence = `[ë¶€ìœ í•œ ì§‘ì•ˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ê³µìš©ì‹¤ì—ì„œ ì§‘ì—ì„œ ê°€ì ¸ì˜¨ ê°„ì‹ì„ ë‚˜ëˆ„ì–´ ì£¼ë©°, ìì—°ìŠ¤ëŸ½ê²Œ ì‚¬ëŒë“¤ ì‚¬ì´ì˜ ì¤‘ì‹¬ì´ ë˜ì—ˆìŠµë‹ˆë‹¤.`;
        } else if (hasF("ë¶€ìœ í•œ ì§‘ì•ˆ")){
          sentence = `[ë¶€ìœ í•œ ì§‘ì•ˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} í˜¸ê·¸ì™€íŠ¸ì˜ ì†Œë°•í•œ ìƒí™œê³¼ ì§‘ì˜ í˜¸í™”ë¡œìš´ í™˜ê²½ì„ ë¹„êµí•˜ë©°, ë¬˜í•œ ì´ì§ˆê°ì„ ëŠê¼ˆìŠµë‹ˆë‹¤.`;
        } else if (hasF("ì²œì¬")){
          sentence = `[ì²œì¬] ::${A};;${pickJosa(A,"ì€ëŠ”")} ë‹¤ë¥¸ í•™ìƒë“¤ì´ ì• ë¥¼ ë¨¹ëŠ” ì£¼ë¬¸ ì´ë¡ ì„ ê¸ˆë°© ì´í•´í•´ ë²„ë¦¬ê³ , í˜¼ì í•œ ë°œ ì•ì„  ì—°ìŠµì„ ì‹œì‘í–ˆìŠµë‹ˆë‹¤.`;
        } else if (hasF("ì±…ë²Œë ˆ")){
          sentence = `[ì±…ë²Œë ˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì‰¬ëŠ” ì‹œê°„ë§ˆë‹¤ ë„ì„œê´€ì— ë“¤ëŸ¬, ì˜¤ëŠ˜ ë°°ìš´ ë‚´ìš©ì„ ì •ë¦¬í•˜ëŠ” ë° ëª°ë‘í–ˆìŠµë‹ˆë‹¤.`;
        } else if (hasF("ìš´ë™ê´‘")){
          sentence = `[ìš´ë™ê´‘] ::${A};;${pickJosa(A,"ì€ëŠ”")} ìˆ˜ì—…ì´ ëë‚˜ìë§ˆì ìš´ë™ì¥ìœ¼ë¡œ ë‹¬ë ¤ ë‚˜ê°€, ë¹—ìë£¨ë¥¼ íƒ€ê³  ëª¸ì„ í’€ì—ˆìŠµë‹ˆë‹¤.`;
        } else if (hasF("ë³‘ì•½")){
          sentence = `[ë³‘ì•½] ::${A};;${pickJosa(A,"ì€ëŠ”")} ê¸ˆì„¸ ì§€ì³ ë²„ë ¤, ë³´ê±´ì‹¤ì—ì„œ ì ì‹œ ì‰¬ê³  ë‚˜ì„œì•¼ ë‹¤ì‹œ ìˆ˜ì—…ì— ëŒì•„ì˜¬ ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.`;
        } else if (hasF("í–‰ìš´ì•„")){
          sentence = `[í–‰ìš´ì•„] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì˜ëª» ì™¸ìš´ ì£¼ë¬¸ì´ ìš°ì—°íˆ ì œëŒ€ë¡œ ì‘ë™í•˜ëŠ”, ë¯¿ê¸° ì–´ë ¤ìš´ í–‰ìš´ì„ ë˜ í•œ ë²ˆ ê²ªì—ˆìŠµë‹ˆë‹¤.`;
        }
      } else if (flavor === "trait"){
        if (traits.length){
          const t = traits[Math.floor(Math.random()*traits.length)];
          sentence = soloTraitSentence(A, t);
        }
      } else if (flavor === "blood"){
        // ë¨¸ê¸€ íƒœìƒ + ë‚™ì²œì /í‰ë“±ì£¼ì˜/ë°˜ê¶Œìœ„ ì¡°í•©ì€ ê·¸ëŒ€ë¡œ ìœ ì§€í•˜ë˜,
        // ì‹¤íŒ¨í•˜ë©´ ì¼ë°˜ í˜ˆí†µ ë¡œê·¸ë¡œ í´ë°±
        if (blood === "ë¨¸ê¸€ íƒœìƒ" && traits.length){
          const braveTraits = new Set(["ë‚™ì²œì ","í‰ë“±ì£¼ì˜","ë°˜ê¶Œìœ„"]);
          const hasBrave = traits.some(t=>braveTraits.has(t));
          if (hasBrave && Math.random() < 0.5){
            sentence = `[ë¨¸ê¸€ íƒœìƒ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ìˆœí˜ˆë“¤ì˜ ì‹œì„ ì—ë„ ì•„ë‘ê³³í•˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.`;
          }
        }
        if (!sentence && blood){
          sentence = soloBloodSentence(A, blood, traits);
        }
      } else if (flavor === "mbti"){
        sentence = seasonSoloTraitLine(id, key);
      }
    }
  }

// 4ìˆœìœ„: ì¼ë°˜ 1ì¸ ì´ë²¤íŠ¸
if (!sentence && soloGen.length){
  const f = pick(soloGen);
  sentence = f(A);
}

// ìµœì¢… ì•ˆì „ë§
// ì§„ì§œë¡œ ì•„ë¬´ ì´ë²¤íŠ¸ë„ ì„ íƒë˜ì§€ ì•Šì•˜ë‹¤ë©´, 'ì¡°ìš©íˆ ë³´ëƒˆë‹¤' ëŒ€ì‹ 
// 'íŠ¹ì„±(feats)ì— ë§ëŠ” ì „ìš© ë¡œê·¸'ë¥¼ ì‚¬ìš©í•œë‹¤.
if (!sentence){
  const featsArr = (c0 && Array.isArray(c0.feats)) ? c0.feats : [];
  const pool = [];

  const pushFeat = (tag, sentences)=>{
    if (!featsArr.includes(tag)) return;
    sentences.forEach(s=>pool.push(s));
  };

  // ê°€ë¬¸ì˜ í›„ê³„ì
  pushFeat("ê°€ë¬¸ì˜ í›„ê³„ì", [
    `[ê°€ë¬¸ì˜ í›„ê³„ì] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì§‘ì•ˆì—ì„œ ë‚´ë ¤ì˜¨ ê¸°ëŒ€ë¥¼ ë– ì˜¬ë¦¬ë©°, ì˜¤ëŠ˜ë„ ìì‹ ì˜ í–‰ë™ í•˜ë‚˜í•˜ë‚˜ë¥¼ ì¡°ì‹¬ìŠ¤ëŸ½ê²Œ ì‹ ê²½ ì¼ë‹¤.`,
    `[ê°€ë¬¸ì˜ í›„ê³„ì] ::${A};;${pickJosa(A,"ì€ëŠ”")} ëŒ€ëŒ€ë¡œ ë‚´ë ¤ì˜¨ ê°€ë¬¸ì˜ ì´ë¦„ì„ ë– ì˜¬ë¦¬ë©°, ìˆ˜ì—… íƒœë„ë¶€í„° ë§íˆ¬ê¹Œì§€ ííŠ¸ëŸ¬ì§€ì§€ ì•Šìœ¼ë ¤ ì• ì¼ë‹¤.`
  ]);

  // ë¶€ìœ í•œ ì§‘ì•ˆ
  pushFeat("ë¶€ìœ í•œ ì§‘ì•ˆ", [
    `[ë¶€ìœ í•œ ì§‘ì•ˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ìµœì‹ í˜• ë¹—ìë£¨ì™€ ê³ ê¸‰ í•„ê¸°êµ¬ë¥¼ ìë‘í•˜ë“¯ êº¼ë‚´ ë†“ê³ , ì£¼ë³€ì˜ ì‹œì„ ì„ ì€ê·¼íˆ ì¦ê²¼ë‹¤.`,
    `[ë¶€ìœ í•œ ì§‘ì•ˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ê¸°ìˆ™ì‚¬ ì¹œêµ¬ë“¤ì—ê²Œ ê³ ê¸‰ ê°„ì‹ì„ ë‚˜ëˆ  ì£¼ë©°, ìì—°ìŠ¤ëŸ½ê²Œ ë¶„ìœ„ê¸°ì˜ ì¤‘ì‹¬ì´ ë˜ì—ˆë‹¤.`
  ]);

  // ì±…ë²Œë ˆ
  pushFeat("ì±…ë²Œë ˆ", [
    `[ì±…ë²Œë ˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ìˆ˜ì—…ì´ ëë‚œ ë’¤ì—ë„ ë„ì„œê´€ì—ì„œ ì±…ì„ ë®ì„ ì¤„ ëª¨ë¥´ê³ , í•œ ì±•í„°ë§Œ ë” ì½ìë©° ìë¦¬ë¥¼ ì§€ì¼°ë‹¤.`,
    `[ì±…ë²Œë ˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ê³µìš©ì‹¤ì´ ì‹œë„ëŸ¬ì›Œì§€ì ì¡°ìš©í•œ êµ¬ì„ìœ¼ë¡œ ìë¦¬ë¥¼ ì˜®ê²¨, ì±… ì† ì„¸ê³„ì— í‘¹ ë¹ ì ¸ ìˆì—ˆë‹¤.`
  ]);

  // ì²œì¬
  pushFeat("ì²œì¬", [
    `[ì²œì¬] ::${A};;${pickJosa(A,"ì€ëŠ”")} ìˆ˜ì—… ë‚´ìš©ì´ ë„ˆë¬´ ì‰¬ì› ëŠ”ì§€, êµìˆ˜ì˜ ì„¤ëª…ì„ ë“£ë‹¤ê°€ ìŠ¤ìŠ¤ë¡œ ë‹¤ë¥¸ ì‘ìš©ë²•ì„ ìƒê°í•´ ë‚´ë©° ì‹œê°„ì„ ë³´ëƒˆë‹¤.`,
    `[ì²œì¬] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì‹œí—˜ ë²”ìœ„ë¥¼ í•œ ë²ˆ í›‘ì–´ë³¸ ë’¤, ì´ë¯¸ í•œ ë²ˆì€ ë³¸ ë“¯í•œ í‘œì •ìœ¼ë¡œ ì—¬ìœ  ìˆê²Œ ë…¸íŠ¸ë¥¼ ì •ë¦¬í–ˆë‹¤.`
  ]);

  // ë¦¬ë”ì‹­
  pushFeat("ë¦¬ë”ì‹­", [
    `[ë¦¬ë”ì‹­] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì¡°ë³„ ê³¼ì œê°€ ë‚˜ì˜¤ì ìì—°ìŠ¤ëŸ½ê²Œ ì¤‘ì‹¬ì— ì„œì„œ ì—­í• ì„ ë‚˜ëˆ„ê³ , ëª¨ë‘ê°€ ë”°ë¼ì˜¬ ìˆ˜ ìˆë„ë¡ ì±™ê²¼ë‹¤.`,
    `[ë¦¬ë”ì‹­] ::${A};;${pickJosa(A,"ì€ëŠ”")} ê³ ë¯¼ì´ ìˆì–´ ë³´ì´ëŠ” ì¹œêµ¬ë¥¼ ë°œê²¬í•˜ê³  ë¨¼ì € ë‹¤ê°€ê°€, ì¡°ìš©íˆ ì´ì•¼ê¸°ë¥¼ ë“¤ì–´ ì£¼ì—ˆë‹¤.`
  ]);

  // ìœ ë¦¬ ë©˜íƒˆ
  pushFeat("ìœ ë¦¬ ë©˜íƒˆ", [
    `[ìœ ë¦¬ ë©˜íƒˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì‚¬ì†Œí•œ ì§€ì ì—ë„ ë§ˆìŒì´ í”ë“¤ë ¤, í•œë™ì•ˆ ìˆ˜ì—…ì— ì§‘ì¤‘í•˜ì§€ ëª»í•œ ì±„ í˜¼ì ë³µë„ì—ì„œ ì‹œê°„ì„ ë³´ëƒˆë‹¤.`,
    `[ìœ ë¦¬ ë©˜íƒˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì‘ì€ ì‹¤ìˆ˜ í•˜ë‚˜ì—ë„ í¬ê²Œ ë‚™ë‹´í•´, ì¹œêµ¬ë“¤ì˜ ìœ„ë¡œë¥¼ ë°›ìœ¼ë©° ê²¨ìš° ê¸°ìš´ì„ ë˜ì°¾ì•˜ë‹¤.`
  ]);

  // ë°˜í•­ì•„
  pushFeat("ë°˜í•­ì•„", [
    `[ë°˜í•­ì•„] ::${A};;${pickJosa(A,"ì€ëŠ”")} êµìˆ˜ì˜ ì§€ì‹œì— ì‚´ì§ ì—‡ë‚˜ê°€ëŠ” í–‰ë™ì„ í•˜ë©°, ì£¼ë³€ ì¹œêµ¬ë“¤ì˜ ì›ƒìŒì„ ìì•„ëƒˆë‹¤.`,
    `[ë°˜í•­ì•„] ::${A};;${pickJosa(A,"ì€ëŠ”")} ê·œì¹™ì„ ì¡°ê¸ˆ ì–´ê²¨ ê°€ë©°, ëª°ë˜ ë°¤ëŠ¦ê²Œê¹Œì§€ ëŒì•„ë‹¤ë‹ˆë‹¤ê°€ ê°„ì‹ íˆ ë“¤í‚¤ì§€ ì•Šê³  ê¸°ìˆ™ì‚¬ë¡œ ëŒì•„ì™”ë‹¤.`
  ]);

  // í–‰ìš´ì•„
  pushFeat("í–‰ìš´ì•„", [
    `[í–‰ìš´ì•„] ::${A};;${pickJosa(A,"ì€ëŠ”")} ìš°ì—°íˆ ê³µìš©ì‹¤ì—ì„œ ë–¨ì–´ì§„ íŒŒì¹˜ì°Œë¥¼ ì£¼ì› ëŠ”ë°, ì•Œê³  ë³´ë‹ˆ ì›í•˜ëŠ” ê±¸ ë­ë“  í•˜ë‚˜ ë½‘ì„ ìˆ˜ ìˆëŠ” í–‰ìš´ì˜ ë¬¼ê±´ì´ì—ˆë‹¤.`,
    `[í–‰ìš´ì•„] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì¤€ë¹„í•˜ì§€ ì•Šì€ ë¶€ë¶„ì—ì„œ ê°‘ìê¸° ìª½ì§€ ì‹œí—˜ì´ ë‚˜ì™”ì§€ë§Œ, ì „ë‚  ì¥ë‚œ ì‚¼ì•„ ì½ì–´ë³¸ í˜ì´ì§€ê°€ ê·¸ëŒ€ë¡œ ì ì¤‘í–ˆë‹¤.`
  ]);

  // ë³‘ì•½
  pushFeat("ë³‘ì•½", [
    `[ë³‘ì•½] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì•„ì¹¨ë¶€í„° ì»¨ë””ì…˜ì´ ì¢‹ì§€ ì•Šì•„, ë³´ê±´ì‹¤ ì¹¨ëŒ€ì— ëˆ„ì›Œ ì°½ë°–ë§Œ ë°”ë¼ë³´ë©° í•˜ë£¨ë¥¼ ë³´ëƒˆë‹¤.`,
    `[ë³‘ì•½] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì¡°ê¸ˆë§Œ ë¬´ë¦¬í•´ë„ ê¸ˆì„¸ ì§€ì³, ê³„ë‹¨ì„ ì˜¤ë¥´ë‚´ë¦¬ëŠ” ê²ƒì¡°ì°¨ ì¡°ì‹¬ìŠ¤ëŸ½ê²Œ ì›€ì§ì—¬ì•¼ í–ˆë‹¤.`
  ]);

  // ìš´ë™ê´‘
  pushFeat("ìš´ë™ê´‘", [
    `[ìš´ë™ê´‘] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì‰¬ëŠ” ì‹œê°„ì´ ëë‚  ë•Œê¹Œì§€ ìš´ë™ì¥ì—ì„œ ë¹—ìë£¨ë¥¼ íƒ€ê³  ëŒì§„ ì—°ìŠµì„ í•˜ë©° ë•€ì„ í˜ë ¸ë‹¤.`,
    `[ìš´ë™ê´‘] ::${A};;${pickJosa(A,"ì€ëŠ”")} ìˆ˜ì—…ì´ ëë‚˜ìë§ˆì ì¹œêµ¬ë“¤ì„ ëŒê³  ë‚˜ê°€, í€´ë””ì¹˜ ê³¨ëŒ€ ì•ì—ì„œ ìŠ› ì—°ìŠµì„ ì œì•ˆí–ˆë‹¤.`
  ]);

  if (pool.length){
    sentence = pool[Math.floor(Math.random() * pool.length)];
  } else {
    // ì •ë§ë¡œ ì–´ë–¤ íŠ¹ì„±ë„ ì¡íˆì§€ ì•ŠëŠ” ìºë¦­í„°ë§Œ ê¸°ì¡´ ë¬¸ì¥ ì‚¬ìš©
    sentence = `::${A};;${pickJosa(A,"ì€ëŠ”")} íŠ¹ë³„í•œ ì‚¬ê±´ ì—†ì´, í‰ë²”í•œ í•™êµ ì¼ê³¼ë¥¼ ë”°ë¼ê°€ë©° í•˜ë£¨ë¥¼ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
  }
}

          lines.push(sentence);
        } else if (g.length === 2){
          const [aId, bId] = g;
          const A = nameOf(aId), B = nameOf(bId);
          let sentence = "";
          let delta = 0;

          const cA = characters.find(c=>c.id===aId);
          const cB = characters.find(c=>c.id===bId);
          const aHouse = (cA && cA.house) || "";
          const bHouse = (cB && cB.house) || "";
          const aBlood = (cA && cA.blood) || "";
          const bBlood = (cB && cB.blood) || "";
          const sameHouse = !!(aHouse && bHouse && aHouse === bHouse);

          // ì¼ì • í™•ë¥ ë¡œ 2ì¸ ì´ë²¤íŠ¸ ëŒ€ì‹  ê°ì ê°œì¸ ì´ë²¤íŠ¸ë¡œ ì²˜ë¦¬
          if (Math.random() >= 0.6){
            // ìœ„ì—ì„œ ë¯¸ë¦¬ ì°¾ì€ cA/cBë¥¼ ì¬ì‚¬ìš©í•œë‹¤.
            
            const fA = (cA && Array.isArray(cA.feats)) ? cA.feats : [];
            const tA = (cA && Array.isArray(cA.traits)) ? cA.traits : [];
            let sA = "";
            if (fA.includes("ìš´ë™ê´‘")){
              sA = `[ìš´ë™ê´‘] ::${A};;${pickJosa(A,"ì€ëŠ”")} í˜¼ìì„œë„ ìš´ë™ì¥ìœ¼ë¡œ ë‚˜ê°€ ë¹—ìë£¨ë¥¼ íƒ€ê³ , ì˜¨ëª¸ì´ ë•€ì— ì –ì„ ë•Œê¹Œì§€ ì—°ìŠµì„ ê³„ì†í–ˆìŠµë‹ˆë‹¤.`;
            } else if (fA.includes("ì²œì¬")){
              sA = `[ì²œì¬] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì˜¤ëŠ˜ ë°°ìš´ ë‚´ìš© ì •ë„ëŠ” ì´ë¯¸ ì•Œê³  ìˆì—ˆë‹¤ëŠ” ë“¯, í˜¼ì ë‹¤ë¥¸ ë§ˆë²• ì´ë¡ ì„ ì‹œí—˜í•´ ë³´ë©° ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
            } else if (fA.includes("ì±…ë²Œë ˆ")){
              sA = `[ì±…ë²Œë ˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} í•¨ê»˜ ì‹œê°„ì„ ë³´ë‚¸ ë’¤ì—ë„ ë„ì„œê´€ìœ¼ë¡œ í–¥í•´, ë‚¨ì€ ì‹œê°„ì„ ì¡°ìš©íˆ ë…ì„œë¡œ ì±„ì› ìŠµë‹ˆë‹¤.`;
            } else if (fA.includes("ë³‘ì•½")){
              sA = `[ë³‘ì•½] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì¡°ê¸ˆ ë¬´ë¦¬í–ˆë˜ íƒ“ì¸ì§€ ê¸ˆì„¸ í”¼ê³¤í•´ì ¸, ë³´ê±´ì‹¤ ì¹¨ëŒ€ì— ëˆ„ì›Œ í•œì°¸ì„ ì‰¬ì–´ì•¼ í–ˆìŠµë‹ˆë‹¤.`;
            } else if (fA.includes("í–‰ìš´ì•„")){
              sA = `[í–‰ìš´ì•„] ::${A};;${pickJosa(A,"ì€ëŠ”")} ìš°ì—°íˆ ë§ˆì£¼ì¹œ êµìˆ˜ë‹˜ì—ê²Œì„œ ëœ»ë°–ì˜ ì¹­ì°¬ì„ ë“£ê³ , ê¸°ë¶„ ì¢‹ê²Œ í•˜ë£¨ë¥¼ ë§ˆë¬´ë¦¬í–ˆìŠµë‹ˆë‹¤.`;
            } else if (fA.length){
              const tagA = fA[0];
              if (tagA === "ë¶€ìœ í•œ ì§‘ì•ˆ"){
                sA = `[ë¶€ìœ í•œ ì§‘ì•ˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ìµœì‹ í˜• ë¹—ìë£¨ì™€ ê³ ê¸‰ ë¬¼ê±´ë“¤ì„ ì•„ë¬´ë ‡ì§€ ì•Šê²Œ ì‚¬ìš©í•˜ë©°, ìì‹ ì´ ë‚¨ë“¤ë³´ë‹¤ ì—¬ìœ ë¡œìš´ í™˜ê²½ì— ìˆë‹¤ëŠ” ê±¸ ìƒˆì‚¼ ëŠê¼ˆìŠµë‹ˆë‹¤.`;
              } else if (tagA === "ë¦¬ë”ì‹­"){
                sA = `[ë¦¬ë”ì‹­] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì•„ë¬´ë„ ë‚˜ì„œì§€ ì•Šë˜ ìˆœê°„ì— ì¡°ìš©íˆ ì•ì— ì„œì„œ, ì¹œêµ¬ë“¤ì˜ ì˜ê²¬ì„ ëª¨ì•„ ê¹”ë”í•˜ê²Œ ì •ë¦¬í•´ ì£¼ì—ˆìŠµë‹ˆë‹¤.`;
              } else if (tagA === "ìœ ë¦¬ ë©˜íƒˆ"){
                sA = `[ìœ ë¦¬ ë©˜íƒˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì‚¬ì†Œí•œ ë§ í•œë§ˆë””ê°€ ë§ˆìŒì— ë‚¨ì•„, í˜¼ì ê¸°ìˆ™ì‚¬ ì¹¨ëŒ€ì— ëˆ„ì›Œ í•œì°¸ì„ ê³±ì”¹ìœ¼ë©° ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
              } else if (tagA === "ë°˜í•­ì•„"){
                sA = `[ë°˜í•­ì•„] ::${A};;${pickJosa(A,"ì€ëŠ”")} ê·œì¹™ì„ ì‚´ì§ ë¹„í‹€ì–´ ì¥ë‚œì„ ì¹˜ê³ ëŠ”, ë“¤í‚¤ì§€ ì•Šê²Œ ìŠ¬ê·¸ë¨¸ë‹ˆ ë¹ ì ¸ë‚˜ê°€ë©° í˜¼ìë§Œì˜ ìŠ¹ë¦¬ê°ì„ ë§›ë³´ì•˜ìŠµë‹ˆë‹¤.`;
              } else if (tagA === "ê°€ë¬¸ì˜ í›„ê³„ì"){
                sA = `[ê°€ë¬¸ì˜ í›„ê³„ì] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì§‘ì•ˆì—ì„œ ë§¡ê¸´ ê¸°ëŒ€ë¥¼ ë– ì˜¬ë¦¬ë©°, ì˜¤ëŠ˜ë„ í–‰ë™ í•˜ë‚˜í•˜ë‚˜ë¥¼ ë‹¤ì¡ìœ¼ë ¤ ì• ì“°ë©° í•˜ë£¨ë¥¼ ë§ˆë¬´ë¦¬í–ˆìŠµë‹ˆë‹¤.`;
              } else {
                sA = `[${tagA}] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì˜¤ëŠ˜ í•˜ë£¨, '${tagA}'ë‹¤ìš´ ëª¨ìŠµì„ ëª‡ ë²ˆì´ë‚˜ ë“œëŸ¬ë‚´ë©° ì¡°ìš©íˆ ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
              }
            } else {
              // featsê°€ ì—†ë‹¤ë©´, ì˜ˆì „ì˜ ì„±ê²© ê¸°ë°˜ 1ì¸ ë¡œê·¸ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš©
              sA = `::${A};;${pickJosa(A,"ì€ëŠ”")} íŠ¹ë³„í•œ ì‚¬ê±´ ì—†ì´, í‰ë²”í•œ í•™êµ ì¼ê³¼ë¥¼ ë”°ë¼ê°€ë©° í•˜ë£¨ë¥¼ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
              if (tA.includes("ì±…ë²Œë ˆ")){
                sA = `::${A};;${pickJosa(A,"ì€ëŠ”")} ìˆ˜ì—…ì´ ì—†ëŠ” ì‹œê°„ë§ˆë‹¤ ì±…ì„ ì½ìœ¼ë©° ì§€ëƒˆìŠµë‹ˆë‹¤.`;
              } else if (tA.includes("í™œë°œí•¨") || tA.includes("ì‚¬êµì ")){
                sA = `::${A};;${pickJosa(A,"ì€ëŠ”")} ì—¬ëŸ¬ ì¹œêµ¬ë“¤ê³¼ ì–´ìš¸ë¦¬ë©° ë– ë“¤ì©í•œ í•˜ë£¨ë¥¼ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
              }
            }
            lines.push(sA);

                        const fB = (cB && Array.isArray(cB.feats)) ? cB.feats : [];
            const tB = (cB && Array.isArray(cB.traits)) ? cB.traits : [];
            let sB = "";
            if (fB.includes("ìš´ë™ê´‘")){
              sB = `[ìš´ë™ê´‘] ::${B};;${pickJosa(B,"ì€ëŠ”")} í˜¼ì ìš´ë™ì¥ìœ¼ë¡œ ë‹¬ë ¤ë‚˜ê°€, ë°©ê¸ˆì˜ ì¼ì„ ìŠì€ ë“¯ ëª¸ì„ ì›€ì§ì´ë©° ìŠ¤íŠ¸ë ˆìŠ¤ë¥¼ í’€ì—ˆìŠµë‹ˆë‹¤.`;
            } else if (fB.includes("ì²œì¬")){
              sB = `[ì²œì¬] ::${B};;${pickJosa(B,"ì€ëŠ”")} í•¨ê»˜ ë³´ë‚¸ ì‹œê°„ì„ ë– ì˜¬ë¦¬ë©°, ê·¸ ì†ì—ì„œ ì–»ì€ íŒíŠ¸ë¥¼ ë°”íƒ•ìœ¼ë¡œ ìƒˆë¡œìš´ ë§ˆë²• ì•„ì´ë””ì–´ë¥¼ ë– ì˜¬ë ¸ìŠµë‹ˆë‹¤.`;
            } else if (fB.includes("ì±…ë²Œë ˆ")){
              sB = `[ì±…ë²Œë ˆ] ::${B};;${pickJosa(B,"ì€ëŠ”")} ë„ì„œê´€ì—ì„œ ë‚¨ì€ ì‹œê°„ì„ ë³´ë‚´ë©°, ë°©ê¸ˆ ë‚˜ëˆˆ ëŒ€í™”ë¥¼ ê³±ì”¹ìœ¼ë©° ì±…ì¥ì„ ë„˜ê²¼ìŠµë‹ˆë‹¤.`;
            } else if (fB.includes("ë³‘ì•½")){
              sB = `[ë³‘ì•½] ::${B};;${pickJosa(B,"ì€ëŠ”")} ê¸ˆì„¸ í”¼ê³¤í•´ì ¸ ê¸°ìˆ™ì‚¬ ì¹¨ëŒ€ì— ëˆ„ì›Œ, ëª¸ ìƒíƒœë¥¼ ë‹¤ë…ì´ë©° ì¡°ìš©íˆ ìˆ¨ì„ ê³¨ëìŠµë‹ˆë‹¤.`;
            } else if (fB.includes("í–‰ìš´ì•„")){
              sB = `[í–‰ìš´ì•„] ::${B};;${pickJosa(B,"ì€ëŠ”")} ìš°ì—°íˆ ì¢‹ì€ ì†Œì‹ì„ ë“£ê²Œ ë˜ì–´, í˜¼ìì„œë„ ì‹±ê¸€ë²™ê¸€í•œ í‘œì •ìœ¼ë¡œ ê¸°ìˆ™ì‚¬ë¡œ ëŒì•„ê°”ìŠµë‹ˆë‹¤.`;
            } else if (fB.length){
              const tagB = fB[0];
              if (tagB === "ë¶€ìœ í•œ ì§‘ì•ˆ"){
                sB = `[ë¶€ìœ í•œ ì§‘ì•ˆ] ::${B};;${pickJosa(B,"ì€ëŠ”")} ì§‘ì—ì„œ ê°€ì ¸ì˜¨ ê³ ê¸‰ ê°„ì‹ì„ ì¹œêµ¬ë“¤ì—ê²Œ ë‚˜ëˆ  ì£¼ë©°, ì•„ë¬´ë ‡ì§€ ì•Šê²Œ ë„‰ë„‰í•œ ì§‘ì•ˆ ì‚¬ì •ì„ ë“œëŸ¬ëƒˆìŠµë‹ˆë‹¤.`;
              } else if (tagB === "ë¦¬ë”ì‹­"){
                sB = `[ë¦¬ë”ì‹­] ::${B};;${pickJosa(B,"ì€ëŠ”")} ì£¼ë³€ ì¹œêµ¬ë“¤ì´ ìš°ì™•ì¢Œì™•í•˜ì, ì¡°ìš©íˆ ì•ì— ì„œì„œ ì˜¤ëŠ˜ í•´ì•¼ í•  ì¼ë“¤ì„ ì •ë¦¬í•´ ì£¼ì—ˆìŠµë‹ˆë‹¤.`;
              } else if (tagB === "ìœ ë¦¬ ë©˜íƒˆ"){
                sB = `[ìœ ë¦¬ ë©˜íƒˆ] ::${B};;${pickJosa(B,"ì€ëŠ”")} ì‘ì€ ë§ í•œë§ˆë””ì— ë§ˆìŒì´ ì˜ˆë¯¼í•˜ê²Œ ë°˜ì‘í•´, í˜¼ì ì‚°ì±…ì„ í•˜ë©° ìƒê°ì„ ì •ë¦¬í•˜ëŠ” ë° ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
              } else if (tagB === "ë°˜í•­ì•„"){
                sB = `[ë°˜í•­ì•„] ::${B};;${pickJosa(B,"ì€ëŠ”")} ì •í•´ì§„ ê·œì¹™ì„ ì‚´ì§ ì–´ê¸°ëŠ” ì§“ì„ í•´ ë†“ê³ , ë“¤í‚¤ì§€ ì•Šì•˜ë‹¤ëŠ” ì‚¬ì‹¤ì— í˜¼ì í¡ì¡±í•´í–ˆìŠµë‹ˆë‹¤.`;
              } else if (tagB === "ê°€ë¬¸ì˜ í›„ê³„ì"){
                sB = `[ê°€ë¬¸ì˜ í›„ê³„ì] ::${B};;${pickJosa(B,"ì€ëŠ”")} ì§‘ì•ˆì—ì„œ ë°›ëŠ” ê¸°ëŒ€ë¥¼ ë– ì˜¬ë¦¬ë©°, ë°©ê¸ˆì˜ ì¼ì„ ì–´ë–»ê²Œ ë³´ê³ í• ì§€ í˜¼ì ë¨¸ë¦¿ì†ìœ¼ë¡œ ë˜ì§šì–´ ë³´ì•˜ìŠµë‹ˆë‹¤.`;
              } else {
                sB = `[${tagB}] ::${B};;${pickJosa(B,"ì€ëŠ”")} ì˜¤ëŠ˜ í•˜ë£¨, '${tagB}'ë‹¤ìš´ ë¶„ìœ„ê¸°ë¥¼ í’ê¸°ë©° í˜¼ìë§Œì˜ ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
              }
            } else {
              sB = `::${B};;${pickJosa(B,"ì€ëŠ”")} íŠ¹ë³„í•œ ì‚¬ê±´ ì—†ì´, í‰ë²”í•œ í•™êµ ì¼ê³¼ë¥¼ ë”°ë¼ê°€ë©° í•˜ë£¨ë¥¼ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
              if (tB.includes("ì±…ë²Œë ˆ")){
                sB = `::${B};;${pickJosa(B,"ì€ëŠ”")} ë„ì„œê´€ì—ì„œ ì‹œê°„ì„ ë³´ë‚´ë©° ì±…ì— íŒŒë¬»í˜€ ìˆì—ˆìŠµë‹ˆë‹¤.`;
              } else if (tB.includes("í™œë°œí•¨") || tB.includes("ì‚¬êµì ")){
                sB = `::${B};;${pickJosa(B,"ì€ëŠ”")} ê³µìš©ì‹¤ì—ì„œ ì¹œêµ¬ë“¤ê³¼ ì›ƒê³  ë– ë“¤ë©° í•˜ë£¨ë¥¼ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
              }
            }
            lines.push(sB);
            return;
          }

          if (!sentence && sameHouse && Math.random() < 0.3){
            sentence = `[ê°™ì€ ê¸°ìˆ™ì‚¬] ::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ê³µìš© ê¸°ìˆ™ì‚¬ì—ì„œ ë‚˜ë€íˆ ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
            delta = 2;
          } else if (!sentence && aHouse === "ìŠ¬ë¦¬ë°ë¦°" && bBlood === "ë¨¸ê¸€ íƒœìƒ" && Math.random() < 0.3){
            const cb = characters.find(c=>c.id===bId);
            const traitsB = (cb && Array.isArray(cb.traits)) ? cb.traits : [];
            const braveB = traitsB.some(t=>["í‰ë“±ì£¼ì˜","ë°˜ê¶Œìœ„","ë‚™ì²œì "].includes(t));
            if (braveB){
              sentence = `ìŠ¬ë¦¬ë°ë¦°ì¸ ::${A};;ì˜ ì‹¸ëŠ˜í•œ ë¶„ìœ„ê¸° ì†ì—ì„œë„, ë¨¸ê¸€ íƒœìƒì¸ ::${B};;${pickJosa(B,"ì€ëŠ”")} ì‰½ê²Œ ìœ„ì¶•ë˜ì§€ ì•Šìœ¼ë ¤ ì• ì¼ìŠµë‹ˆë‹¤.`;
              delta = -1;
            } else {
              sentence = `ìŠ¬ë¦¬ë°ë¦°ì¸ ::${A};;${pickJosa(A,"ì€ëŠ”")} ë¨¸ê¸€ íƒœìƒì¸ ::${B};;ì—ê²Œ ì¡°ê¸ˆ ì°¨ê°€ìš´ ë§ì„ ë˜ì¡ŒìŠµë‹ˆë‹¤.`;
              delta = -2;
            }
          } else if (!sentence && bHouse === "ìŠ¬ë¦¬ë°ë¦°" && aBlood === "ë¨¸ê¸€ íƒœìƒ" && Math.random() < 0.3){
            const ca = characters.find(c=>c.id===aId);
            const traitsA = (ca && Array.isArray(ca.traits)) ? ca.traits : [];
            const braveA = traitsA.some(t=>["í‰ë“±ì£¼ì˜","ë°˜ê¶Œìœ„","ë‚™ì²œì "].includes(t));
            if (braveA){
              sentence = `ë¨¸ê¸€ íƒœìƒì¸ ::${A};;${pickJosa(A,"ì€ëŠ”")} ìŠ¬ë¦¬ë°ë¦°ì¸ ::${B};;ì˜ ì‹œì„ ì„ ì˜ì‹í•˜ë©´ì„œë„, ì‰½ì‚¬ë¦¬ ìœ„ì¶•ë˜ì§€ëŠ” ì•Šìœ¼ë ¤ í–ˆìŠµë‹ˆë‹¤.`;
              delta = -1;
            } else {
              sentence = `ë¨¸ê¸€ íƒœìƒì¸ ::${A};;${pickJosa(A,"ì€ëŠ”")} ìŠ¬ë¦¬ë°ë¦°ì¸ ::${B};;ì˜ ì‹œì„ ì— ì‚´ì§ ìœ„ì¶•ë˜ì—ˆìŠµë‹ˆë‹¤.`;
              delta = -2;
            }
          }

          
          // ==== Negative affinity themed conflicts (rarer than positive) ====
          if (!sentence){
            const ca = characters.find(c=>c.id===aId);
            const cb = characters.find(c=>c.id===bId);
            const ta = (ca && Array.isArray(ca.traits)) ? ca.traits : [];
            const tb = (cb && Array.isArray(cb.traits)) ? cb.traits : [];
            const ba = ca && ca.blood ? ca.blood : "";
            const bb = cb && cb.blood ? cb.blood : "";

            const hasA = (x)=>ta.includes(x);
            const hasB = (x)=>tb.includes(x);

            const brave = (t)=>t.includes("í‰ë“±ì£¼ì˜")||t.includes("ë°˜ê¶Œìœ„")||t.includes("ë‚™ì²œì ");
            const hier = (t)=>t.includes("í˜ˆí†µì¤‘ì‹œ")||t.includes("ê¶Œìœ„ì¡´ì¤‘");

            let negPool = [];

            // ìˆœí˜ˆ vs ë¨¸ê¸€ íƒœìƒ ì¡°í•©ì—ì„œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ëŒ€ì‚¬
            if ((ba==="ë¨¸ê¸€ íƒœìƒ" && bb==="ìˆœí˜ˆ" && hier(tb)) || (bb==="ë¨¸ê¸€ íƒœìƒ" && ba==="ìˆœí˜ˆ" && hier(ta))){
              negPool.push(`ìˆœí˜ˆê³¼ ë¨¸ê¸€ ì¶œì‹  ì‚¬ì´ì˜ ë¯¸ë¬˜í•œ ëŒ€í™” ëì—, ::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};; ì‚¬ì´ì— ë³´ì´ì§€ ì•ŠëŠ” ê¸´ì¥ê°ì´ ë‚¨ì•˜ìŠµë‹ˆë‹¤.`);
            }

            if ((hasA("ì´ìƒì£¼ì˜") && hasB("í˜„ì‹¤ì£¼ì˜")) || (hasA("í˜„ì‹¤ì£¼ì˜") && hasB("ì´ìƒì£¼ì˜"))){
              negPool.push(`::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ì„œë¡œë¥¼ ì„¤ë“í•˜ì§€ ëª»í•œ ì±„ ëŒ€í™”ë¥¼ ì¤‘ë‹¨í–ˆê³ , ë¶ˆí¸í•œ ê°ì •ë§Œ ë‚¨ì•˜ìŠµë‹ˆë‹¤.`);
            }

            if ((hasA("í‰ë“±ì£¼ì˜") && hasB("í˜ˆí†µì¤‘ì‹œ")) || (hasA("í˜ˆí†µì¤‘ì‹œ") && hasB("í‰ë“±ì£¼ì˜"))){
              negPool.push(`í˜ˆí†µ ë¬¸ì œë¥¼ ë‘ê³  ì˜ê²¬ì´ í¬ê²Œ ê°ˆë¦¬ë©°, ::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} í•œë™ì•ˆ ë§ì„ ì•„ë¼ê¸°ë¡œ í–ˆìŠµë‹ˆë‹¤.`);
            }

            if ((hasA("ê¶Œìœ„ì¡´ì¤‘") && brave(tb)) || (hasB("ê¶Œìœ„ì¡´ì¤‘") && brave(ta))){
              negPool.push(`ê·œì¹™ê³¼ íƒœë„ë¥¼ ë‘˜ëŸ¬ì‹¼ ëŒ€ë¦½ìœ¼ë¡œ ì¸í•´, ::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;ì˜ ê´€ê³„ê°€ í•œì¸µ ë” ëƒ‰ë­í•´ì¡ŒìŠµë‹ˆë‹¤.`);
            }

            if ((hasA("ë³‘ì•½") && hasB("ìš´ë™ê´‘")) || (hasA("ìš´ë™ê´‘") && hasB("ë³‘ì•½"))){
              negPool.push(`ì²´ë ¥ ì°¨ì´ì—ì„œ ë¹„ë¡¯ëœ ì‘ì€ ì‹¤ë‘ì´ê°€ ìŒ“ì—¬, ::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ì„œë¡œì—ê²Œ ì•½ê°„ì˜ ë¶ˆí¸í•¨ì„ ëŠë¼ê¸° ì‹œì‘í–ˆìŠµë‹ˆë‹¤.`);
            }

            if ((hasA("ì¶©ë™ì ") && hasB("ì‹ ì¤‘í•¨")) || (hasA("ì‹ ì¤‘í•¨") && hasB("ì¶©ë™ì "))){
              negPool.push(`ì„±ê²© ì°¨ì´ë¡œ ì¸í•œ ì–¸ìŸ ëì—, ::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};; ì‚¬ì´ì— ë¯¸ë¬˜í•œ ê· ì—´ì´ ìƒê²¼ìŠµë‹ˆë‹¤.`);
            }

            if ((hasA("ëƒ‰ì •í•¨") && hasB("ê°ì„±ì ")) || (hasA("ê°ì„±ì ") && hasB("ëƒ‰ì •í•¨"))){
              negPool.push(`ë§íˆ¬ì™€ íƒœë„ì˜ ì°¨ì´ê°€ ë˜ í•œ ë²ˆ ì¶©ëŒí•˜ë©°, ::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ì„œë¡œë¥¼ ì´í•´í•˜ê¸° ì–´ë ¤ì›Œí–ˆìŠµë‹ˆë‹¤.`);
            }

            if (negPool.length && Math.random() < 0.28){
              sentence = pick(negPool).replace("::A;;", `::${A};;`).replace("::B;;", `::${B};;`);
              delta = -1;
            }
          }
const pg = (SEASON_PAIR_GENERAL[key] || []);
          const pt = (SEASON_PAIR_TRAIT[key] || []);

                    // ì„±ê²© í‚¤ì›Œë“œ / í˜ˆí†µ ê¸°ë°˜ 2ì¸ ì´ë²¤íŠ¸ (ëŒ€ê´„í˜¸ X)
          if (!sentence){
            const ca = characters.find(c=>c.id===aId);
            const cb = characters.find(c=>c.id===bId);
            const ta = (ca && Array.isArray(ca.traits)) ? ca.traits : [];
            const tb = (cb && Array.isArray(cb.traits)) ? cb.traits : [];
            const ba = ca && ca.blood ? ca.blood : "";
            const bb = cb && cb.blood ? cb.blood : "";

            if (ta.length && Math.random()<0.25){
              const t = ta[Math.floor(Math.random()*ta.length)];
              sentence = pairTraitSentence(A, B, t, ca, cb);
              delta = 2;
            } else if (tb.length && Math.random()<0.25){
              const t = tb[Math.floor(Math.random()*tb.length)];
              sentence = pairTraitSentence(B, A, t, cb, ca);
              delta = 1;
            } else if (ba && bb && ba !== bb && Math.random()<0.2){
              sentence = pairBloodSentence(A, B, ba, bb);
              delta = 1;
            }
          }

// ì•„ì§ íŠ¹ìˆ˜ ë¬¸ì¥ì´ ì„ íƒë˜ì§€ ì•Šì•˜ë‹¤ë©´ â†’ ê¸°ì¡´ MBTI/ì¼ë°˜ í…œí”Œë¦¿ ì‚¬ìš©
          if (!sentence){
            if (pt.length && Math.random() < 0.2){
              const f = pick(pt);
              sentence = f(aId, bId);
              delta = 2; // ì¡°ê¸ˆ ë” ê°•í•œ +í˜¸ê°ë„
            } else if (pg.length){
              const f = pick(pg);
              sentence = f(A, B);
              delta = 1;
            } else {
              sentence = `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ì˜¤ëŠ˜ë„ ì–¼êµ´ì„ ë§ˆì£¼ì³¤ìŠµë‹ˆë‹¤.`;
              delta = 1;
            }
          }

          // â˜… ì„±ê²©/í˜ˆí†µ ê¸°ë°˜ ìµœì¢… íŠœë‹
          try{
            const tunedAuto = tunePairAffinityForTraits(aId, bId, sentence, delta, "auto");
            sentence = tunedAuto.sentence;
            delta = tunedAuto.delta;
          }catch(e){}

          // 'í˜ˆí†µ' ë¬¸ì œë¥¼ ë‘ê³  ì˜ê²¬ì´ ê°•í•˜ê²Œ ëŒ€ë¦½í•œ ì¥ë©´ì€
          // í•­ìƒ -í˜¸ê°ë„ë¡œ ê³ ì •ë˜ë„ë¡ ë§ˆì§€ë§‰ì— í•œ ë²ˆ ë” ë³´ì •í•œë‹¤.
          try{
            const bloodConflictRegex = /í˜ˆí†µ' ë¬¸ì œë¥¼ ë‘ê³  ì˜ê²¬ì´ ê°•í•˜ê²Œ ëŒ€ë¦½í–ˆìŠµë‹ˆë‹¤/;
            if (bloodConflictRegex.test(sentence) && delta > -1){
              delta = -1;
            }
          }catch(e){}

          if (!delta) delta = 1;

          changeAffinity(aId, bId, delta);
          const affix = formatAffinityTag(delta);
          let relLabel = "";
          let flavor = "";
          if (Math.random() < 0.2){
            relLabel = formatPairRelationLabel(aId, bId);
            if (relLabel){
              flavor = makeRelationFlavorSentence(A, B, aId, bId);
            }
          }
          const line = `${relLabel ? relLabel + ' ' : ''}${flavor ? flavor : sentence} ${affix}`;
          lines.push(line);
        } else {
          const namesTopic = joinNamesForGroupSubject(g);
          const gg = (SEASON_GROUP_GENERAL[key] || []);
          let sentence = "";
          if (gg.length){
            const f = gg[0];
            sentence = f(namesTopic);
          } else {
            sentence = `${namesTopic} í•¨ê»˜ ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
          }

          // ê·¸ë£¹ ì´ë²¤íŠ¸ë„ ê´€ê³„ì— ì˜í–¥ì„ ì£¼ë˜, ê¸°ë³¸ì€ ì•½í•œ +í˜¸ê° / ë“œë¬¼ê²Œ -í˜¸ê°
          let groupDelta = 1;

          try{
            // ê·¸ë£¹ ì•ˆì— 'ê°ˆë“± ì¡°í•©'ì´ ì–¼ë§ˆë‚˜ ì„ì—¬ ìˆëŠ”ì§€ ëŒ€ëµ ê³„ì‚°
            const arr = g.map(id => characters.find(c=>c.id===id) || {});
            const pairs = [];
            for (let i=0;i<arr.length;i++){
              for (let j=i+1;j<arr.length;j++){
                pairs.push([arr[i],arr[j]]);
              }
            }

            let conflictScore = 0;
            let pairCount = 0;

            const has = (cs, t)=>Array.isArray(cs.traits) && cs.traits.includes(t);
            const isBrave = (cs)=>Array.isArray(cs.traits) && cs.traits.some(x=>["í‰ë“±ì£¼ì˜","ë°˜ê¶Œìœ„","ë‚™ì²œì "].includes(x));
            const isHier = (cs)=>Array.isArray(cs.traits) && cs.traits.some(x=>["í˜ˆí†µì¤‘ì‹œ","ê¶Œìœ„ì¡´ì¤‘"].includes(x));

            pairs.forEach(([ca, cb]) => {
              if (!ca.id || !cb.id) return;
              pairCount++;

              const ba = ca.blood || "";
              const bb = cb.blood || "";

              if ((ba==="ë¨¸ê¸€ íƒœìƒ" && isHier(cb)) || (bb==="ë¨¸ê¸€ íƒœìƒ" && isHier(ca))){
                conflictScore += 1.5;
              }
              if ((has(ca,"ì´ìƒì£¼ì˜") && has(cb,"í˜„ì‹¤ì£¼ì˜")) || (has(ca,"í˜„ì‹¤ì£¼ì˜") && has(cb,"ì´ìƒì£¼ì˜"))){
                conflictScore += 1.0;
              }
              if ((has(ca,"í‰ë“±ì£¼ì˜") && has(cb,"í˜ˆí†µì¤‘ì‹œ")) || (has(ca,"í˜ˆí†µì¤‘ì‹œ") && has(cb,"í‰ë“±ì£¼ì˜"))){
                conflictScore += 1.2;
              }
              if ((has(ca,"ê¶Œìœ„ì¡´ì¤‘") && isBrave(cb)) || (has(cb,"ê¶Œìœ„ì¡´ì¤‘") && isBrave(ca))){
                conflictScore += 1.0;
              }
              if ((has(ca,"ë³‘ì•½") && has(cb,"ìš´ë™ê´‘")) || (has(ca,"ìš´ë™ê´‘") && has(cb,"ë³‘ì•½"))){
                conflictScore += 0.6;
              }
              if ((has(ca,"ì¶©ë™ì ") && has(cb,"ì‹ ì¤‘í•¨")) || (has(ca,"ì‹ ì¤‘í•¨") && has(cb,"ì¶©ë™ì "))){
                conflictScore += 0.8;
              }
              if ((has(ca,"ëƒ‰ì •í•¨") && has(cb,"ê°ì„±ì ")) || (has(ca,"ê°ì„±ì ") && has(cb,"ëƒ‰ì •í•¨"))){
                conflictScore += 0.8;
              }
            });

            const avgConflict = pairCount ? conflictScore / pairCount : 0;

            // ê¸°ë³¸ì€ +1, ê°ˆë“±ì´ ê½¤ ë§ì€ ì¡°í•©ì´ë©´ ë‚®ì€ í™•ë¥ ë¡œ -1
            if (avgConflict > 0.9 && Math.random() < 0.4){
              groupDelta = -1;
            } else if (avgConflict > 0.4 && Math.random() < 0.25){
              groupDelta = -1;
            } else {
              groupDelta = 1;
            }
          }catch(e){
            groupDelta = 1;
          }

          // ì¦ê±°ìš´ ë¶„ìœ„ê¸°ì˜ ê·¸ë£¹ ì´ë²¤íŠ¸ëŠ” -í˜¸ê°ë„ë¡œ ë–¨ì–´ì§€ì§€ ì•Šë„ë¡ ë³´í˜¸
          // íŠ¹íˆ "ë– ë“¤ì©í•˜ê²Œ ì›ƒì—ˆìŠµë‹ˆë‹¤" ë¥˜ì˜ ì¥ë©´ì€ ìµœì†Œ +1ë¡œ ê³ ì •í•œë‹¤.
          try{
            const cheerfulGroupRegex = /(ë– ë“¤ì©í•˜ê²Œ ì›ƒì—ˆìŠµë‹ˆë‹¤|ìƒˆ í•™ê¸° ì´ì•¼ê¸°ë¥¼ ë‚˜ëˆ„ë©° ë– ë“¤ì©í•˜ê²Œ ì›ƒì—ˆìŠµë‹ˆë‹¤|ë‚œë¡œ ì•ì— ëª¨ì—¬ ì„œë¡œì˜ ì‹œí—˜ ëŒ€ë¹„ ê³„íšì„ ê³µìœ í–ˆìŠµë‹ˆë‹¤|ë´„ë°”ëŒì´ ë¶€ëŠ” êµì •ì„ í•¨ê»˜ ë›°ì–´ë‹¤ë…”ìŠµë‹ˆë‹¤|ì‹œì›í•œ ê³µìš©ì‹¤ì— ëª¨ì—¬ í•œê°€ë¡œìš´ ì˜¤í›„ë¥¼ ë³´ëƒˆìŠµë‹ˆë‹¤)/;
            if (cheerfulGroupRegex.test(sentence) && groupDelta < 1){
              groupDelta = 1;
            }
          }catch(e){}

          // ê·¸ë£¹ ì „ì²´ì— ê°™ì€ í¬ê¸°ì˜ ë¯¸ì„¸í•œ í˜¸ê°ë„ ë³€í™”ë¥¼ ì ìš© (ë„ˆë¬´ í¬ì§€ ì•Šê²Œ)
          const deltaForPairs = groupDelta;

          g.forEach((id1, idx1) => {
            for (let idx2 = idx1+1; idx2 < g.length; idx2++){
              const id2 = g[idx2];
              changeAffinity(id1, id2, deltaForPairs);
            }
          });

          const groupTag = formatAffinityTag(groupDelta);
          lines.push(groupTag ? `${sentence} ${groupTag}` : sentence);
        }
      });

      } // end of ì¼ë°˜ í•™ê¸° ë¡œê·¸ ë¶„ê¸° (O.W.L ì‹œí—˜ì¼ì´ ì•„ë‹Œ ê²½ìš°)

      story.seasonTurn += 1;

      const seasonName = SEASON_NAME_MAP[key] || "ê°€ì„";
      const year = story.currentYear || 1;
      const seasonEmojiMap = { autumn:"ğŸ‚", winter:"â„ï¸", spring:"ğŸŒ¸", summer:"â˜€ï¸" };
      const seasonEmoji = seasonEmojiMap[key] || "ğŸ‚";
      const isOwlTitle = (story.currentYear === 5 && key === "summer" && story.seasonTurn === maxPerSeason);
      const suffix = isOwlTitle ? " O.W.L" : "";
      const title = `${seasonName} ${seasonEmoji} (${story.seasonTurn}/${maxPerSeason})${suffix}`;
      story.log.push({
        turn: 2000 + (year*100) + (story.seasonIndex*10) + story.seasonTurn,
        title,
        meta: `${year}í•™ë…„`,
        lines
      });

      saveAll();
      renderLog();
      updateStoryHeader();
    }
    

    function generateVacationTurn(){
      if (!characters.length){
        showToast("ìºë¦­í„°ë¥¼ ë¨¼ì € ë§Œë“¤ì–´ì¤˜!");
        return;
      }
      const maxVac = 3;
      if (story.vacationTurn >= maxVac){
        showToast("ë°©í•™ ì´ì•¼ê¸°ëŠ” ì´ë¯¸ ì¶©ë¶„íˆ ì§„í–‰ë˜ì—ˆìŠµë‹ˆë‹¤.");
        return;
      }

      const ids = characters.map(c=>c.id);
      const lines = [];

      // Helper: ì´ë¦„/ì†ì„±/í˜ˆí†µ ê°€ì ¸ì˜¤ê¸°
      const byId = {};
      characters.forEach(c=> byId[c.id] = c);
      const nameOf = (id)=> (byId[id] ? byId[id].name : "");
      const traitsOfId = (id)=> (byId[id] && Array.isArray(byId[id].traits)) ? byId[id].traits : traitsOf(id) || [];
      const bloodOfId = (id)=> (byId[id] && byId[id].blood) ? byId[id].blood : "";
      const featsOfId = (id)=> (byId[id] && Array.isArray(byId[id].feats)) ? byId[id].feats : [];

      const map = ensureAffinityMap();

      function isAcquaintance(aId,bId){
        const k = pairKey(aId,bId);
        const relKey = relations[k] || DEFAULT_REL;
        return (relKey === "aneun" || relKey === "friend" || relKey === "best" || relKey === "love");
      }
      function pick(arr){
        if (!arr || !arr.length) return null;
        return arr[Math.floor(Math.random()*arr.length)];
      }

      // ë°©í•™ í•œ í„´ì— ëª¨ë“  ìºë¦­í„°ê°€ í•œ ë²ˆì”© ë“±ì¥í•˜ë„ë¡ êµ¬ì„±
      const pool = ids.slice().sort(()=>Math.random()-0.5);
      const used = new Set();

      while (pool.length){
        const aId = pool.shift();
        if (used.has(aId)) continue;
        const A = nameOf(aId);
        const traitsA = traitsOfId(aId);
        const bloodA = bloodOfId(aId);

        // í¸ì§€ë¥¼ ë³´ë‚¼ ìˆ˜ ìˆëŠ” ìƒëŒ€ í›„ë³´ (ì•„ëŠ” ì‚¬ì´ + ì•„ì§ ë¯¸ì‚¬ìš©)
        const letterCandidates = pool.filter(bId=> !used.has(bId) && isAcquaintance(aId, bId));

        // 1) í¸ì§€/ë§Œë‚¨ ì´ë²¤íŠ¸ (ê°€ëŠ¥í•˜ë©´ 2ì¸ ë¬¶ìŒ)
        if (letterCandidates.length && Math.random() < 0.4){
          const bId = pick(letterCandidates);
          const B = nameOf(bId);
          const traitsB = traitsOfId(bId);
          const bloodB = bloodOfId(bId);

          let sentence = "";

          // ê¸°ë³¸ í¸ì§€Â·ë§Œë‚¨ ë¬¸ì¥
          // ì¼ë¶€ëŠ” ì§ì ‘ ë§Œë‚¨, ì¼ë¶€ëŠ” í¸ì§€ ìœ„ì£¼
          const letterModeRand = Math.random();
          const isLateVacation = (story.vacationTurn >= 2); // ë°©í•™ í›„ë°˜ë¶€ì¼ìˆ˜ë¡ ìƒˆí•™ê¸° ì´ì•¼ê¸° í™•ë¥  â†‘

          if (letterModeRand < 0.25){
            // ì‹œë‚´ ì¹´í˜ì—ì„œ ë§Œë‚¨
            sentence = `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} í•¨ê»˜ ì‹œë‚´ì˜ ì¹´í˜ì—ì„œ ì»¤í”¼ë¥¼ ë§ˆì‹œë©° ë°©í•™ ì´ì•¼ê¸°ë¥¼ ë‚˜ëˆ„ì—ˆìŠµë‹ˆë‹¤.`;
          } else if (letterModeRand < 0.5){
            // ë§ˆë²•ì‚¬ ê±°ë¦¬ë¥¼ í•¨ê»˜ ëŒì•„ë‹¤ë‹˜
            sentence = `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ì‹œë‚´ ë§ˆë²•ì‚¬ ê±°ë¦¬ë¥¼ í•¨ê»˜ ê±°ë‹ë©° ê°€ê²Œë“¤ì„ êµ¬ê²½í–ˆìŠµë‹ˆë‹¤.`;
          } else if (letterModeRand < 0.75 && isLateVacation){
            // ìƒˆí•™ê¸°ì— ëŒ€í•œ ê¸°ëŒ€ë¥¼ ë‚˜ëˆ„ëŠ” í¸ì§€
            sentence = `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ìƒˆ í•™ê¸°ì— ëŒ€í•œ ê¸°ëŒ€ê°ì„ ë‹´ì€ í¸ì§€ë¥¼ ì£¼ê³ ë°›ì•˜ìŠµë‹ˆë‹¤.`;
          } else {
            // ê¸°ë³¸ í¸ì§€ ë¬¸ì¥
            sentence = `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ë°©í•™ ë‚´ë‚´ í¸ì§€ë¥¼ ì£¼ê³ ë°›ìœ¼ë©° ì„œë¡œì˜ ì†Œì‹ì„ ë‚˜ëˆ„ì—ˆìŠµë‹ˆë‹¤.`;
          }

          // ê°ì„±ì /ì†”ì§í•œ ì„±ê²©
          if (traitsA.includes("ê°ì„±ì ") || traitsB.includes("ê°ì„±ì ") || traitsA.includes("ì†”ì§í•¨") || traitsB.includes("ì†”ì§í•¨")){
            if (Math.random() < 0.5){
              sentence = `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} í¸ì§€ ì†ì—ì„œ í‰ì†Œ ë§í•˜ì§€ ëª»í–ˆë˜ ì†ë§ˆìŒì„ í„¸ì–´ë†“ì•˜ìŠµë‹ˆë‹¤.`;
            }
          }

          // í˜ˆí†µ/ê°€ì¹˜ê´€ ëŒ€í™”
          const aEqual = traitsA.includes("í‰ë“±ì£¼ì˜");
          const bEqual = traitsB.includes("í‰ë“±ì£¼ì˜");
          const aBloodFocus = traitsA.includes("í˜ˆí†µì¤‘ì‹œ");
          const bBloodFocus = traitsB.includes("í˜ˆí†µì¤‘ì‹œ");
          const mixedBlood = (bloodA === "ë¨¸ê¸€ íƒœìƒ" && bloodB === "ìˆœí˜ˆ") || (bloodB === "ë¨¸ê¸€ íƒœìƒ" && bloodA === "ìˆœí˜ˆ");

          if (mixedBlood && (aEqual || bEqual || aBloodFocus || bBloodFocus) && Math.random() < 0.5){
            sentence = `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} í¸ì§€ ì†ì—ì„œ í˜ˆí†µê³¼ ë§ˆë²•ì‚¬ ì‚¬íšŒì— ëŒ€í•œ ìƒê°ì„ ì¡°ì‹¬ìŠ¤ëŸ½ê²Œ ì£¼ê³ ë°›ì•˜ìŠµë‹ˆë‹¤.`;
          }

          let delta = 1;
          // â˜… ì„±ê²©/í˜ˆí†µ ê¸°ë°˜ ìµœì¢… íŠœë‹
          try{
            const tunedAuto = tunePairAffinityForTraits(aId, bId, sentence, delta, "vacation");
            sentence = tunedAuto.sentence;
            delta = tunedAuto.delta;
          }catch(e){}

          if (!delta) delta = 1;

          changeAffinity(aId, bId, delta);
          const tag = formatAffinityTag(delta);
          lines.push(tag ? `${sentence} ${tag}` : sentence);

          used.add(aId);
          used.add(bId);
          // bIdë¥¼ poolì—ì„œë„ ì œê±°
          const idx = pool.indexOf(bId);
          if (idx >= 0) pool.splice(idx, 1);
          // í¸ì§€/ë§Œë‚¨ ì´ë²¤íŠ¸ê°€ ë°œìƒí•œ ê²½ìš°, ì´ í„´ì—ëŠ” aIdì— ëŒ€í•´ ì¶”ê°€ 1ì¸ ì´ë²¤íŠ¸ë¥¼ ë§Œë“¤ì§€ ì•ŠëŠ”ë‹¤.
          continue;
        }

        // 2) 1ì¸ ì´ë²¤íŠ¸ë“¤
        let sentence = "";
        const traits = traitsA;
        const blood = bloodA;
        const feats = featsOfId(aId);
        const hasT = (t)=> traits.includes(t);
        const hasF = (f)=> feats.includes(f);
        const pickOne = (arr)=> arr[Math.floor(Math.random()*arr.length)];
          const useFeatLogs = Math.random() < 0.33;  // ë°©í•™ íŠ¹ì„± ë¡œê·¸ëŠ” 70% ì •ë„ë§Œ ì‚¬ìš©


        // ê°€ë¬¸ì˜ í›„ê³„ì ê´€ë ¨ íŠ¹ì„± ë¡œê·¸
        if (!sentence && useFeatLogs && hasF("ê°€ë¬¸ì˜ í›„ê³„ì") && hasT("ê¶Œìœ„ì¡´ì¤‘")){
          sentence = `[ê°€ë¬¸ì˜ í›„ê³„ì] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì§‘ì•ˆ ì–´ë¥¸ë“¤ê³¼ í•¨ê»˜ ê°€ë¬¸ì˜ ì „í†µê³¼ ì±…ì„ì— ëŒ€í•´ ì´ì•¼ê¸°ë¥¼ ë‚˜ëˆ„ë©°, ìì‹ ì´ ì´ ê¸¸ì„ ì´ì–´ê°ˆ ê²ƒì´ë¼ ë§ˆìŒì„ ë‹¤ì¡ì•˜ìŠµë‹ˆë‹¤.`;
        } else if (!sentence && useFeatLogs && hasF("ê°€ë¬¸ì˜ í›„ê³„ì")){
          sentence = `[ê°€ë¬¸ì˜ í›„ê³„ì] ::${A};;${pickJosa(A,"ì€ëŠ”")} ë°©í•™ ë‚´ë‚´ ì´ì–´ì§€ëŠ” í›„ê³„ì êµìœ¡ì„ ë°›ìœ¼ë©°, ìì‹ ì—ê²Œ ìŸì•„ì§€ëŠ” ê¸°ëŒ€ì™€ ë¶€ë‹´ì„ ë™ì‹œì— ëŠê¼ˆìŠµë‹ˆë‹¤.`;
        }

        // ë¶€ìœ í•œ ì§‘ì•ˆ ê´€ë ¨ íŠ¹ì„± ë¡œê·¸
        if (!sentence && useFeatLogs && hasF("ë¶€ìœ í•œ ì§‘ì•ˆ") && hasT("ê¶Œìœ„ì¡´ì¤‘")){
          sentence = `[ë¶€ìœ í•œ ì§‘ì•ˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì§‘ì•ˆì—ì„œ ì¤€ë¹„í•œ ì—°íšŒì™€ ëª¨ì„ì— ì°¨ë¶„íˆ ì°¸ì„í•˜ë©°, ìì‹ ì´ ëˆ„ë¦¬ëŠ” í™˜ê²½ì„ ë‹¹ì—°í•˜ê²Œ ë°›ì•„ë“¤ì´ê¸° ì‹œì‘í–ˆìŠµë‹ˆë‹¤.`;
        } else if (!sentence && useFeatLogs && hasF("ë¶€ìœ í•œ ì§‘ì•ˆ") && (hasT("ë‚™ì²œì ") || hasT("ì‚¬êµì "))){
          sentence = `[ë¶€ìœ í•œ ì§‘ì•ˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} í™”ë ¤í•œ ì—°íšŒì™€ íŒŒí‹° ì†ì—ì„œ ì›ƒê³  ë– ë“¤ë©°, ë°©í•™ ë™ì•ˆì˜ ì‹œê°„ì„ ì˜¨ì „íˆ ì¦ê²¼ìŠµë‹ˆë‹¤.`;
        } else if (!sentence && useFeatLogs && hasF("ë¶€ìœ í•œ ì§‘ì•ˆ")){
          sentence = `[ë¶€ìœ í•œ ì§‘ì•ˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ë„“ì€ ì €íƒ ê³³ê³³ì„ ê±°ë‹ë©°, ìì‹ ì—ê²Œ ì£¼ì–´ì§„ í™˜ê²½ê³¼ ì•ìœ¼ë¡œì˜ ê¸°ëŒ€ë¥¼ ê³±ì”¹ëŠ” ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
        }

        // ë³‘ì•½ íŠ¹ì„± ë¡œê·¸
        if (!sentence && useFeatLogs && hasF("ë³‘ì•½")){
          const pool = [
            `[ë³‘ì•½] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì‚¬ì†Œí•œ ê°ê¸°ì— ê±¸ë ¤ë„ ì˜¤ë˜ ì•“ëŠ” í¸ì´ë¼, ë°©í•™ ë™ì•ˆì—ë„ ê±´ê°• ê´€ë¦¬ë¥¼ ìµœìš°ì„ ìœ¼ë¡œ ì±™ê²¼ìŠµë‹ˆë‹¤.`,
            `[ë³‘ì•½] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì§‘ ì•ˆì—ì„œ ì¡°ìš©íˆ ì‹œê°„ì„ ë³´ë‚´ë©°, ë¬´ë¦¬í•˜ì§€ ì•ŠëŠ” ì„ ì—ì„œ ì±…ì„ ì½ê±°ë‚˜ ì°½ë°–ì„ ë°”ë¼ë³´ëŠ” ë‚ ì´ ë§ì•˜ìŠµë‹ˆë‹¤.`,
            `[ë³‘ì•½] ::${A};;${pickJosa(A,"ì€ëŠ”")} ë©°ì¹  ë™ì•ˆ ì‹¬í•œ ê°ê¸°ì— ê±¸ë ¤ ì•“ì•„ëˆ„ì› ê³ , íšŒë³µëœ ë’¤ì—ì„œì•¼ ë‚¨ì€ ë°©í•™ì„ ì²œì²œíˆ ì¦ê¸¸ ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤.`
          ];
          sentence = pickOne(pool);
        }

        // ìš´ë™ê´‘ íŠ¹ì„± ë¡œê·¸
        if (!sentence && useFeatLogs && hasF("ìš´ë™ê´‘")){
          const pool = [
            `[ìš´ë™ê´‘] ::${A};;${pickJosa(A,"ì€ëŠ”")} ë°©í•™ ë™ì•ˆì—ë„ ìƒˆë²½ë¶€í„° ìš´ë™ì¥ì´ë‚˜ ë§ˆë‹¹ì„ ë›°ì–´ë‹¤ë‹ˆë©°, ëª¸ì„ ì›€ì§ì´ì§€ ì•Šê³ ëŠ” ê²¬ë””ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.`,
            `[ìš´ë™ê´‘] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì§‘ ê·¼ì²˜ì—ì„œ ë¹—ìë£¨ ë¹„í–‰ ì—°ìŠµì„ í•˜ë‹¤ê°€, ê°€ì¡±ë“¤ì—ê²Œ ë„ˆë¬´ ë†’ì´ ì˜¬ë¼ê°€ì§€ ë§ë¼ë©° ê±±ì •ì„ í•œê» ë“¤ì—ˆìŠµë‹ˆë‹¤.`,
            `[ìš´ë™ê´‘] ::${A};;${pickJosa(A,"ì€ëŠ”")} ë°©í•™ ë‚´ë‚´ ìš´ë™ ê³„íší‘œë¥¼ ë§Œë“¤ì–´ ì‹¤ì²œí•˜ë©°, ìƒˆ í•™ê¸° í€´ë””ì¹˜ ì‹œì¦Œì„ ìœ„í•´ ëª¸ì„ ë§Œë“¤ì–´ ê°”ìŠµë‹ˆë‹¤.`
          ];
          sentence = pickOne(pool);
        }

        // ì²œì¬ íŠ¹ì„± ë¡œê·¸
        if (!sentence && useFeatLogs && hasF("ì²œì¬")){
          const pool = [
            `[ì²œì¬] ::${A};;${pickJosa(A,"ì€ëŠ”")} ë°©í•™ ê³¼ì œë¥¼ ì¼ì°Œê°ì¹˜ ëë‚´ ë²„ë¦¬ê³ , í˜¼ì ê³ ê¸‰ ë§ˆë²•ì„œì™€ ì—°êµ¬ì„œë¥¼ ì½ìœ¼ë©° ìƒˆë¡œìš´ ì£¼ë¬¸ì„ ì—°êµ¬í–ˆìŠµë‹ˆë‹¤.`,
            `[ì²œì¬] ::${A};;${pickJosa(A,"ì€ëŠ”")} ê°€ì¡±ë“¤ì´ ì´í•´í•˜ì§€ ëª»í•˜ëŠ” ë‚œí•´í•œ ë§ˆë²• ì´ë¡ ì„ í˜¼ìì„œ ì •ë¦¬í•˜ë©°, ì˜¤íˆë ¤ ì‰¬ëŠ” ì‹œê°„ë³´ë‹¤ ê³µë¶€í•˜ëŠ” ì‹œê°„ì´ ë” ì¦ê±°ì› ìŠµë‹ˆë‹¤.`,
            `[ì²œì¬] ::${A};;${pickJosa(A,"ì€ëŠ”")} ë°©í•™ ì¤‘ì—ë„ ìŠ¤ìŠ¤ë¡œ ì‹œí—˜ ë¬¸ì œë¥¼ ë§Œë“¤ì–´ í’€ì–´ ë³´ë©°, ë‹¤ìŒ í•™ê¸°ë¥¼ ëŒ€ë¹„í•œ ê³µë¶€ë¥¼ ê²Œì„ì²˜ëŸ¼ ì¦ê²¼ìŠµë‹ˆë‹¤.`
          ];
          sentence = pickOne(pool);
        }

        // ì±…ë²Œë ˆ íŠ¹ì„± ë¡œê·¸
        if (!sentence && useFeatLogs && hasF("ì±…ë²Œë ˆ")){
          const pool = [
            `[ì±…ë²Œë ˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì§‘ ê·¼ì²˜ ì„œì ê³¼ ë„ì„œê´€ì„ ì „ë¶€ ë’¤ì§€ë©°, ì½ê³  ì‹¶ë˜ ë§ˆë²• ì„œì ì„ í•œ ì•„ë¦„ ì•ˆê³  ëŒì•„ì™”ìŠµë‹ˆë‹¤.`,
            `[ì±…ë²Œë ˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ë°©í•™ ë‚´ë‚´ ì°½ê°€ì— ì•‰ì•„ ì±…ì„ ì½ì—ˆì§€ë§Œ, ì½ì€ ë§Œí¼ ìƒˆë¡œìš´ ì±… ëª©ë¡ë„ ëì—†ì´ ëŠ˜ì–´ë§Œ ê°”ìŠµë‹ˆë‹¤.`,
            `[ì±…ë²Œë ˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ê°€ì¡± ì—¬í–‰ì§€ì—ì„œë„ ê´€ê´‘ë³´ë‹¤ëŠ” ì¡°ìš©í•œ ì„œì¬ë‚˜ ì„œì ì— ë” ê´€ì‹¬ì„ ë³´ì´ë©°, ëŠ˜ ì±…ì„ í•œ ê¶Œ ì´ìƒ ë“¤ê³  ë‹¤ë…”ìŠµë‹ˆë‹¤.`
          ];
          sentence = pickOne(pool);
        }

        // ë¦¬ë”ì‹­ íŠ¹ì„± ë¡œê·¸
        if (!sentence && useFeatLogs && hasF("ë¦¬ë”ì‹­")){
          const pool = [
            `[ë¦¬ë”ì‹­] ::${A};;${pickJosa(A,"ì€ëŠ”")} ë°©í•™ ë™ì•ˆì—ë„ ì¹œêµ¬ë“¤ê³¼ì˜ ëª¨ì„ì„ ì£¼ë„í•˜ë©°, ì¼ì •ê³¼ ì¥ì†Œë¥¼ ì •ë¦¬í•´ ëª¨ë‘ê°€ ì¦ê¸¸ ìˆ˜ ìˆëŠ” ìë¦¬ë¥¼ ë§ˆë ¨í–ˆìŠµë‹ˆë‹¤.`,
            `[ë¦¬ë”ì‹­] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì§‘ì—ì„œ ë™ìƒë“¤ì´ë‚˜ ì‚¬ì´Œë“¤ì„ ì±™ê¸°ë©°, ìì—°ìŠ¤ëŸ½ê²Œ ë†€ì´ë‚˜ ê²Œì„ì˜ ê·œì¹™ì„ ì •í•˜ê³  ë¶„ìœ„ê¸°ë¥¼ ì´ëŒì—ˆìŠµë‹ˆë‹¤.`,
            `[ë¦¬ë”ì‹­] ::${A};;${pickJosa(A,"ì€ëŠ”")} ë°©í•™ ê³¼ì œë¥¼ ë¯¸ë¤„ ë‘ë ¤ëŠ” ì¹œêµ¬ë“¤ì—ê²Œ ì—°ë½í•´, í•¨ê»˜ ê³µë¶€í•  ì‹œê°„ì„ ì¡ì•„ ì„œë¡œë¥¼ ë¶™ì¡ì•„ ì£¼ì—ˆìŠµë‹ˆë‹¤.`
          ];
          sentence = pickOne(pool);
        }

        // ìœ ë¦¬ ë©˜íƒˆ íŠ¹ì„± ë¡œê·¸
        if (!sentence && useFeatLogs && hasF("ìœ ë¦¬ ë©˜íƒˆ")){
          const pool = [
            `[ìœ ë¦¬ ë©˜íƒˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ê°€ì¡±ì´ë‚˜ ì¹œêµ¬ì˜ ì‚¬ì†Œí•œ ë§ì—ë„ ë§ˆìŒì´ ì‰½ê²Œ í”ë“¤ë ¤, ë°© ì•ˆì— í˜¼ì í‹€ì–´ë°•í˜€ ìŒì•…ì„ ë“¤ìœ¼ë©° ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`,
            `[ìœ ë¦¬ ë©˜íƒˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ë°©í•™ ìˆ™ì œë¥¼ ë‘ê³  ê¾¸ì¤‘ì„ ë“¤ì€ ë’¤ í•œì°¸ ë™ì•ˆ ìš°ìš¸í•´í•˜ë‹¤ê°€, ê²¨ìš° ë§ˆìŒì„ ë‹¤ì¡ê³  ë‹¤ì‹œ ì±…ìƒ ì•ì— ì•‰ì•˜ìŠµë‹ˆë‹¤.`,
            `[ìœ ë¦¬ ë©˜íƒˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ìƒˆ í•™ê¸°ë¥¼ ê±±ì •í•˜ëŠ” ë§ˆìŒì´ ì»¤ì ¸, ê´œíˆ ë¶ˆì•ˆí•œ ìƒìƒë“¤ì„ í•˜ë©° ë°¤ëŠ¦ê²Œê¹Œì§€ ì ë“¤ì§€ ëª»í•˜ëŠ” ë‚ ì´ ë§ì•˜ìŠµë‹ˆë‹¤.`
          ];
          sentence = pickOne(pool);
        }

        // ë°˜í•­ì•„ íŠ¹ì„± ë¡œê·¸
        if (!sentence && useFeatLogs && hasF("ë°˜í•­ì•„")){
          const pool = [
            `[ë°˜í•­ì•„] ::${A};;${pickJosa(A,"ì€ëŠ”")} ì§‘ì•ˆì˜ ê·œì¹™ì„ ì‚´ì§ ì–´ê¸°ë©° ë°¤ëŠ¦ê²Œê¹Œì§€ ë§ˆì„ì„ ëŒì•„ë‹¤ë‹ˆë‹¤ê°€, ë“¤í‚¤ì§€ ì•Šê²Œ ëª°ë˜ ë°©ìœ¼ë¡œ ëŒì•„ì™”ìŠµë‹ˆë‹¤.`,
            `[ë°˜í•­ì•„] ::${A};;${pickJosa(A,"ì€ëŠ”")} ë°©í•™ ë‚´ë‚´ ê³µë¶€í•˜ë¼ëŠ” ì–´ë¥¸ë“¤ì˜ ì”ì†Œë¦¬ë¥¼ í”¼í•´, ì¥ë‚œê³¼ ëª¨í—˜ìœ¼ë¡œ ê°€ë“í•œ í•˜ë£¨ë“¤ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`,
            `[ë°˜í•­ì•„] ::${A};;${pickJosa(A,"ì€ëŠ”")} êµ³ì´ ë§ë¦¬ì§€ ì•Šì•„ë„ ë  ì¼ì— ê³ ì§‘ì„ ë¶€ë¦¬ë©°, ìê¸° ë°©ì‹ëŒ€ë¡œ í•˜ë£¨ë¥¼ ë³´ë‚´ê² ë‹¤ê³  ë§ˆìŒë¨¹ì—ˆìŠµë‹ˆë‹¤.`
          ];
          sentence = pickOne(pool);
        }

        // í–‰ìš´ì•„ íŠ¹ì„± ë¡œê·¸
        if (!sentence && useFeatLogs && hasF("í–‰ìš´ì•„")){
          const pool = [
            `[í–‰ìš´ì•„] ::${A};;${pickJosa(A,"ì€ëŠ”")} ìš°ì—°íˆ ë“¤ì–´ê°„ ê°€ê²Œì—ì„œ ë§ˆì§€ë§‰ ë‚¨ì€ í¬ê·€í•œ ë§ˆë²• ë¬¼ê±´ì„ í—ê°’ì— ì–»ì–´, ìì‹ ì´ ì–¼ë§ˆë‚˜ ìš´ì´ ì¢‹ì€ì§€ ìƒˆì‚¼ ëŠê¼ˆìŠµë‹ˆë‹¤.`,
            `[í–‰ìš´ì•„] ::${A};;${pickJosa(A,"ì€ëŠ”")} íŠ¹ë³„íˆ ë…¸ë ¥í•˜ì§€ ì•Šì•˜ëŠ”ë°ë„ ë°©í•™ ê³¼ì œì—ì„œ ì¢‹ì€ í‰ê°€ë¥¼ ë°›ì•˜ë‹¤ëŠ” ì†Œì‹ì„ ë“£ê³ , ì–´ì©ì§€ ìš´ì´ ë”°ë¼ì£¼ëŠ” ê¸°ë¶„ì„ ì¦ê²¼ìŠµë‹ˆë‹¤.`,
            `[í–‰ìš´ì•„] ::${A};;${pickJosa(A,"ì€ëŠ”")} ê°€ì¡± ì—¬í–‰ ë„ì¤‘ ë‚ ì”¨ì™€ ì¼ì •ì´ ê¸°ê°€ ë§‰íˆê²Œ ë§ì•„ë–¨ì–´ì ¸, ê³„íšë³´ë‹¤ í›¨ì”¬ ì¦ê±°ìš´ ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`
          ];
          sentence = pickOne(pool);
        }

        // ìš´ë™ê´‘/ì²œì¬/ì±…ë²Œë ˆ/ë¦¬ë”ì‹­ ë“±ì´ ëª¨ë‘ ì—†ê³ ,
        // ìœ„ íŠ¹ì„± ë¡œê·¸ë“¤ì—ì„œë„ ë¬¸ì¥ì´ ì •í•´ì§€ì§€ ì•Šì€ ê²½ìš°ì—ë§Œ
        // ì•„ë˜ì˜ ê¸°ë³¸ ë°©í•™ 1ì¸ ì´ë²¤íŠ¸ë¡œ ë–¨ì–´ì§„ë‹¤.
// ìœ„ íŠ¹ì„± ë¡œê·¸ê°€ ì„ íƒë˜ì§€ ì•Šì•˜ë‹¤ë©´ â†’ ê¸°ì¡´ ë°©í•™ 1ì¸ ì´ë²¤íŠ¸ ì‚¬ìš©
        if (!sentence){
          // ìˆœí˜ˆ í•œì •: í›„ê³„ì êµìœ¡ (í˜ˆí†µ + ê°€ì¡± ì¤‘ì‹¬ ì´ì•¼ê¸°)
          if (blood === "ìˆœí˜ˆ" && Math.random() < 0.4){
            sentence = `[ìˆœí˜ˆ] ::${A};;${pickJosa(A,"ì€ëŠ”")} ë°©í•™ ë™ì•ˆ ì§‘ì•ˆ ì–´ë¥¸ë“¤ê³¼ ì§‘ì•ˆì˜ ì—­ì‚¬ì™€ ì „í†µì— ëŒ€í•œ ì´ì•¼ê¸°ë¥¼ ë“¤ìœ¼ë©° ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`;
            if (hasT("í‰ë“±ì£¼ì˜") || hasT("ë°˜ê¶Œìœ„")){
              sentence = sentence.replace("ë³´ëƒˆìŠµë‹ˆë‹¤.", "ë³´ë‚´ë©°, ìì‹ ì´ ë¯¿ëŠ” ê°€ì¹˜ì™€ ì§‘ì•ˆì˜ ìƒê° ì‚¬ì´ì—ì„œ ë¯¸ë¬˜í•œ ê´´ë¦¬ë¥¼ ëŠê¼ˆìŠµë‹ˆë‹¤.");
            } else if (hasT("í˜ˆí†µì¤‘ì‹œ") || hasT("ê·œìœ¨ ì¤‘ì‹œ")){
              sentence = sentence.replace("ë³´ëƒˆìŠµë‹ˆë‹¤.", "ë³´ë‚´ë©°, ì§‘ì•ˆì˜ ê¸°ëŒ€ë¥¼ ìì—°ìŠ¤ëŸ½ê²Œ ìì‹ ì˜ ì—­í• ë¡œ ë°›ì•„ë“¤ì´ê¸° ì‹œì‘í–ˆìŠµë‹ˆë‹¤.");
            }
          } else {
            // ê°€ì¡±ê³¼ í•¨ê»˜ ë³´ë‚´ëŠ” ì¼ë°˜ ë°©í•™ ë¡œê·¸ë“¤ë§Œ ì‚¬ìš©
            // ê°€ì¡±ê³¼ í•¨ê»˜ ë³´ë‚´ëŠ” ì¼ë°˜ ë°©í•™ ë¡œê·¸ë“¤ë§Œ ì‚¬ìš© (ë‹¤ì–‘í•œ ë²„ì „ìœ¼ë¡œ ì„ê¸°)
            const pool = [];
            pool.push(`::${A};;${pickJosa(A,"ì€ëŠ”")} ê°€ì¡±ë“¤ê³¼ í•¨ê»˜ ì§‘ì—ì„œ ì¡°ìš©íˆ ì´ì•¼ê¸°ë¥¼ ë‚˜ëˆ„ë©° ë°©í•™ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`);
            pool.push(`::${A};;${pickJosa(A,"ì€ëŠ”")} ê°€ì¡±ë“¤ê³¼ ê°„ë‹¨í•œ ìš”ë¦¬ë¥¼ í•´ ë¨¹ê³ , ê±°ì‹¤ì—ì„œ í•œê°€ë¡­ê²Œ ì‹œê°„ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`);
            pool.push(`::${A};;${pickJosa(A,"ì€ëŠ”")} ê°€ì¡±ë“¤ê³¼ ë§ˆë²• ì‹ ë¬¸ê³¼ ë¨¸ê¸€ ì‹ ë¬¸ì„ ë²ˆê°ˆì•„ ì½ìœ¼ë©° ì„œë¡œì˜ ìƒê°ì„ ë‚˜ëˆ´ìŠµë‹ˆë‹¤.`);
            pool.push(`::${A};;${pickJosa(A,"ì€ëŠ”")} ê°€ì¡±ë“¤ê³¼ ë™ë„¤ë¥¼ ì‚°ì±…í•˜ê±°ë‚˜, ì‘ì€ ë§ˆì„ ê°€ê²Œë“¤ì„ êµ¬ê²½í•˜ë©° ì—¬ìœ ë¡œìš´ í•˜ë£¨ë¥¼ ë³´ëƒˆìŠµë‹ˆë‹¤.`);

            if (hasT("í™œë°œí•¨") || hasT("ì‚¬êµì ")){
              pool.push(`::${A};;${pickJosa(A,"ì€ëŠ”")} ì¹œì²™ë“¤ì„ ì°¨ë¡€ë¡œ ë§Œë‚˜ëŸ¬ ë‹¤ë‹ˆë©°, ì˜¤ëœë§Œì˜ ì¬íšŒë¥¼ ì¦ê²¼ìŠµë‹ˆë‹¤.`);
              pool.push(`::${A};;${pickJosa(A,"ì€ëŠ”")} ê°€ì¡±ë“¤ê³¼ ì§§ì€ ì—¬í–‰ì„ ë– ë‚˜, ìƒˆë¡œìš´ í’ê²½ê³¼ ë§ˆë²• ìƒì ì„ êµ¬ê²½í–ˆìŠµë‹ˆë‹¤.`);
            }
            if (hasT("ë‚´í–¥ì ") || hasT("ì±…ë²Œë ˆ")){
              pool.push(`::${A};;${pickJosa(A,"ì€ëŠ”")} ì§‘ì—ì„œ ì±…ì„ ì½ê±°ë‚˜ ìƒê°ì— ì ê¸°ë©° ì¡°ìš©í•œ ë°©í•™ì„ ë³´ëƒˆìŠµë‹ˆë‹¤.`);
              pool.push(`::${A};;${pickJosa(A,"ì€ëŠ”")} ìì‹ ë§Œì˜ ë°©ì—ì„œ ì¼ê¸°ì™€ ìŠ¤ì¼€ì¹˜ë¥¼ ë‚¨ê¸°ë©°, ì§€ë‚œ í•™ê¸°ë¥¼ ë˜ëŒì•„ë³´ëŠ” ì‹œê°„ì„ ê°€ì¡ŒìŠµë‹ˆë‹¤.`);
            }

            sentence = pool[Math.floor(Math.random()*pool.length)];
          }
}

      // ë°©í•™ 1ì¸ ì´ë²¤íŠ¸ì—ëŠ” í˜¸ê°ë„ íƒœê·¸ë¥¼ ë¶™ì´ì§€ ì•ŠëŠ”ë‹¤
      lines.push(sentence);
        used.add(aId);
      }

      const year = story.currentYear || 0;
      story.vacationTurn += 1;
      const title = `ë°©í•™ (${story.vacationTurn}/${maxVac})`;
      story.log.push({
        turn: 3000 + (year*100) + story.vacationTurn,
        title,
        meta: `${year}í•™ë…„ ë°©í•™`,
        lines
      });

      saveAll();
      renderLog();
      updateStoryHeader();
    }
    function generateTrainTurn(){
      if (characters.length < 2){
        showToast("ìŠ¤í† ë¦¬ëŠ” ìºë¦­í„° 2ëª… ì´ìƒë¶€í„° ì‹œì‘ë©ë‹ˆë‹¤!");
        return;
      }
      if (story.trainTurn >= TRAIN_TURNS_MAX){
        showToast("ì—´ì°¨ íŒŒíŠ¸ëŠ” 5íšŒë¡œ ë!");
        return;
      }

      const ids = characters.map(c=>c.id);
      const groups = makeGroups(ids);

      // ì—´ì°¨ì—ì„œ í•¨ê»˜ ë“±ì¥í•œ ìºë¦­í„°ë“¤ì€ ìµœì†Œí•œ 'ì•„ëŠ” ì‚¬ì´'ë¡œ ì„¤ì •
      groups.forEach(g => ensureGroupAcquaintances(g));

      const lines = [];
      groups.forEach(g=>{
        if (g.length === 1){
          const id = g[0];
          const A = nameOf(id);
          const base = pick(SOLO_TEMPLATES)(A);
          // ì—´ì°¨ ë¡œê·¸ì—ëŠ” MBTI/ì„±ê²©/í˜ˆí†µ ë“±ì˜ íƒœê·¸ë¥¼ ë¶™ì´ì§€ ì•ŠëŠ”ë‹¤
          const line = base;
          lines.push(line);
        } else if (g.length === 2){
          const [aId, bId] = g;
          const A = nameOf(aId), B = nameOf(bId);
          const aTraits = traitsOf(aId) || [];
          const bTraits = traitsOf(bId) || [];
          const aVal = aTraits.find(x=>VALUE_TRAITS.has(x));
          const bVal = bTraits.find(x=>VALUE_TRAITS.has(x));
          let template = pick(PAIR_TEMPLATES);
          let sentence = template(A,B);

          const rank = relRankBetween(aId, bId);
          let delta = 1; // ê¸°ë³¸ì€ ì†Œí­ +í˜¸ê°ë„

          // tiny adjustments
          if (rank === 0 && Math.random() < 0.22){
            sentence = `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ì–´ìƒ‰í•œ ë¶„ìœ„ê¸° ì†ì—ì„œ ì§§ê²Œ ì¸ì‚¬ë¥¼ ë‚˜ëˆ„ì—ˆìŠµë‹ˆë‹¤.`;
            delta = -1;
          } else if (rank >= 2 && Math.random() < 0.22){
            sentence = `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ìì—°ìŠ¤ëŸ½ê²Œ ëŒ€í™”ë¥¼ ì´ì–´ê°”ìŠµë‹ˆë‹¤.`;
            delta = 1;
          }

          // value clash hint (rare, ê´€ê³„ -)
          if (aVal && bVal && aVal !== bVal && Math.random() < 0.18){
            sentence = `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ${aVal}ì™€ ${bVal}ì— ëŒ€í•´ ì˜ê²¬ ì°¨ì´ë¥¼ ë“œëŸ¬ëƒˆìŠµë‹ˆë‹¤.`;
            delta = -1;
          }

          // â˜… ì„±ê²©/í˜ˆí†µ ê¸°ë°˜ ìµœì¢… íŠœë‹
          try{
            const tunedAuto = tunePairAffinityForTraits(aId, bId, sentence, delta, "auto");
            sentence = tunedAuto.sentence;
            delta = tunedAuto.delta;
          }catch(e){}

          if (!delta) delta = 1;

          changeAffinity(aId, bId, delta);
          const affix = formatAffinityTag(delta);
          let relLabel = "";
          let flavor = "";
          if (Math.random() < 0.2){
            relLabel = formatPairRelationLabel(aId, bId);
            if (relLabel){
              flavor = makeRelationFlavorSentence(A, B, aId, bId);
            }
          }
          const line = `${relLabel ? relLabel + ' ' : ''}${flavor ? flavor : sentence} ${affix}`;
          lines.push(line);
        } else {
          const [aId, bId, cId] = g;
          const A = nameOf(aId), B = nameOf(bId), C = nameOf(cId);
          const sentence = pick(TRIO_TEMPLATES)(A,B,C);
          // íŠ¸ë¦¬ì˜¤ì—ì„œëŠ” ëŒ€í‘œ aId ê¸°ì¤€ìœ¼ë¡œ íƒœê·¸, ì„¸ ìŒ ëª¨ë‘ ì‚´ì§ +
          changeAffinity(aId, bId, 1);
          changeAffinity(aId, cId, 1);
          changeAffinity(bId, cId, 1);
          const affix = formatAffinityTag(1);
          let relLabel = "";
          if (Math.random() < 0.2){
            relLabel = formatPairRelationLabel(aId, bId);
          }
          const line = `${relLabel ? relLabel + ' ' : ''}${sentence} ${affix}`;
          lines.push(line);
        }
      });

      story.trainTurn += 1;
      const trainTitle = `í˜¸ê·¸ì™€íŠ¸í–‰ ì—´ì°¨ ğŸš‚ (${story.trainTurn}/${TRAIN_TURNS_MAX})`;
      story.log.push({
        turn: story.trainTurn,
        title: trainTitle,
        meta: `${groups.length}ê°œ ì¥ë©´`,
        lines
      });

      if (story.trainTurn >= TRAIN_TURNS_MAX){
        // keep phase as 'train' for routing; just mark done by trainTurn
      }

      saveAll();
      updateStoryHeader();
      renderLog();
      showToast("ë¡œê·¸ ìƒì„±!");
    }
function runGreatHallIntroSequence(){
      if (characters.length < 2) return;
      if (story.phase !== "great_hall") return;
      if (story.greatHallIntroDone) return;

      const lines = [
        "ë¬¸ì´ ì—´ë¦¬ì, ë”°ëœ»í•œ ë¹›ì´ ìŸì•„ì§€ë“¯ ë‚´ë¦°ë‹¤.",
        "ìˆ˜ë§ì€ ì´›ë¶ˆì´ ê³µì¤‘ì— ëœ¬ ì±„ë¡œ ìš°ë¦¬ë¥¼ ë°˜ê¸´ë‹¤.",
        "1991ë…„ 9ì›”, í˜¸ê·¸ì™€íŠ¸ì˜ ëŒ€ì—°íšŒì¥.",
        "...",
        "ê¸°ìˆ™ì‚¬ ë°°ì •ì‹."
      ];

      // remove any existing great hall block
      story.log = (story.log || []).filter(b => b.turn !== -1);
      const block = { turn: -1, meta: "ì¥ë©´ ì „í™˜", lines: [] };
      story.log.push(block);
      saveAll();
      updateStoryHeader();
      // Sorting panel visibility
      if (sortingPanel){
        sortingPanel.style.display = (story.phase === "great_hall" && story.sortingMode) ? "" : "none";
      }
      renderLog();

      let lineIdx = 0;

      // Great Hall ì „ìš© íƒ€ì´í•‘ í•¨ìˆ˜ (ë¡œì»¬)
      const typeLineLocal = (text, cb)=>{
        let i = 0;
        block.lines.push("");
        renderLog();
        // ë¹ˆ ë¬¸ìì—´ì´ë©´ ì• ë‹ˆë©”ì´ì…˜ ì—†ì´ ë¹ˆ ì¤„ë§Œ ì¶”ê°€
        if (!text || text.length === 0){
          block.lines.push("");
          renderLog();
          cb && cb();
          return;
        }
        const interval = setInterval(()=>{
          block.lines[block.lines.length - 1] += text[i];
          renderLog();
          i++;
          if (i >= text.length){
            clearInterval(interval);
            cb && cb();
          }
        }, text.length <= 3 ? 200 : 40);
      };

      const nextLine = ()=>{
        if (lineIdx >= lines.length){
          story.greatHallIntroDone = true;
          saveAll();
          updateStoryHeader();
          renderLog();
          showToast("ëŒ€ì—°íšŒì¥ ë„ì°©!");
          return;
        }
        typeLineLocal(lines[lineIdx], ()=>{
          lineIdx++;
          setTimeout(nextLine, 600);
        });
      };

      setTimeout(nextLine, 300);
    }

    
    function runArrivalSequence(){
      if (characters.length < 2) return;
      if (story.phase !== "arrival") return;
      if (story.arrivalDone) return;

      const lines = [
        "ëœì»¹ ëœì»¹â€¦",
        "ëœì»¹ ëœì»¹â€¦",
        "...",
        "ì—´ì°¨ê°€ ì²œì²œíˆ ë©ˆì¶˜ë‹¤.",
        "ê¿ˆì— ê·¸ë¦¬ë˜ ê³³ì—-"
      ];

      story.log = (story.log || []).filter(b => b.turn !== -2);
      const block = { turn: -2, meta: "ì¥ë©´ ì „í™˜", lines: [] };
      story.log.push(block);
      saveAll();
      updateStoryHeader();
      // Sorting panel visibility
      if (sortingPanel){
        sortingPanel.style.display = (story.phase === "great_hall" && story.sortingMode) ? "" : "none";
      }
      renderLog();

      let lineIdx = 0;

      const typeLineArrival = (text, cb)=>{
        let i = 0;
        block.lines.push("");
        renderLog();
        // ë¹ˆ ë¬¸ìì—´ì´ë©´ ì• ë‹ˆë©”ì´ì…˜ ì—†ì´ ë¹ˆ ì¤„ë§Œ ì¶”ê°€
        if (!text || text.length === 0){
          block.lines.push("");
          renderLog();
          cb && cb();
          return;
        }
        const interval = setInterval(()=>{
          block.lines[block.lines.length - 1] += text[i];
          renderLog();
          i++;
          if (i >= text.length){
            clearInterval(interval);
            cb && cb();
          }
        }, text.length <= 3 ? 200 : 40);
      };

      const nextLine = ()=>{
        if (lineIdx >= lines.length){
          story.arrivalDone = true;
          saveAll();
          updateStoryHeader();
          renderLog();
          showToast("ë„ì°©!");
          return;
        }
        typeLineArrival(lines[lineIdx], ()=>{
          lineIdx++;
          setTimeout(nextLine, 600);
        });
      };

      setTimeout(nextLine, 500);
    }

    function transitionToArrival(){
      // Move to arrival scene immediately (no blackout between train && arrival)
      story.phase = "arrival";
      story.arrivalDone = false;
      saveAll();
      renderStory();
      window.setTimeout(()=>{ runArrivalSequence(); }, 50);
    }

function transitionToGreatHall(){
      // short blackout + switch phase + play intro
      fade.classList.add("on");
      window.setTimeout(()=>{
        story.phase = "great_hall";
        story.greatHallIntroDone = false;
        story.sortingMode = false;
        saveAll();
        renderStory();
        window.setTimeout(()=>{ runGreatHallIntroSequence(); }, 50);
        window.setTimeout(()=> fade.classList.remove("on"), 240);
      }, 280);
    }

function startNewYear(){
      // ìƒˆ í•™ë…„ìœ¼ë¡œ ë„˜ì–´ê°ˆ ë•Œë„ í˜ì´ë“œ ì•„ì›ƒ íš¨ê³¼ë¥¼ ì£¼ê³ , íƒ€ì´í‹€ ë¡œê·¸ë§Œ ë‚¨ê¸´ë‹¤.
      fade.classList.add("on");
      window.setTimeout(()=>{
        const prevYear = Number.isFinite(story.currentYear) ? story.currentYear : 0;
        if (!story.logsByYear || typeof story.logsByYear !== "object") story.logsByYear = {};
        if (!story.logsByVacation || typeof story.logsByVacation !== "object") story.logsByVacation = {};
        let prevLogs = Array.isArray(story.log) ? story.log.slice() : [];

        // 5í•™ë…„ O.W.L ì„±ì ì„ ëª¨ë‘ ì—´ëŒí•œ ìƒíƒœì—ì„œ ìƒˆ í•™ë…„ìœ¼ë¡œ ë„˜ì–´ê°€ëŠ” ê²½ìš°,
        // 'ê¸°ë¡' íƒ­ì—ì„œ ë”°ë¡œ í™•ì¸í•  ìˆ˜ ìˆë„ë¡ ìš”ì•½ ë¡œê·¸ë¥¼ í•˜ë‚˜ ì¶”ê°€ë¡œ ë‚¨ê²¨ ë‘”ë‹¤.
        try {
          if (prevYear === 5 && story.phase === "owlResult"){
            const yearKey = String(prevYear);
            const byYearAll = (story.owlResultsByYear && typeof story.owlResultsByYear === "object") ? story.owlResultsByYear : null;
            const byYear = byYearAll ? byYearAll[yearKey] : null;
            if (byYear && typeof byYear === "object"){
              const idsWithResult = Object.keys(byYear);
              if (idsWithResult.length > 0){
                const lines = [];
                lines.push("5í•™ë…„ O.W.L ì„±ì  ìš”ì•½");
                idsWithResult.forEach(id=>{
                  const r = byYear[id];
                  if (!r) return;
                  const who = Array.isArray(characters) ? characters.find(c=>c.id===id) : null;
                  const name = (who && who.name) ? who.name : id;
                  const summary = r.summary || "";
                  lines.push(`${name}: ${summary}`);
                });
                const archiveBlock = {
                  turn: 5900 + prevYear,
                  title: "5í•™ë…„ O.W.L ì„±ì ",
                  meta: "O.W.L ì„±ì ",
                  lines
                };
                prevLogs.push(archiveBlock);
              }
            }
          }
        } catch(e){
          console.error(e);
        }

        const nextYear = prevYear + 1;

        // ì´ì „ í•™ë…„(1í•™ë…„ ì´ìƒ)ì˜ ë¡œê·¸ë¥¼ ì•„ì¹´ì´ë¸Œì— ìŒ“ì•„ ë‘”ë‹¤.
        if (prevLogs.length){
          if (story.phase === "vacation" && prevYear >= 1){
            // ë°©í•™ ìƒíƒœì—ì„œ ìƒˆ í•™ë…„ìœ¼ë¡œ ë„˜ì–´ê°€ëŠ” ê²½ìš° â†’ ë°©í•™ ì•„ì¹´ì´ë¸Œ (í•­ìƒ ì €ì¥)
            const spanKey = `${prevYear}-${nextYear}`;
            story.logsByVacation[String(spanKey)] = prevLogs;
          } else if (appOptions && appOptions.autoArchive !== false && prevYear >= 0){
            // ê·¸ ì™¸ì—ëŠ” autoArchive ì„¤ì •ì— ë”°ë¼ í•™ë…„ ì•„ì¹´ì´ë¸Œì— ì €ì¥ (í”„ë¡¤ë¡œê·¸ í¬í•¨)
            story.logsByYear[String(prevYear)] = prevLogs;
          }
        }

        story.currentYear = nextYear;

        const title = `ìƒˆí•™ë…„ì´ ì‹œì‘ëìŠµë‹ˆë‹¤. (${nextYear}í•™ë…„)`;
        const lineText = `ìƒˆí•™ë…„ì´ ì‹œì‘ëìŠµë‹ˆë‹¤.`;
        const block = { turn: 1000 + nextYear, title, meta: "í•™ë…„ ì‹œì‘", lines: [lineText] };
        story.log = [block];

        // í•™ë…„/ê³„ì ˆ ìƒíƒœ ì´ˆê¸°í™”
        story.phase = "school";
        story.seasonIndex = 0;
        story.seasonTurn = 0;
        story.readyForNewYear = false;

        // í”„ë¡¤ë¡œê·¸ëŠ” ëë‚¬ë‹¤ê³  í‘œì‹œ
        story.prologueDone = true;

        saveAll();
        renderLog();
        updateStoryHeader();
        window.setTimeout(()=> fade.classList.remove("on"), 240);
      }, 280);
    }


function resetStoryLogsSilently(){
      story = {
        phase: "train",
        trainTurn: 0,
        prologueDone: false,
        greatHallIntroDone: false,
        arrivalDone: false,
        sortingMode: false,
        currentYear: 0,
        logsByYear: {},
        logsByVacation: {},
        logViewMode: "current",
        seasonIndex: 0,
        seasonTurn: 0,
        vacationTurn: 0,
        log: [],
        affinity: {},
        readyForNewYear: false,
        owlExamByYear: {},
        owlResultsByYear: {},
        owlResultsShownByYear: {}
      };
      saveAll();
      updateStoryHeader();
      // Sorting panel visibility
      if (sortingPanel){
        sortingPanel.style.display = (story.phase === "great_hall" && story.sortingMode) ? "" : "none";
      }
      renderLog();
    }


    function runPrologueSequence(){
      if (characters.length < 2) return;
      if (story.prologueDone) return;

      const lines = [
        "ëœì»¹ ëœì»¹â€¦",
        "ëœì»¹ ëœì»¹â€¦",
        "...",
        "1991ë…„ 9ì›”, í˜¸ê·¸ì™€íŠ¸ í–‰ ì—´ì°¨.",
        "ì„ íƒë°›ì€ ì•„ì´ë“¤ì¸ ìš°ë¦¬ëŠ”, ìƒˆë¡œìš´ ì„¸ìƒì„ í–¥í•œ ì²« ê±¸ìŒì„ ë‚´ë”›ì—ˆë‹¤."
      ];

      story.prologueDone = false;
      story.log = (story.log || []).filter(b => b.turn !== 0);
      const block = { turn: 0, meta: "í”„ë¡¤ë¡œê·¸", lines: [] };
      story.log.unshift(block);
      saveAll();
      updateStoryHeader();
      // Sorting panel visibility
      if (sortingPanel){
        sortingPanel.style.display = (story.phase === "great_hall" && story.sortingMode) ? "" : "none";
      }
      renderLog();

      let lineIdx = 0;

      const typeLinePrologue = (text, cb)=>{
        let i = 0;
        block.lines.push("");
        renderLog();
        // ë¹ˆ ë¬¸ìì—´ì´ë©´ ì• ë‹ˆë©”ì´ì…˜ ì—†ì´ ë¹ˆ ì¤„ë§Œ ì¶”ê°€
        if (!text || text.length === 0){
          block.lines.push("");
          renderLog();
          cb && cb();
          return;
        }
        const interval = setInterval(()=>{
          block.lines[block.lines.length - 1] += text[i];
          renderLog();
          i++;
          if (i >= text.length){
            clearInterval(interval);
            cb && cb();
          }
        }, text.length <= 3 ? 200 : 40);
      };

      const nextLine = ()=>{
        if (lineIdx >= lines.length){
          story.prologueDone = true;
          saveAll();
          updateStoryHeader();
          renderLog();
          showToast("í”„ë¡¤ë¡œê·¸ ì¢…ë£Œ!");
          return;
        }
        typeLinePrologue(lines[lineIdx], ()=>{
          lineIdx++;
          setTimeout(nextLine, 600); // pause between lines
        });
      };

      setTimeout(nextLine, 500);
    }

    // Graduation epilogue & ending
    function getEpilogueBlock(){
      if (!Array.isArray(story.log)) story.log = [];
      let block = story.log.find(b => b && b.meta === "ì—í•„ë¡œê·¸");
      if (!block){
        block = { turn: 999, title: "ì—í•„ë¡œê·¸", meta: "ì—í•„ë¡œê·¸", lines: [] };
        story.log.push(block);
      }
      return block;
    }

    function getGraduationBlock(step){
      if (!Array.isArray(story.log)) story.log = [];
      // step: 1,2,3 ì— ë”°ë¼ ê°ê° 'ì¡¸ì—… (1/3)~(3/3)' íƒ€ì´í‹€ì„ ê°€ì§„ ë¸”ë¡ì„ ë§Œë“ ë‹¤.
      const safeStep = (step >= 1 && step <= 3) ? step : 1;
      let block = story.log.find(b => b && b.meta === "ì¡¸ì—…" && b.step === safeStep);
      if (!block){
        block = {
          turn: 1000 + safeStep,
          title: `ì¡¸ì—… (${safeStep}/3)`,
          meta: "ì¡¸ì—…",
          step: safeStep,
          lines: []
        };
        story.log.push(block);
      }
      return block;
    }

    function makeGraduationLogLine(){
      if (!Array.isArray(characters) || !characters.length) return "";
      const ids = shuffle(characters.map(c=>c.id));
      const maxSize = Math.min(3, ids.length);
      const size = Math.max(1, Math.min(maxSize, 1 + Math.floor(Math.random()*maxSize)));
      const A = nameOf(ids[0] || "");
      const B = nameOf(ids[1] || "");
      const C = nameOf(ids[2] || "");
      const oneList = [
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ì†ì— ì¥” ì¡¸ì—… ì¦ì„œë¥¼ í•œ ë²ˆ ë” ë°”ë¼ë³´ë”ë‹ˆ, ë§ˆì§€ë§‰ìœ¼ë¡œ ëŒ€ê°•ë‹¹ì„ ì²œì²œíˆ ë‘˜ëŸ¬ë³´ì•˜ë‹¤. ì´ì œ ëì´ë¼ëŠ” ì‹¤ê°ì´ ì¡°ê¸ˆì”© ë§ˆìŒì†ì— ë‚´ë ¤ì•‰ê¸° ì‹œì‘í–ˆë‹¤.`,
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ì—¬ì „íˆ ì–´ìƒ‰í•œ ê¸°ì¨ê³¼ ë¬˜í•œ ì•„ì‰¬ì›€ì´ ë’¤ì„ì¸ í‘œì •ìœ¼ë¡œ ì„œ ìˆì—ˆë‹¤. ê·¸ë™ì•ˆ ì§€ë‚˜ì˜¨ ë‚ ë“¤ì´ ìŠ¤ì³ ì§€ë‚˜ê°€ë“¯ ë– ì˜¤ë¥´ê³ , ì¡°ìš©íˆ ê³ ê°œë¥¼ ë„ë•ì˜€ë‹¤.`,
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ì‚¬ëŒë“¤ ì‚¬ì´ì—ì„œ ì‚´ì§ ë¬¼ëŸ¬ë‚˜, ì¡°ìš©í•œ í•œ êµ¬ì„ì—ì„œ ì¡¸ì—…ì‹ì„ ë°”ë¼ë³´ì•˜ë‹¤. ê·¸ ëˆˆë¹› ì†ì—ëŠ” ì–´ë¦´ ì  ëª¨ìŠµê³¼ ì•ìœ¼ë¡œì˜ ì‹œê°„ì´ í•¨ê»˜ ë‹´ê²¨ ìˆì—ˆë‹¤.`
      ];
      const twoList = [
        (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ì„œë¡œë¥¼ ë°”ë¼ë³´ë©° ì ì‹œ ì›ƒì—ˆë‹¤. ê¸¸ì—ˆë˜ ì‹œê°„ì´ ì—¬ê¸°ì„œ ëë‚¬ë‹¤ëŠ” ì‚¬ì‹¤ì„ ë‘˜ ë‹¤ ì•Œê³  ìˆì—ˆê³ , ì•ìœ¼ë¡œë„ ë‹¤ì‹œ ë§Œë‚  ê±°ë¼ëŠ” ë¯¿ìŒì„ ë§ˆìŒì†ì— ë‚¨ê²¨ ë‘ì—ˆë‹¤.`,
        (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ë§ˆì§€ë§‰ê¹Œì§€ ë‚˜ë€íˆ ì„œ ìˆì—ˆë‹¤. í—¤ì–´ì§€ê¸° ì‹«ì–´ ë¶™ì¡ëŠ” ëŒ€ì‹ , ì„œë¡œê°€ ì•ìœ¼ë¡œ ê±¸ì–´ê°ˆ ê¸¸ì„ ì‘ì›í•˜ëŠ” ë“¯í•œ ëˆˆë¹›ë§Œ ì¡°ìš©íˆ ì£¼ê³ ë°›ì•˜ë‹¤.`,
        (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ë§ì—†ì´ ì•…ìˆ˜ë¥¼ ë‚˜ëˆ„ê³ , ì²œì²œíˆ ì†ì„ ë†“ì•˜ë‹¤. ê·¸ ì§§ì€ ë™ì‘ ì•ˆì—, í•¨ê»˜ ë³´ë‚¸ ì‹œê°„ê³¼ ì•ìœ¼ë¡œë„ ì´ì–´ì§ˆ ì¸ì—°ì— ëŒ€í•œ ë¯¿ìŒì´ ë‹´ê²¨ ìˆì—ˆë‹¤.`
      ];
      const threeList = [
        (A,B,C)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;, ê·¸ë¦¬ê³  ::${C};;${pickJosa(C,"ì€ëŠ”")} ë§ˆì§€ë§‰ìœ¼ë¡œ í•œê³³ì— ëª¨ì—¬ ì„œ ìˆì—ˆë‹¤. ì„œë¡œì˜ ë‹¤ë¥¸ í‘œì •ë§Œ ë´ë„ ì–´ë–¤ ë§ˆìŒì¸ì§€ ì•Œ ìˆ˜ ìˆì„ ë§Œí¼, ì˜¤ë˜ í•¨ê»˜í–ˆë˜ ì‹œê°„ì´ ê·¸ë“¤ ì‚¬ì´ì— ìŒ“ì—¬ ìˆì—ˆë‹¤.`,
        (A,B,C)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;, ::${C};;${pickJosa(C,"ì€ëŠ”")} ê°ì ë‹¤ë¥¸ ë¯¸ë˜ë¥¼ í–¥í•´ ë‚˜ì•„ê°€ì•¼ í–ˆì§€ë§Œ, ê·¸ ì‚¬ì‹¤ì´ ì„œìš´í•¨ìœ¼ë¡œë§Œ ë‚¨ì§€ëŠ” ì•Šì•˜ë‹¤. í•¨ê»˜í•œ ì‹œê°„ì€ ì´ë¯¸ ì„¸ ì‚¬ëŒì˜ ì¼ë¶€ê°€ ë˜ì–´, ì•ìœ¼ë¡œë„ ê³„ì† ì´ì–´ì§ˆ ê²ƒì²˜ëŸ¼ ëŠê»´ì¡Œë‹¤.`,
        (A,B,C)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;, ê·¸ë¦¬ê³  ::${C};;${pickJosa(C,"ì€ëŠ”")} ëë‚´ ì›ƒìŒì„ í„°ëœ¨ë ¸ë‹¤. ë³µì¡í•œ ê°ì •ë³´ë‹¤, ë§ˆì§€ë§‰ê¹Œì§€ ì„œë¡œì™€ í•¨ê»˜ ìˆë‹¤ëŠ” ë‹¨ìˆœí•œ ì‚¬ì‹¤ì´ ë” í¬ê²Œ ëŠê»´ì§€ëŠ” ìˆœê°„ì´ì—ˆë‹¤.`
      ];

      if (size === 1){
        const f = oneList[Math.floor(Math.random()*oneList.length)];
        return f(A);
      } else if (size === 2){
        const f = twoList[Math.floor(Math.random()*twoList.length)];
        return f(A,B);
      } else {
        const f = threeList[Math.floor(Math.random()*threeList.length)];
        return f(A,B,C);
      }
    }

    
    function makeGraduationLinesForAll(){
      if (!Array.isArray(characters) || !characters.length) return [];
      const ids = shuffle(characters.map(c=>c.id));
      const result = [];
      const oneList = [
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ì†ì— ì¥” ì¡¸ì—… ì¦ì„œë¥¼ í•œ ë²ˆ ë” ë°”ë¼ë³´ë”ë‹ˆ, ë§ˆì§€ë§‰ìœ¼ë¡œ ëŒ€ê°•ë‹¹ì„ ì²œì²œíˆ ë‘˜ëŸ¬ë³´ì•˜ë‹¤. ì´ì œ ëì´ë¼ëŠ” ì‹¤ê°ì´ ì¡°ê¸ˆì”© ë§ˆìŒì†ì— ë‚´ë ¤ì•‰ê¸° ì‹œì‘í–ˆë‹¤.`,
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ì—¬ì „íˆ ì–´ìƒ‰í•œ ê¸°ì¨ê³¼ ë¬˜í•œ ì•„ì‰¬ì›€ì´ ë’¤ì„ì¸ í‘œì •ìœ¼ë¡œ ì„œ ìˆì—ˆë‹¤. ê·¸ë™ì•ˆ ì§€ë‚˜ì˜¨ ë‚ ë“¤ì´ ìŠ¤ì³ ì§€ë‚˜ê°€ë“¯ ë– ì˜¤ë¥´ê³ , ì¡°ìš©íˆ ê³ ê°œë¥¼ ë„ë•ì˜€ë‹¤.`,
        (A)=> `::${A};;${pickJosa(A,"ì€ëŠ”")} ì‚¬ëŒë“¤ ì‚¬ì´ì—ì„œ ì‚´ì§ ë¬¼ëŸ¬ë‚˜, ì¡°ìš©í•œ í•œ êµ¬ì„ì—ì„œ ì¡¸ì—…ì‹ì„ ë°”ë¼ë³´ì•˜ë‹¤. ê·¸ ëˆˆë¹› ì†ì—ëŠ” ì–´ë¦´ ì  ëª¨ìŠµê³¼ ì•ìœ¼ë¡œì˜ ì‹œê°„ì´ í•¨ê»˜ ë‹´ê²¨ ìˆì—ˆë‹¤.`
      ];
      const twoList = [
        (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ì„œë¡œë¥¼ ë°”ë¼ë³´ë©° ì ì‹œ ì›ƒì—ˆë‹¤. ê¸¸ì—ˆë˜ ì‹œê°„ì´ ì—¬ê¸°ì„œ ëë‚¬ë‹¤ëŠ” ì‚¬ì‹¤ì„ ë‘˜ ë‹¤ ì•Œê³  ìˆì—ˆê³ , ì•ìœ¼ë¡œë„ ë‹¤ì‹œ ë§Œë‚  ê±°ë¼ëŠ” ë¯¿ìŒì„ ë§ˆìŒì†ì— ë‚¨ê²¨ ë‘ì—ˆë‹¤.`,
        (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ë§ˆì§€ë§‰ê¹Œì§€ ë‚˜ë€íˆ ì„œ ìˆì—ˆë‹¤. í—¤ì–´ì§€ê¸° ì‹«ì–´ ë¶™ì¡ëŠ” ëŒ€ì‹ , ì„œë¡œê°€ ì•ìœ¼ë¡œ ê±¸ì–´ê°ˆ ê¸¸ì„ ì‘ì›í•˜ëŠ” ë“¯í•œ ëˆˆë¹›ë§Œ ì¡°ìš©íˆ ì£¼ê³ ë°›ì•˜ë‹¤.`,
        (A,B)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;${pickJosa(B,"ì€ëŠ”")} ë§ì—†ì´ ì•…ìˆ˜ë¥¼ ë‚˜ëˆ„ê³ , ì²œì²œíˆ ì†ì„ ë†“ì•˜ë‹¤. ê·¸ ì§§ì€ ë™ì‘ ì•ˆì—, í•¨ê»˜ ë³´ë‚¸ ì‹œê°„ê³¼ ì•ìœ¼ë¡œë„ ì´ì–´ì§ˆ ì¸ì—°ì— ëŒ€í•œ ë¯¿ìŒì´ ë‹´ê²¨ ìˆì—ˆë‹¤.`
      ];
      const threeList = [
        (A,B,C)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;, ê·¸ë¦¬ê³  ::${C};;${pickJosa(C,"ì€ëŠ”")} ë§ˆì§€ë§‰ìœ¼ë¡œ í•œê³³ì— ëª¨ì—¬ ì„œ ìˆì—ˆë‹¤. ì„œë¡œì˜ ë‹¤ë¥¸ í‘œì •ë§Œ ë´ë„ ì–´ë–¤ ë§ˆìŒì¸ì§€ ì•Œ ìˆ˜ ìˆì„ ë§Œí¼, ì˜¤ë˜ í•¨ê»˜í–ˆë˜ ì‹œê°„ì´ ê·¸ë“¤ ì‚¬ì´ì— ìŒ“ì—¬ ìˆì—ˆë‹¤.`,
        (A,B,C)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;, ::${C};;${pickJosa(C,"ì€ëŠ”")} ê°ì ë‹¤ë¥¸ ë¯¸ë˜ë¥¼ í–¥í•´ ë‚˜ì•„ê°€ì•¼ í–ˆì§€ë§Œ, ê·¸ ì‚¬ì‹¤ì´ ì„œìš´í•¨ìœ¼ë¡œë§Œ ë‚¨ì§€ëŠ” ì•Šì•˜ë‹¤. í•¨ê»˜í•œ ì‹œê°„ì€ ì´ë¯¸ ì„¸ ì‚¬ëŒì˜ ì¼ë¶€ê°€ ë˜ì–´, ì•ìœ¼ë¡œë„ ê³„ì† ì´ì–´ì§ˆ ê²ƒì²˜ëŸ¼ ëŠê»´ì¡Œë‹¤.`,
        (A,B,C)=> `::${A};;${pickJosa(A,"ê³¼ì™€")} ::${B};;, ê·¸ë¦¬ê³  ::${C};;${pickJosa(C,"ì€ëŠ”")} ëë‚´ ì›ƒìŒì„ í„°ëœ¨ë ¸ë‹¤. ë³µì¡í•œ ê°ì •ë³´ë‹¤, ë§ˆì§€ë§‰ê¹Œì§€ ì„œë¡œì™€ í•¨ê»˜ ìˆë‹¤ëŠ” ë‹¨ìˆœí•œ ì‚¬ì‹¤ì´ ë” í¬ê²Œ ëŠê»´ì§€ëŠ” ìˆœê°„ì´ì—ˆë‹¤.`
      ];

      let i = 0;
      while (i < ids.length){
        const remain = ids.length - i;
        let size = 1;
        if (remain === 1){
          size = 1;
        } else if (remain === 2){
          size = 2;
        } else {
          // 2ëª… ë˜ëŠ” 3ëª…ì”© ë¬¶ì–´ì„œ ì¡¸ì—… ì¥ë©´ì„ ë§Œë“¤ì–´ ì¤€ë‹¤.
          size = 2 + Math.floor(Math.random()*2); // 2 or 3
          if (size > remain) size = remain;
        }
        const A = nameOf(ids[i] || "");
        const B = nameOf(ids[i+1] || "");
        const C = nameOf(ids[i+2] || "");
        if (size === 1){
          const f = oneList[Math.floor(Math.random()*oneList.length)];
          result.push(f(A));
          i += 1;
        } else if (size === 2){
          const f = twoList[Math.floor(Math.random()*twoList.length)];
          result.push(f(A,B));
          i += 2;
        } else {
          const f = threeList[Math.floor(Math.random()*threeList.length)];
          result.push(f(A,B,C));
          i += 3;
        }
      }
      return result;
    }

function startGraduationEpilogue(){
      // ì¡¸ì—… ì—í•„ë¡œê·¸ ë™ì•ˆì—ëŠ” ì—í•„ë¡œê·¸ ì„œì‚¬ê°€ ëª¨ë‘ ì¶œë ¥ë  ë•Œê¹Œì§€ 'ë‹¤ìŒ' ë²„íŠ¼ì„ ë¹„í™œì„±í™”í•œë‹¤.
      if (storyNext){
        storyNext.disabled = true;
        storyNext.textContent = "â€¦";
      }
      // Fade out, clear existing logs, and start epilogue mode
      fade.classList.add("on");
      window.setTimeout(()=>{
        story.phase = "epilogue";
        story.epilogueStep = 1;
        story.log = [];
        // ì—í•„ë¡œê·¸ ì²« ì¸íŠ¸ë¡œ(7ë…„ì´ë¼ëŠ” ì„¸ì›”ì´ í˜ë €ë‹¤~)ê°€ ëª¨ë‘ ëë‚  ë•Œê¹Œì§€ëŠ” 'ë‹¤ìŒ' í´ë¦­ì„ ë§‰ëŠ”ë‹¤.
        story.epilogueIntroDone = false;
        const block = getEpilogueBlock();
        const lines = [
          "...",
          "7ë…„ì´ë¼ëŠ” ì„¸ì›”ì´ í˜ë €ë‹¤.",
          "ì—¬ì „íˆ ì•„ì´ ê°™ë˜ ë§ˆìŒì€ ê¿ˆì„ ë¨¹ê³  ë¬´ëŸ­ë¬´ëŸ­ ìë¼,",
          "ì–´ëŠìƒˆ ë¯¸ë˜ë¥¼ ë°”ë¼ë³´ëŠ” í•œ ëª… í•œ ëª…ì˜ ì–´ë¥¸ì´ ë˜ì–´ê°„ë‹¤.",
          "ëˆ„êµ°ê°€ëŠ” ì‚¬ë‘í–ˆë˜ ì‚¬ëŒë“¤ê³¼ ë§ˆì§€ë§‰ ì¸ì‚¬ë¥¼ ì£¼ê³ ë°›ê³ ,",
          "ë˜ ëˆ„êµ°ê°€ëŠ” ê¸°ëŒ€ê°ì— ë¶€í’€ì–´ ë§ˆìŒì´ ë¨¼ì € ì•ì„œê°€ëŠ” ë“¯í•˜ë‹¤."
        ];
        block.lines = [];
        saveAll();
        renderLog();
        updateStoryHeader();

        let lineIdx = 0;

        const typeLineEpilogue = (text, cb)=>{
          let i = 0;
          block.lines.push("");
          renderLog();
          const interval = setInterval(()=>{
            block.lines[block.lines.length - 1] += text[i];
            renderLog();
            i++;
            if (i >= text.length){
              clearInterval(interval);
              cb && cb();
            }
          }, text.length <= 3 ? 200 : 40);
        };

        const nextLine = ()=>{
          if (lineIdx >= lines.length){
            // ì—í•„ë¡œê·¸ ì¸íŠ¸ë¡œ í…ìŠ¤íŠ¸ê°€ ëª¨ë‘ ì¶œë ¥ë˜ì—ˆìœ¼ë¯€ë¡œ ì´ì œë¶€í„° ì¡¸ì—… ë¡œê·¸ ì§„í–‰ì„ í—ˆìš©í•œë‹¤.
            story.epilogueIntroDone = true;
            storyNext.textContent = "ë‹¤ìŒ";
            storyNext.disabled = false;
            saveAll();
            renderLog();
            return;
          }
          typeLineEpilogue(lines[lineIdx], ()=>{
            lineIdx++;
            setTimeout(nextLine, 600);
          });
        };

        // í˜ì´ë“œëŠ” ì§§ê²Œë§Œ ìœ ì§€í–ˆë‹¤ê°€, ì—í•„ë¡œê·¸ íƒ€ì´í•‘ì´ ì‹œì‘ë˜ë©´ ë°”ë¡œ ê±·ì–´ë‚¸ë‹¤.
        setTimeout(nextLine, 400);
        window.setTimeout(()=> fade.classList.remove("on"), 260);
      }, 380);
    }

function handleGraduationEpilogueClick(){
      if (story.phase !== "epilogue") return;
      if (typeof story.epilogueStep !== "number") story.epilogueStep = 1;
      const step = story.epilogueStep;
      // ì—í•„ë¡œê·¸ ì¸íŠ¸ë¡œ(7ë…„ì´ë¼ëŠ” ì„¸ì›”ì´ í˜ë €ë‹¤~ ë¶€ë¶„)ê°€ ì•„ì§ ëë‚˜ì§€ ì•Šì•˜ë‹¤ë©´, ì¡¸ì—… ë¡œê·¸ ì§„í–‰ì„ ë§‰ëŠ”ë‹¤.
      if (step === 1 && !story.epilogueIntroDone){
        return;
      }

      // steps 1~3: graduation logs (ì¡¸ì—… (1/3) ~ (3/3))
      if (step >= 1 && step <= 3){
        const block = getGraduationBlock(step);
        if (step === 1){
          // ì²« ë²ˆì§¸ í´ë¦­ì—ì„œëŠ” ëª¨ë“  ìºë¦­í„°ê°€ í•œ ë²ˆì”© ë“±ì¥í•˜ë„ë¡ ì¡¸ì—… ë¡œê·¸ë¥¼ ë§Œë“¤ì–´ ì¤€ë‹¤.
          const lines = makeGraduationLinesForAll();
          if (Array.isArray(lines) && lines.length){
            lines.forEach(l=>{
              if (!l || !String(l).trim()) return;
              block.lines.push(String(l));
            });
          }
        } else {
          // ë‘ ë²ˆì§¸, ì„¸ ë²ˆì§¸ í´ë¦­ì—ì„œë„ ëª¨ë“  ìºë¦­í„°ê°€ í•œ ë²ˆì”© ë“±ì¥í•˜ëŠ” ì¡¸ì—… ì¥ë©´ì„ ë³´ì—¬ì¤€ë‹¤.
          const lines = makeGraduationLinesForAll();
          if (Array.isArray(lines) && lines.length){
            lines.forEach(l=>{
              if (!l || !String(l).trim()) return;
              block.lines.push(String(l));
            });
          }
        }
        story.epilogueStep = step + 1;
        if (story.epilogueStep <= 3){
          storyNext.textContent = "ë‹¤ìŒ";
        } else {
          storyNext.textContent = "ìŠ¤í† ë¦¬ ì§„í–‰";
        }
        saveAll();
        renderLog();
        updateStoryHeader();
        return;
      }

      // step 4: final ending text (ì¡¸ì—… ë¡œê·¸ ì„¸ ê°œ ë’¤ì— ë¶™ëŠ” ì—”ë”©) - íƒ€ì´í•‘ ì—°ì¶œ
      if (step === 4){
        if (!Array.isArray(story.log)) story.log = [];
        const block = {
          turn: 2000,
          title: "ì—í•„ë¡œê·¸",
          meta: "ì—í•„ë¡œê·¸",
          lines: []
        };
        story.log.push(block);

        const endingLines = [
          "...",
          "ìœ ë… ë§‘ì€ ë‚ ì”¨ ìœ„ë¡œ, í•™ì‚¬ëª¨ê°€ í•˜ëŠ˜ì„ í–¥í•´ ë‚ ì•„ ì˜¤ë¥¸ë‹¤.",
          "ìˆ˜ ë§ì€ ì¼ë“¤ì´ ìˆì—ˆê³ , ë˜í•œ ìˆ˜ ì—†ëŠ” ë¬¼ìŒì´ ë‚¨ì•„ìˆì§€ë§Œ,",
          "ê²°êµ­ ê·¸ ëì—ì„œ ë¬»ê³  ì‹¶ì€ ê±´ ë‹¨ í•˜ë‚˜.",
          "ìš°ë¦¬ëŠ” ì–´ë–¤ ì–´ë¥¸ì´ ë ê¹Œ?"
        ];

        let lineIdx2 = 0;

        
        const typeLineEnding = (txt, cb)=>{
          let i = 0;
          block.lines.push("");
          renderLog();
          const delay = (txt.trim() === '...') ? 200 : 40;
          const interval = setInterval(()=>{
            block.lines[block.lines.length - 1] += txt[i];
            renderLog();
            i++;
            if (i >= txt.length){
              clearInterval(interval);
              cb && cb();
            }
          }, delay);
        };


        const nextEndingLine = ()=>{
          if (lineIdx2 >= endingLines.length){
            story.epilogueStep = 5;
            saveAll();
            renderLog();
            updateStoryHeader();
            // ì´í›„ íë¦„(ì§„ì˜ ëŒ€ë¦½ ë“±)ì€ ë‚˜ì¤‘ì— í™•ì¥
            storyNext.disabled = true;
            return;
          }
          const t = endingLines[lineIdx2];
          lineIdx2++;
          typeLineEnding(t, ()=>{
            setTimeout(nextEndingLine, 600);
          });
        };

        nextEndingLine();
        return;
      }
    }
    function resetHouses(doSave=false){
      try{
        characters.forEach(c=>{
          if (c && typeof c === "object" && "house" in c) delete c.house;
        });
        // also reset sorting progress (if any)
        if (story && typeof story === "object"){
          story.sortingMode = false;
          if (story.sortingState && typeof story.sortingState === "object"){
            story.sortingState = { stage:"idle", currentId:null, suggestedHouse:null };
          }
        }
        if (doSave) saveAll();
        // refresh roster chips if visible
        if (typeof renderStoryRoster === "function") renderStoryRoster();
      }catch(e){}
    }
function resetStoryLogs(){
      resetHouses(false);
      story = { phase:"train", trainTurn:0, prologueDone:false, greatHallIntroDone:false, arrivalDone:false, sortingMode:false, currentYear:0, logsByYear:{}, logsByVacation:{}, logViewMode:"current", log:[] };
      saveAll();
      updateStoryHeader();
      // Sorting panel visibility
      if (sortingPanel){
        sortingPanel.style.display = (story.phase === "great_hall" && story.sortingMode) ? "" : "none";
      }
      renderLog();
      showToast("ì´ˆê¸°í™”!");
    }

    
    function ensureSortingState(){
  if (!story.sortingState || typeof story.sortingState !== "object"){
    story.sortingState = { stage:"idle", currentId:null, suggestedHouse:null };
  }
}

function pushLogBlock(turn, title, meta){
  const block = { turn, title: title || "", meta: meta || "", lines: [] };
  story.log.push(block);
  saveAll(); renderLog();
  return block;
}

function pushHTMLLine(block, html){
  block.lines.push("@@HTML@@" + html);
  saveAll(); renderLog();
}

function buildCharButtons(){
  const remaining = characters.filter(c=>!c.house);
  if (!remaining.length) return "<span class='muted'>ëª¨ë“  í•™ìƒì˜ ë°°ì •ì´ ëë‚¬ìŠµë‹ˆë‹¤.</span>";
  return remaining.map(c=>{
    return `<button class="logBtn" data-action="pick-char" data-id="${c.id}">${escapeHTML(c.name)}</button>`;
  }).join("");
}

function computeHouseSuggestion(c){
  const t = new Set((c.traits || []).map(x=>String(x)));
  const mb = String(c.mbti || "").toUpperCase();
  const blood = String(c.blood || "");
  const score = { "ê·¸ë¦¬í•€ë„ë¥´":0, "ìŠ¬ë¦¬ë°ë¦°":0, "ë˜ë²ˆí´ë¡œ":0, "í›„í”Œí‘¸í”„":0 };

  // traits
  const add = (house, pts)=>{ score[house] = (score[house]||0) + pts; };
  const has = (x)=>t.has(x);

  // Gryffindor
  ["ëŒ€ë‹´í•¨","ëª¨í—˜ê°€","ì¶©ë™ì ","ì •ì˜ê°","ë°˜ê¶Œìœ„","ì¹´ë¦¬ìŠ¤ë§ˆ","ë¶„ë…¸ì¡°ì ˆê³¤ë€"].forEach(x=>{ if (has(x)) add("ê·¸ë¦¬í•€ë„ë¥´",2); });
  ["ë‚™ì²œì ","í˜¸ê¸°ì‹¬"].forEach(x=>{ if (has(x)) add("ê·¸ë¦¬í•€ë„ë¥´",1); });

  // Slytherin
  ["ì•¼ì‹¬ê°€","í˜ˆí†µì¤‘ì‹œ","ê¸°íšŒì£¼ì˜ì","ì§‘ì°©í˜•","ì™„ë²½ì£¼ì˜","í˜„ì‹¤ì£¼ì˜","ì´ì¤‘ì„±"].forEach(x=>{ if (has(x)) add("ìŠ¬ë¦¬ë°ë¦°",2); });
  ["ëƒ‰ì •í•¨","ëˆˆì¹˜ë¹ ë¦„"].forEach(x=>{ if (has(x)) add("ìŠ¬ë¦¬ë°ë¦°",1); });

  // Ravenclaw
  ["ì‹ ì¤‘í•¨","í˜¸ê¸°ì‹¬","ì´ìƒì£¼ì˜","ë¶„ì„ì ","ëƒ‰ì •í•¨","ì™„ë²½ì£¼ì˜"].forEach(x=>{ if (has(x)) add("ë˜ë²ˆí´ë¡œ",2); });
  ["ê³ ë…í•¨","ì˜ì‹¬ë§ìŒ"].forEach(x=>{ if (has(x)) add("ë˜ë²ˆí´ë¡œ",1); });

  // Hufflepuff
  ["ì„±ì‹¤í•¨","ì‚¬êµì ","í‰ë“±ì£¼ì˜","ë°°ë ¤","ì˜ì¡´ì ","ê¶Œìœ„ì¡´ì¤‘"].forEach(x=>{ if (has(x)) add("í›„í”Œí‘¸í”„",2); });
  ["ë‚™ì²œì ","í˜„ì‹¤ì£¼ì˜"].forEach(x=>{ if (has(x)) add("í›„í”Œí‘¸í”„",1); });

  // MBTI bias
  const N = mb.includes("N"), S = mb.includes("S"), Tm = mb.includes("T"), Fm = mb.includes("F");
  const J = mb.includes("J"), P = mb.includes("P");
  if (N && Tm) add("ë˜ë²ˆí´ë¡œ",2);
  if (N && J) add("ë˜ë²ˆí´ë¡œ",1);
  if (Tm && J) add("ìŠ¬ë¦¬ë°ë¦°",1);
  if (S && Fm) add("í›„í”Œí‘¸í”„",2);
  if (S && P) add("ê·¸ë¦¬í•€ë„ë¥´",1);
  if (Fm && P) add("ê·¸ë¦¬í•€ë„ë¥´",1);

  // Blood bias (light touch)
  if (blood === "ìˆœí˜ˆ"){ add("ìŠ¬ë¦¬ë°ë¦°",2); add("ê·¸ë¦¬í•€ë„ë¥´",1); }
  if (blood === "ë¨¸ê¸€ íƒœìƒ"){ add("í›„í”Œí‘¸í”„",2); add("ë˜ë²ˆí´ë¡œ",1); }
  if (blood === "í˜¼í˜ˆ"){ add("ê·¸ë¦¬í•€ë„ë¥´",1); add("í›„í”Œí‘¸í”„",1); }


  // Feat-based subtle bias
  const feats = Array.isArray(c.feats) ? c.feats : [];
  const hasFeat = (f)=>feats.includes(f);
  if (hasFeat("ê°€ë¬¸ì˜ í›„ê³„ì")){ add("ìŠ¬ë¦¬ë°ë¦°",1.5); add("ê·¸ë¦¬í•€ë„ë¥´",1.0); }
  if (hasFeat("ë¶€ìœ í•œ ì§‘ì•ˆ")){ add("ìŠ¬ë¦¬ë°ë¦°",0.8); add("ë˜ë²ˆí´ë¡œ",0.5); }
  if (hasFeat("ì±…ë²Œë ˆ")){ add("ë˜ë²ˆí´ë¡œ",1.2); add("í›„í”Œí‘¸í”„",0.5); }
  if (hasFeat("ì²œì¬")){ add("ë˜ë²ˆí´ë¡œ",1.5); add("ê·¸ë¦¬í•€ë„ë¥´",0.7); }
  if (hasFeat("ë¦¬ë”ì‹­")){ add("ê·¸ë¦¬í•€ë„ë¥´",1.4); }
  if (hasFeat("ìœ ë¦¬ ë©˜íƒˆ")){ add("í›„í”Œí‘¸í”„",0.7); add("ë˜ë²ˆí´ë¡œ",-0.3); }
  if (hasFeat("ë°˜í•­ì•„")){ add("ê·¸ë¦¬í•€ë„ë¥´",0.8); add("ìŠ¬ë¦¬ë°ë¦°",0.8); }
  if (hasFeat("í–‰ìš´ì•„")){ add("ê·¸ë¦¬í•€ë„ë¥´",0.5); add("ìŠ¬ë¦¬ë°ë¦°",0.5); }
  if (hasFeat("ë³‘ì•½")){ add("í›„í”Œí‘¸í”„",1.0); add("ìŠ¬ë¦¬ë°ë¦°",-0.5); }
  if (hasFeat("ìš´ë™ê´‘")){ add("ê·¸ë¦¬í•€ë„ë¥´",1.2); add("í›„í”Œí‘¸í”„",0.3); }

  // tie-breaker: stable ordering
  const order = ["ê·¸ë¦¬í•€ë„ë¥´","ìŠ¬ë¦¬ë°ë¦°","ë˜ë²ˆí´ë¡œ","í›„í”Œí‘¸í”„"];
  order.forEach((h,i)=>{ score[h]+= (0.001*(order.length-i)); });

  const best = Object.entries(score).sort((a,b)=>b[1]-a[1])[0][0];
  return best;
}


function generateHatMonologue(c){
  const t = new Set((c.traits || []).map(String));
  const mb = String(c.mbti || "").toUpperCase();
  const has = (x)=>t.has(x);

  const isENFP = mb === "ENFP";
  const isINTJ = mb === "INTJ";
  const isE = mb.startsWith("E");
  const isI = mb.startsWith("I");
  const isF = mb.includes("F");
  const isT = mb.includes("T");

  if ((has("ì‚¬êµì ") || isE) && isF){
    return "ê°ì •ì´ í’ë¶€í•˜ê³  ì‚¬ëŒë“¤ ì†ì—ì„œ ìˆ¨ ì‰¬ëŠ” ê²ƒì„ ì¦ê¸°ëŠ” ì•„ì´êµ°. ë¶„ëª… ìì‹ ì„ ì›ƒê²Œ ë§Œë“œëŠ” ê¸¸ì„ ìŠ¤ìŠ¤ë¡œ ì„ íƒí•˜ê²Œ ë  ê±°ì•¼.";
  }
  if (has("ì§‘ì°©í˜•") || (isF && (has("ì˜ì¡´ì ") || has("ì§‘ìš”í•¨")))){
    return "ê°ì •ê³¼ ì§‘ì°©ì´ ê¹Šì´ ì–½íŒ ì•„ì´ë¡œêµ°â€¦ ë§ˆìŒì´ í–¥í•˜ëŠ” ê³³ì´ë¼ë©´ ìœ„í—˜ì¡°ì°¨ ë©ˆì¶”ê²Œ í•˜ì§€ ëª»í•˜ê² ì§€.";
  }
  if (isINTJ || has("ì°¨ë¶„") || has("ë¶„ì„ì ") || has("ì‹ ì¤‘í•¨") || (isI && isT)){
    return "ê²‰ìœ¼ë¡œëŠ” ì¡°ìš©í•˜ì§€ë§Œ, ì°¨ê°‘ê²Œ ì„¸ìƒì„ ë°”ë¼ë³´ëŠ” ëˆˆì´ ìˆêµ°. ê³„ì‚°ëœ ì„ íƒì„ ì²œì²œíˆ, ê·¸ëŸ¬ë‚˜ í™•ì‹¤í•˜ê²Œ ìŒ“ì•„ ì˜¬ë¦´ ì•„ì´ì•¼.";
  }
  if (has("ì˜ì¡´ì ") || has("ë¶ˆì•ˆì •")){
    return "ì„¬ì„¸í•˜ê³  ì‰½ê²Œ í”ë“¤ë¦´ ê²ƒ ê°™ì€ ë§ˆìŒâ€¦ ê·¸ëŸ¬ë‚˜ ê·¸ê²ƒì´ ê³§ ê¹Šì´ì™€ ê°ê°ì´ ë˜ê² ì§€. ì´ ì•„ì´ì˜ ê¸¸ì€ ì£¼ë³€ì˜ ì‚¬ëŒê³¼ í™˜ê²½ì´ í¬ê²Œ ìƒ‰ì¹ í•˜ê²Œ ë  ê±°ì•¼.";
  }

  if (has("ëŒ€ë‹´í•¨") || has("ëª¨í—˜ê°€") || (isE && !isF)){
    return "ì£¼ì €í•¨ ì—†ì´ ì•ìœ¼ë¡œ ë‚˜ì•„ê°€ëŠ” ì„±ì§ˆì´ ëŠê»´ì§€ëŠ”êµ°. ìœ„í—˜ ì†ì—ì„œë„ ìê¸° ê¸¸ì„ ìŠ¤ìŠ¤ë¡œ ëš«ì–´ ë‚˜ê°ˆ ì•„ì´ì•¼.";
  }
  if (has("ë°˜í•­ì•„") || has("ë°˜ê¶Œìœ„")){
    return "ìœ„í—˜ì„ ë¬´ë¦…ì“°ê³ ì„œë¼ë„ ë„ì „í•˜ëŠ” ì•„ì´êµ°. ë‚¨ì˜ ì‹œì„ ì— í”ë“¤ë¦¬ì§€ ì•Šê³  ìì‹ ì˜ ê¸°ì¤€ìœ¼ë¡œ ê¸¸ì„ ì •í•˜ì§€. ê³ ì§‘ë„ ìˆì§€ë§Œâ€¦ ê·¸ë§Œí¼ êµ³ì„¸ê³  ê°•í•œ ìš©ê¸°ë¥¼ ì§€ë‹ˆê³  ìˆì–´.";
  }
  if (has("ì™„ë²½ì£¼ì˜") || has("í˜„ì‹¤ì£¼ì˜") || (isT && mb.endsWith("J"))){
    return "ì§ˆì„œì™€ ì™„ì„±ë„ë¥¼ ë¬´ì—‡ë³´ë‹¤ ì¤‘íˆ ì—¬ê¸°ëŠ”êµ°. ë¹„ë¡ ëŠë¦´ì§€ë¼ë„, ì ˆëŒ€ í—ˆíˆ¬ë£¨ ì§€ë‚˜ì¹˜ì§€ ì•Šì„ ì•„ì´ì•¼.";
  }
  if (has("í˜¸ê¸°ì‹¬") || (mb.includes("N") && isI)){
    return "ë‚¯ì„  ê²ƒ ì•ì—ì„œ ëˆˆì´ ë°˜ì§ì´ëŠ”êµ°. ì¡°ìš©íˆ, ê·¸ëŸ¬ë‚˜ ê¹Šìˆ™ì´ íŒŒê³ ë“¤ë©° ê²°êµ­ ìì‹ ë§Œì˜ ë‹µì„ ì°¾ì•„ë‚¼ ê±°ì•¼.";
  }

  return "ì•„ì§ì€ ìŠ¤ìŠ¤ë¡œì˜ ë¹›ì„ ì°¾ëŠ” ì¤‘ì´ë¡œêµ°â€¦ í•˜ì§€ë§Œ ë¨¸ì§€ì•Šì•„, ì´ ì•„ì´ì—ê²Œ ê°€ì¥ ì–´ìš¸ë¦¬ëŠ” ê¸¸ì„ ê¹¨ë‹«ê²Œ ë˜ê² ì§€.";
}

function startSortingPrompt(){
  ensureSortingState();
  if (story.phase !== "great_hall") return;
  story.sortingMode = true;

  const block = pushLogBlock(-3, "ë¶„ë¥˜ëª¨ì", "ê¸°ìˆ™ì‚¬ ë°°ì •ì‹");
  typewriterAppend(block, "Q. ëˆ„êµ¬ë¥¼ í˜¸ëª…í• ê¹Œ?", ()=>{
    pushHTMLLine(block, `<div class="logActionRow">${buildCharButtons()}</div>`);
    story.sortingState.stage = "picking";
    saveAll();
  });

  updateStoryHeader();
}

function beginSortingFor(id){
  ensureSortingState();
  const c = characters.find(x=>x.id===id);
  if (!c || c.house) return;


  const suggested = computeHouseSuggestion(c);
  story.sortingState = { stage:"revealing", currentId:id, suggestedHouse:suggested };
  saveAll();

  const block = pushLogBlock(-3, "ë¶„ë¥˜ëª¨ì", "");
  typewriterAppend(block, generateHatMonologue(c), ()=>{
    typewriterAppend(block, "...", ()=>{
      typewriterAppend(block, `${suggested}!`, ()=>{
        // choices after a short delay
        setTimeout(()=>{
          pushHTMLLine(block, `<div class="logActionRow">
            <button class="logBtn" data-action="accept-house" data-id="${id}">ë§ˆìŒì— ë“¤ì–´!</button>
            <button class="logBtn" data-action="reroll-house" data-id="${id}">ë‹¤ì‹œ ê³ ë¥¼ë˜!</button>
          </div>`);
          story.sortingState.stage = "choice";
          saveAll();
        }, 500);
      });
    });
  });

  updateStoryHeader();
}

function applyHouse(id, house, isManual){
  const c = characters.find(x=>x.id===id);
  if (!c) return;
  c.house = house;
  c.updatedAt = nowISO();

  // ë°°ì •ì´ ëë‚¬ìœ¼ë‹ˆ sortingStateë„ ì¢…ë£Œ ìƒíƒœë¡œ ì´ˆê¸°í™”
  if (story.sortingState && story.sortingState.currentId === id){
    story.sortingState = { stage:"idle", currentId:null, suggestedHouse:null };
  }

  // update roster dots (it uses c.house)
  saveAll();
  renderStoryRoster();
  renderLog();

  // announce && continue
  const block = pushLogBlock(-3, "ë°°ì • ì™„ë£Œ", "");
  const how = isManual ? "ì§ì ‘ ì„ íƒí•œ" : "ëª¨ìê°€ ì¶”ì²œí•œ";
  typewriterAppend(block, `${c.name}ì˜ ê¸°ìˆ™ì‚¬ëŠ” ${how} ê²°ê³¼ë¡œ ${house}ë¡œ ê²°ì •ë˜ì—ˆë‹¤.`, ()=>{
    // continue
    if (characters.every(x=>x.house)){
      typewriterAppend(block, "ëª¨ë“  ìºë¦­í„°ì˜ ê¸°ìˆ™ì‚¬ ë°°ì •ì´ ì™„ë£Œëë‹¤!", ()=>{
        storyDoneHint.textContent = "ëª¨ë“  í•™ìƒì˜ ê¸°ìˆ™ì‚¬ê°€ ë°°ì •ë˜ì—ˆìŠµë‹ˆë‹¤.";
        saveAll(); updateStoryHeader();
      });
    } else {
      setTimeout(()=> startSortingPrompt(), 450);
    }
  });
}

function showManualHousePick(id){
  ensureSortingState();
  const c = characters.find(x=>x.id===id);
  if (!c || c.house) return;
  story.sortingState = { stage:"manual", currentId:id, suggestedHouse: story.sortingState?.suggestedHouse || null };
  saveAll();

  const block = pushLogBlock(-3, "ë¶„ë¥˜ëª¨ì", "ì§ì ‘ ì„ íƒ");
  typewriterAppend(block, "ê·¸ëŸ¼ ì–´ë–¤ ê¸°ìˆ™ì‚¬ë¥¼ ì„ íƒí• ë˜?", ()=>{
    pushHTMLLine(block, `<div class="logActionRow">
      <button class="logBtn" data-action="pick-house" data-id="${id}" data-house="ê·¸ë¦¬í•€ë„ë¥´">ê·¸ë¦¬í•€ë„ë¥´</button>
      <button class="logBtn" data-action="pick-house" data-id="${id}" data-house="ìŠ¬ë¦¬ë°ë¦°">ìŠ¬ë¦¬ë°ë¦°</button>
      <button class="logBtn" data-action="pick-house" data-id="${id}" data-house="ë˜ë²ˆí´ë¡œ">ë˜ë²ˆí´ë¡œ</button>
      <button class="logBtn" data-action="pick-house" data-id="${id}" data-house="í›„í”Œí‘¸í”„">í›„í”Œí‘¸í”„</button>
    </div>`);
  });
}

// override: keep name but now uses log-based flow (no popup)
function showSortingPanel(){
  // called by the "ê¸°ìˆ™ì‚¬ ë°°ì •" button in Great Hall
  startSortingPrompt();
}


    function getOrCreateGreatHallBlock(){
      let block = (story.log || []).find(b=>b.turn === -1);
      if (!block){
        block = { turn: -1, meta: "ëŒ€ì—°íšŒì¥", lines: [] };
        story.log.push(block);
      }
      block.lines = Array.isArray(block.lines) ? block.lines : [];
      return block;
    }

    function pushHtmlLine(block, html){
      block.lines.push("@@HTML@@" + html);
    }

    function unassignedCharacters(){
      return characters.filter(c=>!c.house);
    }

    function chooseHouseByHeuristics(c){
      // Simple scoring based on blood + MBTI + traits keywords
      const mbti = (c.mbti || "").toUpperCase();
      const blood = (c.blood || "");
      const traits = (c.traits || []);

      const score = {"ê·¸ë¦¬í•€ë„ë¥´":0,"ìŠ¬ë¦¬ë°ë¦°":0,"ë˜ë²ˆí´ë¡œ":0,"í›„í”Œí‘¸í”„":0};

      const add = (h,v)=>{ score[h]+=v; };

      // Blood
      if (blood.includes("ìˆœí˜ˆ")) add("ìŠ¬ë¦¬ë°ë¦°", 1);
      if (blood.includes("ë¨¸ê¸€")) { add("í›„í”Œí‘¸í”„", 1); add("ê·¸ë¦¬í•€ë„ë¥´", 0.5); }
      if (blood.includes("í˜¼í˜ˆ")) { add("ê·¸ë¦¬í•€ë„ë¥´", 0.3); add("ë˜ë²ˆí´ë¡œ", 0.3); }

      // MBTI hints
      if (mbti.length===4){
        const [E,I,N,S,T,F,J,P] = [mbti[0]==='E', mbti[0]==='I', mbti[1]==='N', mbti[1]==='S', mbti[2]==='T', mbti[2]==='F', mbti[3]==='J', mbti[3]==='P'];
        if (E) add("ê·¸ë¦¬í•€ë„ë¥´", 0.8);
        if (I) add("ë˜ë²ˆí´ë¡œ", 0.4);
        if (N) add("ë˜ë²ˆí´ë¡œ", 1.0);
        if (S) add("í›„í”Œí‘¸í”„", 0.6);
        if (T) add("ìŠ¬ë¦¬ë°ë¦°", 0.9);
        if (F) add("í›„í”Œí‘¸í”„", 0.9);
        if (J) add("ìŠ¬ë¦¬ë°ë¦°", 0.4);
        if (P) add("ê·¸ë¦¬í•€ë„ë¥´", 0.3);
      }

      // Traits mapping (existing keywords; partial)
      const t = new Set(traits);
      const map = [
        ["ê·¸ë¦¬í•€ë„ë¥´", ["ëŒ€ë‹´í•¨","ì •ì˜ê°","ì¶©ë™ì ","ë¦¬ë”ì‹­","ë„ì „ì ","ì—´ì •ì "]],
        ["ìŠ¬ë¦¬ë°ë¦°", ["ì•¼ë§","ìŠ¹ë¶€ìš•","í˜„ì‹¤ì£¼ì˜","ëƒ‰ì •í•¨","ê³„ì‚°ì ","ì „ëµê°€"]],
        ["ë˜ë²ˆí´ë¡œ", ["í˜¸ê¸°ì‹¬","ë¶„ì„ì ","í•™êµ¬ì ","ì°½ì˜ì ","ì‹ ì¤‘í•¨","ì™„ë²½ì£¼ì˜"]],
        ["í›„í”Œí‘¸í”„", ["ì„±ì‹¤í•¨","ë°°ë ¤","í˜‘ë™ì ","ì¸ë‚´ì‹¬","ë”°ëœ»í•¨","ì¶©ì„±ì‹¬"]],
      ];
      map.forEach(([h,arr])=>{
        arr.forEach(k=>{
          if (t.has(k)) add(h, 2);
        });
      });

      // Small balancing: if no traits matched, give mild based on value-ish keywords
      if (![t].some(x=>map.some(([,arr])=>arr.includes(x)))){
        add("í›„í”Œí‘¸í”„", 0.2);
        add("ê·¸ë¦¬í•€ë„ë¥´", 0.2);
        add("ë˜ë²ˆí´ë¡œ", 0.2);
        add("ìŠ¬ë¦¬ë°ë¦°", 0.2);
      }

      // Pick max with random tie-break
      const entries = Object.entries(score);
      const max = Math.max(entries.map(([,v])=>v));
      const top = entries.filter(([,v])=>Math.abs(v-max)<1e-9).map(([h])=>h);
      return pick(top);
    }

    function logSortingQuestion(){
      const block = getOrCreateGreatHallBlock();
      block.lines.push("Q. ëˆ„êµ¬ë¥¼ í˜¸ëª…í• ê¹Œ?");
      const btns = unassignedCharacters().map(c=>`<button class="logBtn" data-act="pickStudent" data-id="${c.id}">${escapeHTML(c.name)}</button>`).join(" ");
      pushHtmlLine(block, `<div class="logActionRow">${btns || `<span class='muted'>ëª¨ë“  í•™ìƒì´ ë°°ì •ë˜ì—ˆìŠµë‹ˆë‹¤.</span>`}</div>`);
      saveAll();
      renderStoryRoster();
      renderLog();
      if (!unassignedCharacters().length){
        showToast("ê¸°ìˆ™ì‚¬ ë°°ì • ì™„ë£Œ!");
      }
    }

    function typewriterAppend(block, text, onDone){
      // appends a new line && types into it
      const idx = block.lines.length;
      block.lines.push("");
      saveAll(); renderLog();
      let i=0;
      const s = String(text);
      const delay = s.length <= 3 ? 200 : 40;
      const iv = setInterval(()=>{
        block.lines[idx] = s.slice(0, i+1);
        saveAll(); renderLog();
        i++;
        if (i >= s.length){
          clearInterval(iv);
          onDone && onDone();
        }
      }, delay);
    }

    function runHatForStudent(id){
      const c = characters.find(x=>x.id===id);
      if (!c) return;
      story.sorting.stage = "hat"; story.sorting.currentId = id; story.sorting.pendingHouse = null;
      saveAll();

      const block = getOrCreateGreatHallBlock();

      const q = generateHatMonologue(c);

      typewriterAppend(block, q, ()=>{
        setTimeout(()=>{
          typewriterAppend(block, "", ()=>{
            const house = chooseHouseByHeuristics(c);
            story.sorting.pendingHouse = house;
            saveAll();
            setTimeout(()=>{
              typewriterAppend(block, `${house}!`, ()=>{
                setTimeout(()=>{
                  // choices
                  pushHtmlLine(block, `<div class="logActionRow">
                    <button class="logBtn" data-act="acceptHouse">ë§ˆìŒì— ë“¤ì–´!</button>
                    <button class="logBtn" data-act="rerollHouse">ë‹¤ì‹œ ê³ ë¥¼ë˜!</button>
                  </div>`);
                  saveAll(); renderLog();
                  story.sorting.stage = "confirm";
                  saveAll();
                }, 700);
              });
            }, 600);
          });
        }, 600);
      });
    }

    function finalizeHouse(id, house){
      const c = characters.find(x=>x.id===id);
      if (!c) return;
      c.house = house;
      saveAll();
      renderStoryRoster();
    }

    function showHouseChoice(){
      const block = getOrCreateGreatHallBlock();
      pushHtmlLine(block, `<div class="logActionRow">
        <button class="logBtn" data-act="pickHouse" data-house="ê·¸ë¦¬í•€ë„ë¥´">ê·¸ë¦¬í•€ë„ë¥´</button>
        <button class="logBtn" data-act="pickHouse" data-house="ìŠ¬ë¦¬ë°ë¦°">ìŠ¬ë¦¬ë°ë¦°</button>
        <button class="logBtn" data-act="pickHouse" data-house="ë˜ë²ˆí´ë¡œ">ë˜ë²ˆí´ë¡œ</button>
        <button class="logBtn" data-act="pickHouse" data-house="í›„í”Œí‘¸í”„">í›„í”Œí‘¸í”„</button>
      </div>`);
      saveAll(); renderLog();
      story.sorting.stage = "choose_house";
      saveAll();
    }

    function startSortingLoop(){
      // Called when user presses 'ê¸°ìˆ™ì‚¬ ë°°ì •'
      story.sorting = { stage:"choose_student", currentId:null, pendingHouse:null };
      saveAll();
      logSortingQuestion();
    }


function renderStory(){
      renderStoryRoster();
      updateStoryHeader();
      // Sorting panel visibility
      if (sortingPanel){
        sortingPanel.style.display = (story.phase === "great_hall" && story.sortingMode) ? "" : "none";
      }
      renderLog();
    }

    function renderArchive(){
      if (!archiveYearTabs || !archiveLogBox) return;

      const byYear = (story.logsByYear && typeof story.logsByYear === "object") ? story.logsByYear : {};
      const byVac = (story.logsByVacation && typeof story.logsByVacation === "object") ? story.logsByVacation : {};
      const yearKeys = Object.keys(byYear);
      const vacKeys = Object.keys(byVac);

      archiveYearTabs.innerHTML = "";
      archiveLogBox.innerHTML = "";

      if (!yearKeys.length && !vacKeys.length){
        if (archiveHint) archiveHint.textContent = "ì•„ì§ ì´ì „ í•™ë…„ ë¡œê·¸ê°€ ì—†ìŠµë‹ˆë‹¤.";
        const empty = document.createElement('div');
        empty.className = "logLine";
        empty.textContent = "í•™ë…„ì´ ì‹œì‘ë˜ë©´, ì—¬ê¸°ì—ì„œ ì§€ë‚œ í•™ë…„ ê¸°ë¡ì„ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.";
        archiveLogBox.appendChild(empty);
        return;
      }

      if (archiveHint) archiveHint.textContent = "ë³´ê³  ì‹¶ì€ í•™ë…„ì´ë‚˜ ë°©í•™ ì¹©ì„ ëˆŒëŸ¬ ë¡œê·¸ë¥¼ í™•ì¸í•´ ì£¼ì„¸ìš”.";

      const years = yearKeys.map(k=>Number(k)).sort((a,b)=>a-b);
      const vacSpans = vacKeys.slice().sort((a,b)=>{
        const [as] = String(a).split("-");
        const [bs] = String(b).split("-");
        return Number(as||0) - Number(bs||0);
      });

      const hasYear = years.length > 0;
      const hasVac = vacSpans.length > 0;

      const defaultYear = hasYear ? years[years.length - 1] : null;
      const defaultVac = (!hasYear && hasVac) ? vacSpans[vacSpans.length - 1] : null;

      // í•™ë…„ ì¹©
      years.forEach(y=>{
        const chip = document.createElement('button');
        chip.type = "button";
        chip.className = "relTabChip";
        chip.dataset.year = String(y);
        chip.textContent = (y === 0) ? "í”„ë¡¤ë¡œê·¸" : `${y}í•™ë…„`;
        if (defaultYear !== null && y === defaultYear) chip.classList.add("active");
        chip.addEventListener('click', ()=>{
          Array.from(archiveYearTabs.querySelectorAll('.relTabChip')).forEach(el=>el.classList.remove('active'));
          chip.classList.add('active');
          renderArchiveYear(y);
        });
        archiveYearTabs.appendChild(chip);
      });

      // ë°©í•™ ì¹© (ì˜ˆ: "1-2 ë°©í•™")
      vacSpans.forEach(span=>{
        const chip = document.createElement('button');
        chip.type = "button";
        chip.className = "relTabChip";
        chip.dataset.vac = String(span);
        chip.textContent = `${span} ë°©í•™`;
        if (!hasYear && defaultVac !== null && span === defaultVac) chip.classList.add("active");
        chip.addEventListener('click', ()=>{
          Array.from(archiveYearTabs.querySelectorAll('.relTabChip')).forEach(el=>el.classList.remove('active'));
          chip.classList.add('active');
          renderArchiveVacation(span);
        });
        archiveYearTabs.appendChild(chip);
      });

      // O.W.L ì„±ì  ì¹© (5í•™ë…„ ì„±ì ì„ ì´ë¯¸ ì—´ëŒí–ˆê³  6í•™ë…„ ì´ìƒìœ¼ë¡œ ì˜¬ë¼ê°„ ê²½ìš°)
      try{
        const owlShown = story && story.owlResultsShownByYear && story.owlResultsShownByYear["5"];
        const reachedSixthYear = story && typeof story.currentYear === "number" && story.currentYear >= 6;
        if (owlShown && reachedSixthYear){
          const chip = document.createElement('button');
          chip.type = "button";
          chip.className = "relTabChip";
          chip.dataset.owl = "5";
          chip.textContent = "O.W.L ì„±ì ";
          chip.addEventListener('click', ()=>{
            Array.from(archiveYearTabs.querySelectorAll('.relTabChip')).forEach(el=>el.classList.remove('active'));
            chip.classList.add('active');
            renderArchiveOwl();
          });
          archiveYearTabs.appendChild(chip);
        }
      }catch(e){}

      if (hasYear){
        renderArchiveYear(defaultYear);
      } else if (hasVac){
        renderArchiveVacation(defaultVac);
      }
    }

    function renderArchiveOwl(){
      if (!archiveLogBox) return;
      archiveLogBox.innerHTML = "";

      const byYear = (story.logsByYear && typeof story.logsByYear === "object") ? story.logsByYear : {};
      const yearKeys = Object.keys(byYear);

      const owlBlocks = [];

      yearKeys.forEach(k=>{
        const list = Array.isArray(byYear[k]) ? byYear[k] : [];
        list.forEach(block=>{
          if (block && block.meta === "O.W.L"){
            owlBlocks.push({ year: Number(k), block });
          }
        });
      });

      if (!owlBlocks.length){
        const empty = document.createElement('div');
        empty.className = "logLine";
        empty.textContent = "ì•„ì§ O.W.L ì„±ì  ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.";
        archiveLogBox.appendChild(empty);
        return;
      }

      owlBlocks.sort((a,b)=>a.year - b.year);

      owlBlocks.forEach(item=>{
        const year = item.year;
        const block = item.block || {};
        const turn = document.createElement('div');
        turn.className = "logTurn";

        const left = document.createElement('div');
        const title = (block && (block.title || block.label)) ? (block.title || block.label) : `O.W.L ì„±ì  (${year}í•™ë…„)`;
        left.innerHTML = `<b>${escapeHTML(title)}</b>`;

        const right = document.createElement('div');
        right.className = "logMeta";
        right.textContent = `${year}í•™ë…„`;
        turn.appendChild(left);
        turn.appendChild(right);
        archiveLogBox.appendChild(turn);

        (block.lines || []).forEach(line=>{
          const div = document.createElement('div');
          div.className = "logLine";
          const s = String(line ?? "");
          if (s.startsWith("@@HTML@@")){
            div.innerHTML = s.slice(8);
          } else {
            div.innerHTML = escapeHTML(s).replaceAll("::", "<em>").replaceAll(";;", "</em>");
          }
          archiveLogBox.appendChild(div);
        });
      });

      archiveLogBox.scrollTop = archiveLogBox.scrollHeight;
    }

function renderArchiveYear(year){
   if (!archiveLogBox) return;
      archiveLogBox.innerHTML = "";

      const byYear = (story.logsByYear && typeof story.logsByYear === "object") ? story.logsByYear : {};
      const key = String(year);
      const list = Array.isArray(byYear[key]) ? byYear[key] : [];

      if (!list.length){
        const empty = document.createElement('div');
        empty.className = "logLine";
        empty.textContent = "í•´ë‹¹ í•™ë…„ì˜ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.";
        archiveLogBox.appendChild(empty);
        return;
      }

      list.forEach(block=>{
        const turn = document.createElement('div');
        turn.className = "logTurn";
        const left = document.createElement('div');

        let title = (block && (block.title || block.label)) ? (block.title || block.label) : "";
        if (!title){
          if (block && block.meta === "O.W.L") title = "O.W.L ì„±ì ";
          else if (block.turn === 0) title = "í”„ë¡¤ë¡œê·¸";
          else if (block.turn > 0) title = `ì—´ì°¨ Â· ${block.turn}ë²ˆì§¸ ìƒí˜¸ì‘ìš©`;
          else if (block.turn === -1) title = "ëŒ€ì—°íšŒì¥";
          else if (block.turn === -2) title = "ë„ì°©";
          else title = "ë¡œê·¸";
        }
        left.innerHTML = `<b>${escapeHTML(title)}</b>`;

        const right = document.createElement('div');
        right.className = "logMeta";
        right.textContent = block.meta || "";
        turn.appendChild(left); turn.appendChild(right);
        archiveLogBox.appendChild(turn);

        (block.lines || []).forEach(line=>{
          const div = document.createElement('div');
          div.className = "logLine";
          const s = String(line ?? "");
          if (s.startsWith("@@HTML@@")){
            div.innerHTML = s.slice(8);
          } else {
            div.innerHTML = escapeHTML(s).replaceAll("::", "<em>").replaceAll(";;", "</em>");
          }
          archiveLogBox.appendChild(div);
        });
      });

      archiveLogBox.scrollTop = archiveLogBox.scrollHeight;
    }

    function renderArchiveVacation(spanKey){
      if (!archiveLogBox) return;
      archiveLogBox.innerHTML = "";

      const byVac = (story.logsByVacation && typeof story.logsByVacation === "object") ? story.logsByVacation : {};
      const key = String(spanKey);
      const list = Array.isArray(byVac[key]) ? byVac[key] : [];

      if (!list.length){
        const empty = document.createElement('div');
        empty.className = "logLine";
        empty.textContent = "í•´ë‹¹ ë°©í•™ì˜ ê¸°ë¡ì´ ì—†ìŠµë‹ˆë‹¤.";
        archiveLogBox.appendChild(empty);
        return;
      }

      list.forEach(block=>{
        const turn = document.createElement('div');
        turn.className = "logTurn";
        const left = document.createElement('div');

        let title = (block && (block.title || block.label)) ? (block.title || block.label) : "";
        if (!title){
          if (block.turn === 0) title = "ë¡œê·¸";
          else title = "ë°©í•™ ë¡œê·¸";
        }
        left.innerHTML = `<b>${escapeHTML(title)}</b>`;

        const right = document.createElement('div');
        right.className = "logMeta";
        right.textContent = block.meta || "";
        turn.appendChild(left); turn.appendChild(right);
        archiveLogBox.appendChild(turn);

        (block.lines || []).forEach(line=>{
          const div = document.createElement('div');
          div.className = "logLine";
          const s = String(line ?? "");
          if (s.startsWith("@@HTML@@")){
            div.innerHTML = s.slice(8);
          } else {
            div.innerHTML = escapeHTML(s).replaceAll("::", "<em>").replaceAll(";;", "</em>");
          }
          archiveLogBox.appendChild(div);
        });
      });

      archiveLogBox.scrollTop = archiveLogBox.scrollHeight;
    }


    storyBackSettings.addEventListener('click', ()=>setMain("settings"));
    storyGoGraph.addEventListener('click', ()=>setMain("graph"));
    storyPrevLogs.addEventListener('click', ()=>{
      const byYear = (story.logsByYear && typeof story.logsByYear === "object") ? story.logsByYear : {};
      const byVac = (story.logsByVacation && typeof story.logsByVacation === "object") ? story.logsByVacation : {};
      if (!Object.keys(byYear).length && !Object.keys(byVac).length){
        if (appOptions && appOptions.autoArchive === false){
          showToast("ìŠ¤í† ë¦¬ ìë™ ì €ì¥ì´ êº¼ì ¸ ìˆì–´ì„œ ì´ì „ ë¡œê·¸ê°€ ì—†ìŠµë‹ˆë‹¤. ì„¤ì •ì—ì„œ ë‹¤ì‹œ ì¼œ ì£¼ì„¸ìš”.");
        } else {
          showToast("ì•„ì§ ì´ì „ í•™ë…„ ë˜ëŠ” ë°©í•™ ë¡œê·¸ê°€ ì—†ìŠµë‹ˆë‹¤.");
        }
        return;
      }
      story.logViewMode = "archive";
      setMain("archive");
    });
    archiveBackStory.addEventListener('click', ()=>{
      story.logViewMode = "current";
      setMain("story");
    });
    
storyNext.addEventListener('click', ()=>{
  // 0. ìƒˆ í•™ë…„ íƒ€ì´í‹€ê¹Œì§€ë§Œ ì§„í–‰ëœ ìƒíƒœë¼ë©´, ì²« í•™ê¸° ë¡œê·¸ê¹Œì§€ í•œ ë²ˆì— ìƒì„±
  if (story.currentYear >= 1 && story.phase !== "school"){
    if (Array.isArray(story.log) && story.log.length === 1 && story.log[0] && story.log[0].meta === "í•™ë…„ ì‹œì‘"){
      story.phase = "school";
      story.seasonIndex = Number.isFinite(story.seasonIndex) ? story.seasonIndex : 0;
      story.seasonTurn = Number.isFinite(story.seasonTurn) ? story.seasonTurn : 0;
      generateSchoolTurn();
      saveAll();
      updateStoryHeader();
      return;
    }
  }

    // Epilogue phase: handle graduation epilogue progression
  if (story.phase === "epilogue"){
    handleGraduationEpilogueClick();
    return;
  }

// 1. Train phase
  if (story.phase === "train"){
    if (story.trainTurn >= TRAIN_TURNS_MAX){
      transitionToArrival();
      return;
    }
    generateTrainTurn();
    updateStoryHeader();
    return;
  }

  // 2. Arrival phase
  if (story.phase === "arrival"){
    if (!story.arrivalDone) return;
    transitionToGreatHall();
    return;
  }

  // 3. Great Hall phase (ë°°ì •)
  if (story.phase === "great_hall"){
    if (!story.greatHallIntroDone) return;

    const allAssigned = characters.length && characters.every(c=>c.house);

    // ëª¨ë“  í•™ìƒ ë°°ì • ì™„ë£Œ í›„
    if (allAssigned){
      // ì•„ì§ í•™ë…„ì´ ì‹œì‘ë˜ì§€ ì•Šì•˜ë‹¤ë©´ â†’ ìƒˆ í•™ë…„ ì‹œì‘
      if (story.currentYear === 0){
        startNewYear();
      } else {
        showToast("ë°°ì • ì™„ë£Œ! (ë‹¤ìŒ ì¥ë©´ì€ ì•„ì§ ì¤€ë¹„ ì¤‘)");
      }
      return;
    }

    // Start / continue sorting prompt (log-based)
    showSortingPanel();
    return;
  }

  // 4. School phase (í•™ê¸° ì§„í–‰)
  if (story.phase === "school"){
    const maxPerSeason = 2;
    const idxRaw = Number.isFinite(story.seasonIndex) ? story.seasonIndex : 0;
    const idx = Math.min(Math.max(idxRaw, 0), 3);
    const doneInSeason = story.seasonTurn >= maxPerSeason;
    const isLastSeason = (idx === 3);
    const isYearPlayable = (story.currentYear >= 1 && story.currentYear < 7);

    // 4-1. ì•„ì§ ì´ ê³„ì ˆì—ì„œ ì§„í–‰í•  ë¡œê·¸ê°€ ë‚¨ì•„ ìˆë‹¤ë©´ â†’ ë¡œê·¸ë§Œ ìƒì„±
    if (!doneInSeason){
      generateSchoolTurn();
      saveAll();
      renderLog();
      updateStoryHeader();
      return;
    }

    // 4-2. ì´ ê³„ì ˆ ë¡œê·¸ëŠ” ëª¨ë‘ ì‚¬ìš©ëê³ , ì•„ì§ ë§ˆì§€ë§‰ ê³„ì ˆì´ ì•„ë‹ˆë¼ë©´ â†’ ë‹¤ìŒ ê³„ì ˆë¡œ ì´ë™í•˜ë©´ì„œ ìƒˆ ê³„ì ˆ ì²« ë¡œê·¸ê¹Œì§€ ìƒì„±
    if (!isLastSeason){
      story.seasonIndex = Math.min(idx + 1, 3);
      story.seasonTurn = 0;
      story.readyForNewYear = false;
      saveAll();
      // ìƒˆ ê³„ì ˆì˜ ì²« ë¡œê·¸ë¥¼ ë°”ë¡œ ìƒì„±
      generateSchoolTurn();
      saveAll();
      renderLog();
      updateStoryHeader();
      return;
    }

    // 4-3. ì—¬ë¦„ê¹Œì§€ ëª¨ë‘ ëë‚œ ìƒíƒœ (isLastSeason && doneInSeason) â†’ ë°©í•™ìœ¼ë¡œ ì§„ì…
    if (isLastSeason && doneInSeason && isYearPlayable){
      fade.classList.add("on");
      window.setTimeout(()=>{
        const year = Number.isFinite(story.currentYear) ? story.currentYear : 0;
        if (!story.logsByYear || typeof story.logsByYear !== "object") story.logsByYear = {};
        const prevLogs = Array.isArray(story.log) ? story.log.slice() : [];
        if (appOptions && appOptions.autoArchive !== false && year >= 1 && prevLogs.length){
          story.logsByYear[String(year)] = prevLogs;
        }
        // í•™ê¸° ë¡œê·¸ëŠ” ì•„ì¹´ì´ë¸Œì— ì €ì¥í•˜ê³ , í™”ë©´ì—ì„œëŠ” ë¹„ì›Œ ë‘”ë‹¤.
        story.log = [];
        story.phase = "vacation";
        story.vacationTurn = 0;
        story.readyForNewYear = false;
        saveAll();
        updateStoryHeader();
        // ë°©í•™ ì¥ë©´ìœ¼ë¡œë§Œ ì „í™˜í•˜ê³ , ì‹¤ì œ ë¡œê·¸ ìƒì„±ì€ ì‚¬ìš©ìê°€ ë²„íŠ¼ì„ ëˆŒë €ì„ ë•Œ ì§„í–‰
        // ì´ ì‹œì ì— story.logëŠ” ì´ë¯¸ ë¹„ì–´ ìˆìœ¼ë¯€ë¡œ, í™”ë©´ ë¡œê·¸ë„ ì´ˆê¸°í™”í•´ ì¤€ë‹¤.
        renderLog();
        window.setTimeout(()=> fade.classList.remove("on"), 240);
      }, 280);
      return;
    }

    // 4-4. 7í•™ë…„ ë“±, ë” ì´ìƒ ìƒˆ í•™ë…„ì´ ì—†ëŠ” ê²½ìš° â†’ ì¡¸ì—… ì—í•„ë¡œê·¸ë¡œ ì „í™˜
    startGraduationEpilogue();
    return;
  }

  // 5. O.W.L ì„±ì í‘œ í™”ë©´ì—ì„œ 'ìƒˆí•™ë…„ìœ¼ë¡œ ê°€ê¸°'
  if (story.phase === "owlResult"){
    const isYearPlayable = (story.currentYear >= 1 && story.currentYear < 7);
    if (isYearPlayable){
      startNewYear();
      story.vacationTurn = 0;
      story.readyForNewYear = false;
      saveAll();
      updateStoryHeader();
    } else {
      showToast("ì´ë¯¸ ë§ˆì§€ë§‰ í•™ë…„ì´ì•¼.");
    }
    return;
  }

  // 6. Vacation phase (ë°©í•™)
  if (story.phase === "vacation"){
    const maxVac = 3;
    const isYearPlayable = (story.currentYear >= 1 && story.currentYear < 7);

    // ì•„ì§ ë°©í•™ ë¡œê·¸ê°€ ë‚¨ì•„ ìˆë‹¤ë©´ â†’ ë°©í•™ ë¡œê·¸ë¥¼ ìƒì„±
    if (story.vacationTurn < maxVac){
      generateVacationTurn();
      saveAll();
      updateStoryHeader();
      return;
    }

    // ë°©í•™ ë¡œê·¸ë¥¼ ëª¨ë‘ ì±„ì› ë‹¤ë©´ â†’ 5í•™ë…„ì˜ ê²½ìš° O.W.L ì„±ì í‘œ ë¨¼ì € í™•ì¸
    if (story.currentYear === 5){
      const yearKey = String(story.currentYear);
      if (!story.owlResultsByYear || typeof story.owlResultsByYear !== "object") story.owlResultsByYear = {};
      if (!story.owlResultsShownByYear || typeof story.owlResultsShownByYear !== "object") story.owlResultsShownByYear = {};
      if (!story.owlResultsByYear[yearKey]){
        // ì´ ê²½ìš°ëŠ” ì˜ˆì™¸ì ìœ¼ë¡œ ì•„ì§ ì„±ì  ê³„ì‚°ì´ ì•ˆ ë˜ì–´ ìˆì„ ë•Œë§Œ ë°±ì—…ìœ¼ë¡œ í•œ ë²ˆ ê³„ì‚°
        calculateOwlResultsForYear(story.currentYear);
      }
      showOwlResultsForYear(story.currentYear);
      story.phase = "owlResult";
      story.owlResultsShownByYear[yearKey] = true;
      saveAll();
      updateStoryHeader();
      return;
    }

    // 5í•™ë…„ì´ ì•„ë‹ˆê³ , ë°©í•™ ë¡œê·¸ë¥¼ ëª¨ë‘ ì±„ì› ë‹¤ë©´ â†’ 'ìƒˆí•™ë…„ìœ¼ë¡œ ê°€ê¸°'
    if (isYearPlayable){
      startNewYear();
      story.vacationTurn = 0;
      story.readyForNewYear = false;
      saveAll();
      updateStoryHeader();
      return;
    }

    // 7í•™ë…„ ì´í›„ ë“±: ë°©í•™ì´ ëë‚¬ì§€ë§Œ ë” ê°ˆ í•™ë…„ì´ ì—†ëŠ” ê²½ìš° â†’ ì¡¸ì—… ì—í•„ë¡œê·¸ë¡œ ì „í™˜
    startGraduationEpilogue();
    return;
  }

  // 7. ê·¸ ë°–ì˜ ì˜ˆì™¸ ìƒíƒœì—ì„œëŠ” ê·¸ëƒ¥ ì•„ë¬´ ê²ƒë„ í•˜ì§€ ì•ŠìŒ
});

    storyReset.addEventListener('click', resetStoryLogs);

    // Fade transition to Story
    function fadeToStory(){
      // When restarting from Settings, also reset sorting results
      resetHouses(true);
      if (characters.length < 2){
        showToast("ìºë¦­í„° 2ëª… ì´ìƒ í•„ìš”!");
        return;
      }
      resetStoryLogsSilently();
      // Reset relations && affinity so a new playthrough starts from a clean slate
      relations = {};
      ensureRelationsAllPairs();
      story.affinity = {};
      saveAll();
      renderRelationsSummary();
      fade.classList.add("on");
      window.setTimeout(()=>{
        setMain("story");
        // Start prologue after entering story
        window.setTimeout(()=>{ runPrologueSequence(); }, 50);
        window.setTimeout(()=> fade.classList.remove("on"), 220);
      }, 380);
    }
    playBtn.addEventListener('click', fadeToStory);

    // Boot
    // Initialize form UI (MBTI + Traits + Feats) BEFORE loading state
    renderMbtiOptions();
    buildTraitsUI();
    renderFeats();
    loadAll();
    ensureRelationsAllPairs();
    saveAll();

    const sel = findSelected();
    if (sel) fillForm(sel);

    setStatus();
    refreshGates();
    updateButtons();
    updatePreview();
    renderList();
    renderRelationsSummary();

    ['input','change'].forEach(evt=>{
      elName.addEventListener(evt, ()=> updateButtons());
      elMbti.addEventListener(evt, ()=> updateButtons());
      elBlood.addEventListener(evt, ()=> updateButtons());
    });
    elQ.addEventListener('input', renderList);

    addBtn.addEventListener('click', addCharacter);
    updateBtn.addEventListener('click', updateCharacter);
    newBtn.addEventListener('click', newInput);
    deleteBtn.addEventListener('click', ()=> deleteCharacter(false));

    elName.addEventListener('keydown', (e)=>{
      if (e.key !== 'Enter') return;
      const v = validate(getForm());
      if (!v.ok) return;
      if (findSelected()) updateCharacter();
      else addCharacter();
    });
  
  </script>
  <script>
  // Year-cycle patch (non-destructive)
  ;
  </script>

</body>

</html>